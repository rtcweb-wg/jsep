<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Javascript Session Establishment Protocol</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 General Design of JSEP"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Other Approaches Considered"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Semantics and Syntax"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Signaling Model"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Session Descriptions and State Machine"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Session Description Format"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 ICE"/>
<link href="#rfc.section.3.4.1" rel="Chapter" title="3.4.1 ICE Gathering Overview"/>
<link href="#rfc.section.3.4.2" rel="Chapter" title="3.4.2 ICE Candidate Trickling"/>
<link href="#rfc.section.3.4.2.1" rel="Chapter" title="3.4.2.1 ICE Candidate Format"/>
<link href="#rfc.section.3.4.3" rel="Chapter" title="3.4.3 ICE Candidate Policy"/>
<link href="#rfc.section.3.4.4" rel="Chapter" title="3.4.4 ICE Candidate Pool"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Video Size Negotiation"/>
<link href="#rfc.section.3.5.1" rel="Chapter" title="3.5.1 Creating an imageattr Attribute"/>
<link href="#rfc.section.3.5.2" rel="Chapter" title="3.5.2 Interpreting an imageattr Attribute"/>
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Interactions With Forking"/>
<link href="#rfc.section.3.6.1" rel="Chapter" title="3.6.1 Sequential Forking"/>
<link href="#rfc.section.3.6.2" rel="Chapter" title="3.6.2 Parallel Forking"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Interface"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Methods"/>
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Constructor"/>
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 createOffer"/>
<link href="#rfc.section.4.1.3" rel="Chapter" title="4.1.3 createAnswer"/>
<link href="#rfc.section.4.1.4" rel="Chapter" title="4.1.4 SessionDescriptionType"/>
<link href="#rfc.section.4.1.4.1" rel="Chapter" title="4.1.4.1 Use of Provisional Answers"/>
<link href="#rfc.section.4.1.4.2" rel="Chapter" title="4.1.4.2 Rollback"/>
<link href="#rfc.section.4.1.5" rel="Chapter" title="4.1.5 setLocalDescription"/>
<link href="#rfc.section.4.1.6" rel="Chapter" title="4.1.6 setRemoteDescription"/>
<link href="#rfc.section.4.1.7" rel="Chapter" title="4.1.7 localDescription"/>
<link href="#rfc.section.4.1.8" rel="Chapter" title="4.1.8 remoteDescription"/>
<link href="#rfc.section.4.1.9" rel="Chapter" title="4.1.9 canTrickleIceCandidates"/>
<link href="#rfc.section.4.1.10" rel="Chapter" title="4.1.10 setConfiguration"/>
<link href="#rfc.section.4.1.11" rel="Chapter" title="4.1.11 addIceCandidate"/>
<link href="#rfc.section.5" rel="Chapter" title="5 SDP Interaction Procedures"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Requirements Overview"/>
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Implementation Requirements"/>
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Usage Requirements"/>
<link href="#rfc.section.5.1.3" rel="Chapter" title="5.1.3 Profile Names and Interoperability"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Constructing an Offer"/>
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Initial Offers"/>
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Subsequent Offers"/>
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Options Handling"/>
<link href="#rfc.section.5.2.3.1" rel="Chapter" title="5.2.3.1 OfferToReceiveAudio"/>
<link href="#rfc.section.5.2.3.2" rel="Chapter" title="5.2.3.2 OfferToReceiveVideo"/>
<link href="#rfc.section.5.2.3.3" rel="Chapter" title="5.2.3.3 IceRestart"/>
<link href="#rfc.section.5.2.3.4" rel="Chapter" title="5.2.3.4 VoiceActivityDetection"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Generating an Answer"/>
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Initial Answers"/>
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 Subsequent Answers"/>
<link href="#rfc.section.5.3.3" rel="Chapter" title="5.3.3 Options Handling"/>
<link href="#rfc.section.5.3.3.1" rel="Chapter" title="5.3.3.1 VoiceActivityDetection"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Processing a Local Description"/>
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Processing a Remote Description"/>
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Parsing a Session Description"/>
<link href="#rfc.section.5.6.1" rel="Chapter" title="5.6.1 Session-Level Parsing"/>
<link href="#rfc.section.5.6.2" rel="Chapter" title="5.6.2 Media Section Parsing"/>
<link href="#rfc.section.5.6.3" rel="Chapter" title="5.6.3 Semantics Verification"/>
<link href="#rfc.section.5.7" rel="Chapter" title="5.7 Applying a Local Description"/>
<link href="#rfc.section.5.8" rel="Chapter" title="5.8 Applying a Remote Description"/>
<link href="#rfc.section.5.9" rel="Chapter" title="5.9 Applying an Answer"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Configurable SDP Parameters"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Examples"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Simple Example"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Normal Examples"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations"/>
<link href="#rfc.section.9" rel="Chapter" title="9 IANA Considerations"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="11 References"/>
<link href="#rfc.references.1" rel="Chapter" title="11.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="11.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Change log"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.0 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Uberti, J., Jennings, C., and E. Rescorla, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-rtcweb-jsep-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2015-10-18" />
  <meta name="dct.abstract" content="This document describes the mechanisms for allowing a Javascript application to control the signaling plane of a multimedia session via the interface specified in the W3C RTCPeerConnection API, and discusses how this relates to existing signaling protocols." />
  <meta name="description" content="This document describes the mechanisms for allowing a Javascript application to control the signaling plane of a multimedia session via the interface specified in the W3C RTCPeerConnection API, and discusses how this relates to existing signaling protocols." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">J. Uberti</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Google</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">C. Jennings</td>
</tr>
<tr>
  <td class="left">Expires: April 20, 2016</td>
  <td class="right">Cisco</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">E. Rescorla, Ed.</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">October 18, 2015</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Javascript Session Establishment Protocol<br />
  <span class="filename">draft-ietf-rtcweb-jsep-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes the mechanisms for allowing a Javascript application to control the signaling plane of a multimedia session via the interface specified in the W3C RTCPeerConnection API, and discusses how this relates to existing signaling protocols.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on April 20, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">General Design of JSEP</a></li>
<li>1.2.   <a href="#rfc.section.1.2">Other Approaches Considered</a></li>
</ul><li>2.   <a href="#rfc.section.2">Terminology</a></li>
<li>3.   <a href="#rfc.section.3">Semantics and Syntax</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Signaling Model</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Session Descriptions and State Machine</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Session Description Format</a></li>
<li>3.4.   <a href="#rfc.section.3.4">ICE</a></li>
<ul><li>3.4.1.   <a href="#rfc.section.3.4.1">ICE Gathering Overview</a></li>
<li>3.4.2.   <a href="#rfc.section.3.4.2">ICE Candidate Trickling</a></li>
<ul><li>3.4.2.1.   <a href="#rfc.section.3.4.2.1">ICE Candidate Format</a></li>
</ul><li>3.4.3.   <a href="#rfc.section.3.4.3">ICE Candidate Policy</a></li>
<li>3.4.4.   <a href="#rfc.section.3.4.4">ICE Candidate Pool</a></li>
</ul><li>3.5.   <a href="#rfc.section.3.5">Video Size Negotiation</a></li>
<ul><li>3.5.1.   <a href="#rfc.section.3.5.1">Creating an imageattr Attribute</a></li>
<li>3.5.2.   <a href="#rfc.section.3.5.2">Interpreting an imageattr Attribute</a></li>
</ul><li>3.6.   <a href="#rfc.section.3.6">Interactions With Forking</a></li>
<ul><li>3.6.1.   <a href="#rfc.section.3.6.1">Sequential Forking</a></li>
<li>3.6.2.   <a href="#rfc.section.3.6.2">Parallel Forking</a></li>
</ul></ul><li>4.   <a href="#rfc.section.4">Interface</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Methods</a></li>
<ul><li>4.1.1.   <a href="#rfc.section.4.1.1">Constructor</a></li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">createOffer</a></li>
<li>4.1.3.   <a href="#rfc.section.4.1.3">createAnswer</a></li>
<li>4.1.4.   <a href="#rfc.section.4.1.4">SessionDescriptionType</a></li>
<ul><li>4.1.4.1.   <a href="#rfc.section.4.1.4.1">Use of Provisional Answers</a></li>
<li>4.1.4.2.   <a href="#rfc.section.4.1.4.2">Rollback</a></li>
</ul><li>4.1.5.   <a href="#rfc.section.4.1.5">setLocalDescription</a></li>
<li>4.1.6.   <a href="#rfc.section.4.1.6">setRemoteDescription</a></li>
<li>4.1.7.   <a href="#rfc.section.4.1.7">localDescription</a></li>
<li>4.1.8.   <a href="#rfc.section.4.1.8">remoteDescription</a></li>
<li>4.1.9.   <a href="#rfc.section.4.1.9">canTrickleIceCandidates</a></li>
<li>4.1.10.   <a href="#rfc.section.4.1.10">setConfiguration</a></li>
<li>4.1.11.   <a href="#rfc.section.4.1.11">addIceCandidate</a></li>
</ul></ul><li>5.   <a href="#rfc.section.5">SDP Interaction Procedures</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Requirements Overview</a></li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Implementation Requirements</a></li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Usage Requirements</a></li>
<li>5.1.3.   <a href="#rfc.section.5.1.3">Profile Names and Interoperability</a></li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Constructing an Offer</a></li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Initial Offers</a></li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Subsequent Offers</a></li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Options Handling</a></li>
<ul><li>5.2.3.1.   <a href="#rfc.section.5.2.3.1">OfferToReceiveAudio</a></li>
<li>5.2.3.2.   <a href="#rfc.section.5.2.3.2">OfferToReceiveVideo</a></li>
<li>5.2.3.3.   <a href="#rfc.section.5.2.3.3">IceRestart</a></li>
<li>5.2.3.4.   <a href="#rfc.section.5.2.3.4">VoiceActivityDetection</a></li>
</ul></ul><li>5.3.   <a href="#rfc.section.5.3">Generating an Answer</a></li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">Initial Answers</a></li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">Subsequent Answers</a></li>
<li>5.3.3.   <a href="#rfc.section.5.3.3">Options Handling</a></li>
<ul><li>5.3.3.1.   <a href="#rfc.section.5.3.3.1">VoiceActivityDetection</a></li>
</ul></ul><li>5.4.   <a href="#rfc.section.5.4">Processing a Local Description</a></li>
<li>5.5.   <a href="#rfc.section.5.5">Processing a Remote Description</a></li>
<li>5.6.   <a href="#rfc.section.5.6">Parsing a Session Description</a></li>
<ul><li>5.6.1.   <a href="#rfc.section.5.6.1">Session-Level Parsing</a></li>
<li>5.6.2.   <a href="#rfc.section.5.6.2">Media Section Parsing</a></li>
<li>5.6.3.   <a href="#rfc.section.5.6.3">Semantics Verification</a></li>
</ul><li>5.7.   <a href="#rfc.section.5.7">Applying a Local Description</a></li>
<li>5.8.   <a href="#rfc.section.5.8">Applying a Remote Description</a></li>
<li>5.9.   <a href="#rfc.section.5.9">Applying an Answer</a></li>
</ul><li>6.   <a href="#rfc.section.6">Configurable SDP Parameters</a></li>
<li>7.   <a href="#rfc.section.7">Examples</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Simple Example</a></li>
<li>7.2.   <a href="#rfc.section.7.2">Normal Examples</a></li>
</ul><li>8.   <a href="#rfc.section.8">Security Considerations</a></li>
<li>9.   <a href="#rfc.section.9">IANA Considerations</a></li>
<li>10.   <a href="#rfc.section.10">Acknowledgements</a></li>
<li>11.   <a href="#rfc.references">References</a></li>
<ul><li>11.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>11.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Change log</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#sec.introduction" id="sec.introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">This document describes how the W3C WEBRTC RTCPeerConnection interface<a href="#W3C.WD-webrtc-20140617">[W3C.WD-webrtc-20140617]</a> is used to control the setup, management and teardown of a multimedia session.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#sec.general-design-of-jsep" id="sec.general-design-of-jsep">General Design of JSEP</a></h1>
<p id="rfc.section.1.1.p.1">The thinking behind WebRTC call setup has been to fully specify and control the media plane, but to leave the signaling plane up to the application as much as possible. The rationale is that different applications may prefer to use different protocols, such as the existing SIP or Jingle call signaling protocols, or something custom to the particular application, perhaps for a novel use case. In this approach, the key information that needs to be exchanged is the multimedia session description, which specifies the necessary transport and media configuration information necessary to establish the media plane.</p>
<p id="rfc.section.1.1.p.2">With these considerations in mind, this document describes the Javascript Session Establishment Protocol (JSEP) that allows for full control of the signaling state machine from Javascript.  JSEP removes the browser almost entirely from the core signaling flow, which is instead handled by the Javascript making use of two interfaces: (1) passing in local and remote session descriptions and (2) interacting with the ICE state machine.  </p>
<p id="rfc.section.1.1.p.3">In this document, the use of JSEP is described as if it always occurs between two browsers. Note though in many cases it will actually be between a browser and some kind of server, such as a gateway or MCU. This distinction is invisible to the browser; it just follows the instructions it is given via the API.</p>
<p id="rfc.section.1.1.p.4">JSEP's handling of session descriptions is simple and straightforward. Whenever an offer/answer exchange is needed, the initiating side creates an offer by calling a createOffer() API. The application optionally modifies that offer, and then uses it to set up its local config via the setLocalDescription() API. The offer is then sent off to the remote side over its preferred signaling mechanism (e.g., WebSockets); upon receipt of that offer, the remote party installs it using the setRemoteDescription() API.</p>
<p id="rfc.section.1.1.p.5">To complete the offer/answer exchange, the remote party uses the createAnswer() API to generate an appropriate answer, applies it using the setLocalDescription() API, and sends the answer back to the initiator over the signaling channel. When the initiator gets that answer, it installs it using the setRemoteDescription() API, and initial setup is complete. This process can be repeated for additional offer/answer exchanges.</p>
<p id="rfc.section.1.1.p.6">Regarding ICE <a href="#RFC5245">[RFC5245]</a>, JSEP decouples the ICE state machine from the overall signaling state machine, as the ICE state machine must remain in the browser, because only the browser has the necessary knowledge of candidates and other transport info.  Performing this separation also provides additional flexibility; in protocols that decouple session descriptions from transport, such as Jingle, the session description can be sent immediately and the transport information can be sent when available. In protocols that don't, such as SIP, the information can be used in the aggregated form. Sending transport information separately can allow for faster ICE and DTLS startup, since ICE checks can start as soon as any transport information is available rather than waiting for all of it.</p>
<p id="rfc.section.1.1.p.7">Through its abstraction of signaling, the JSEP approach does require the application to be aware of the signaling process. While the application does not need to understand the contents of session descriptions to set up a call, the application must call the right APIs at the right times, convert the session descriptions and ICE information into the defined messages of its chosen signaling protocol, and perform the reverse conversion on the messages it receives from the other side.</p>
<p id="rfc.section.1.1.p.8">One way to mitigate this is to provide a Javascript library that hides this complexity from the developer; said library would implement a given signaling protocol along with its state machine and serialization code, presenting a higher level call-oriented interface to the application developer. For example, libraries exist to adapt the JSEP API into an API suitable for a SIP or XMPP.  Thus, JSEP provides greater control for the experienced developer without forcing any additional complexity on the novice developer.</p>
<h1 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#sec.other-approaches-consider" id="sec.other-approaches-consider">Other Approaches Considered</a></h1>
<p id="rfc.section.1.2.p.1">One approach that was considered instead of JSEP was to include a lightweight signaling protocol. Instead of providing session descriptions to the API, the API would produce and consume messages from this protocol. While providing a more high-level API, this put more control of signaling within the browser, forcing the browser to have to understand and handle concepts like signaling glare. In addition, it prevented the application from driving the state machine to a desired state, as is needed in the page reload case.</p>
<p id="rfc.section.1.2.p.2">A second approach that was considered but not chosen was to decouple the management of the media control objects from session descriptions, instead offering APIs that would control each component directly. This was rejected based on a feeling that requiring exposure of this level of complexity to the application programmer would not be beneficial; it would result in an API where even a simple example would require a significant amount of code to orchestrate all the needed interactions, as well as creating a large API surface that needed to be agreed upon and documented. In addition, these API points could be called in any order, resulting in a more complex set of interactions with the media subsystem than the JSEP approach, which specifies how session descriptions are to be evaluated and applied.</p>
<p id="rfc.section.1.2.p.3">One variation on JSEP that was considered was to keep the basic session description-oriented API, but to move the mechanism for generating offers and answers out of the browser. Instead of providing createOffer/createAnswer methods within the browser, this approach would instead expose a getCapabilities API which would provide the application with the information it needed in order to generate its own session descriptions. This increases the amount of work that the application needs to do; it needs to know how to generate session descriptions from capabilities, and especially how to generate the correct answer from an arbitrary offer and the supported capabilities.  While this could certainly be addressed by using a library like the one mentioned above, it basically forces the use of said library even for a simple example. Providing createOffer/createAnswer avoids this problem, but still allows applications to generate their own offers/answers (to a large extent) if they choose, using the description generated by createOffer as an indication of the browser's capabilities.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#sec.terminology" id="sec.terminology">Terminology</a></h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#sec.semantics-and-syntax" id="sec.semantics-and-syntax">Semantics and Syntax</a></h1>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#sec.signaling-model" id="sec.signaling-model">Signaling Model</a></h1>
<p id="rfc.section.3.1.p.1">JSEP does not specify a particular signaling model or state machine, other than the generic need to exchange session descriptions in the fashion described by <a href="#RFC3264">[RFC3264]</a> (offer/answer) in order for both sides of the session to know how to conduct the session. JSEP provides mechanisms to create offers and answers, as well as to apply them to a session.  However, the browser is totally decoupled from the actual mechanism by which these offers and answers are communicated to the remote side, including addressing, retransmission, forking, and glare handling.  These issues are left entirely up to the application; the application has complete control over which offers and answers get handed to the browser, and when.</p>
<div id="rfc.figure.1"/>
<div id="fig-sigModel"/>
<pre>
    +-----------+                               +-----------+
    |  Web App  |&lt;--- App-Specific Signaling --&gt;|  Web App  |
    +-----------+                               +-----------+
          ^                                            ^
          |  SDP                                       |  SDP
          V                                            V
    +-----------+                                +-----------+
    |  Browser  |&lt;----------- Media ------------&gt;|  Browser  |
    +-----------+                                +-----------+
</pre>
<p class="figure">Figure 1: JSEP Signaling Model</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#sec.session-descriptions-and-" id="sec.session-descriptions-and-">Session Descriptions and State Machine</a></h1>
<p id="rfc.section.3.2.p.1">In order to establish the media plane, the user agent needs specific parameters to indicate what to transmit to the remote side, as well as how to handle the media that is received. These parameters are determined by the exchange of session descriptions in offers and answers, and there are certain details to this process that must be handled in the JSEP APIs.</p>
<p id="rfc.section.3.2.p.2">Whether a session description applies to the local side or the remote side affects the meaning of that description. For example, the list of codecs sent to a remote party indicates what the local side is willing to receive, which, when intersected with the set of codecs the remote side supports, specifies what the remote side should send.  However, not all parameters follow this rule; for example, the DTLS-SRTP parameters <a href="#RFC5763">[RFC5763]</a> sent to a remote party indicate what certificate the local side will use in DTLS setup, and thereby what the remote party should expect to receive; the remote party will have to accept these parameters, with no option to choose different values.  </p>
<p id="rfc.section.3.2.p.3">In addition, various RFCs put different conditions on the format of offers versus answers. For example, an offer may propose an arbitrary number of media streams (i.e. m= sections), but an answer must contain the exact same number as the offer.</p>
<p id="rfc.section.3.2.p.4">Lastly, while the exact media parameters are only known only after an offer and an answer have been exchanged, it is possible for the offerer to receive media after they have sent an offer and before they have received an answer. To properly process incoming media in this case, the offerer's media handler must be aware of the details of the offer before the answer arrives.</p>
<p id="rfc.section.3.2.p.5">Therefore, in order to handle session descriptions properly, the user agent needs: </p>

<ol>
  <li>To know if a session description pertains to the local or remote side.</li>
  <li>To know if a session description is an offer or an answer.</li>
  <li>To allow the offer to be specified independently of the answer.</li>
</ol>

<p> JSEP addresses this by adding both setLocalDescription and setRemoteDescription methods and having session description objects contain a type field indicating the type of session description being supplied. This satisfies the requirements listed above for both the offerer, who first calls setLocalDescription(sdp [offer]) and then later setRemoteDescription(sdp [answer]), as well as for the answerer, who first calls setRemoteDescription(sdp [offer]) and then later setLocalDescription(sdp [answer]).</p>
<p id="rfc.section.3.2.p.6">JSEP also allows for an answer to be treated as provisional by the application. Provisional answers provide a way for an answerer to communicate initial session parameters back to the offerer, in order to allow the session to begin, while allowing a final answer to be specified later. This concept of a final answer is important to the offer/answer model; when such an answer is received, any extra resources allocated by the caller can be released, now that the exact session configuration is known. These "resources" can include things like extra ICE components, TURN candidates, or video decoders.  Provisional answers, on the other hand, do no such deallocation results; as a result, multiple dissimilar provisional answers can be received and applied during call setup.</p>
<p id="rfc.section.3.2.p.7">In <a href="#RFC3264">[RFC3264]</a>, the constraint at the signaling level is that only one offer can be outstanding for a given session, but at the media stack level, a new offer can be generated at any point. For example, when using SIP for signaling, if one offer is sent, then cancelled using a SIP CANCEL, another offer can be generated even though no answer was received for the first offer. To support this, the JSEP media layer can provide an offer via the createOffer() method whenever the Javascript application needs one for the signaling.  The answerer can send back zero or more provisional answers, and finally end the offer-answer exchange by sending a final answer. The state machine for this is as follows:</p>
<div id="rfc.figure.2"/>
<div id="fig-state-machine"/>
<pre>
                    setRemote(OFFER)               setLocal(PRANSWER)
                        /-----\                               /-----\
                        |     |                               |     |
                        v     |                               v     |
         +---------------+    |                +---------------+    |
         |               |----/                |               |----/
         |               | setLocal(PRANSWER)  |               |
         |  Remote-Offer |------------------- &gt;| Local-Pranswer|
         |               |                     |               |
         |               |                     |               |
         +---------------+                     +---------------+
              ^   |                                   |
              |   | setLocal(ANSWER)                  |
setRemote(OFFER)  |                                   |
              |   V                  setLocal(ANSWER) |
         +---------------+                            |
         |               |                            |
         |               |&lt;---------------------------+
         |    Stable     |
         |               |&lt;---------------------------+
         |               |                            |
         +---------------+          setRemote(ANSWER) |
              ^   |                                   |
              |   | setLocal(OFFER)                   |
setRemote(ANSWER) |                                   |
              |   V                                   |
         +---------------+                     +---------------+
         |               |                     |               |
         |               | setRemote(PRANSWER) |               |
         |  Local-Offer  |------------------- &gt;|Remote-Pranswer|
         |               |                     |               |
         |               |----\                |               |----\
         +---------------+    |                +---------------+    |
                        ^     |                               ^     |
                        |     |                               |     |
                        \-----/                               \-----/
                    setLocal(OFFER)               setRemote(PRANSWER)
</pre>
<p class="figure">Figure 2: JSEP State Machine</p>
<p/>
<p id="rfc.section.3.2.p.9">Aside from these state transitions there is no other difference between the handling of provisional ("pranswer") and final ("answer") answers.</p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#sec.session-description-forma" id="sec.session-description-forma">Session Description Format</a></h1>
<p id="rfc.section.3.3.p.1">In the WebRTC specification, session descriptions are formatted as SDP messages. While this format is not optimal for manipulation from Javascript, it is widely accepted, and frequently updated with new features. Any alternate encoding of session descriptions would have to keep pace with the changes to SDP, at least until the time that this new encoding eclipsed SDP in popularity. As a result, JSEP currently uses SDP as the internal representation for its session descriptions.</p>
<p id="rfc.section.3.3.p.2">However, to simplify Javascript processing, and provide for future flexibility, the SDP syntax is encapsulated within a SessionDescription object, which can be constructed from SDP, and be serialized out to SDP. If future specifications agree on a JSON format for session descriptions, we could easily enable this object to generate and consume that JSON.</p>
<p id="rfc.section.3.3.p.3">Other methods may be added to SessionDescription in the future to simplify handling of SessionDescriptions from Javascript. In the meantime, Javascript libraries can be used to perform these manipulations.</p>
<p id="rfc.section.3.3.p.4">Note that most applications should be able to treat the SessionDescriptions produced and consumed by these various API calls as opaque blobs; that is, the application will not need to read or change them. The W3C WebRTC API specification will provide appropriate APIs to allow the application to control various session parameters, which will provide the necessary information to the browser about what sort of SessionDescription to produce.</p>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#sec.ice" id="sec.ice">ICE</a></h1>
<h1 id="rfc.section.3.4.1"><a href="#rfc.section.3.4.1">3.4.1.</a> <a href="#sec.ice-gather-overview" id="sec.ice-gather-overview">ICE Gathering Overview</a></h1>
<p id="rfc.section.3.4.1.p.1">JSEP gathers ICE candidates as needed by the application.  Collection of ICE candidates is referred to as a gathering phase, and this is triggered either by the addition of a new or recycled m= line to the local session description, or new ICE credentials in the description, indicating an ICE restart. Use of new ICE credentials can be triggered explicitly by the application, or implicitly by the browser in response to changes in the ICE configuration.  </p>
<p id="rfc.section.3.4.1.p.2">When a new gathering phase starts, the ICE Agent will notify the application that gathering is occurring through an event. Then, when each new ICE candidate becomes available, the ICE Agent will supply it to the application via an additional event; these candidates will also automatically be added to the local session description. Finally, when all candidates have been gathered, an event will be dispatched to signal that the gathering process is complete.</p>
<p id="rfc.section.3.4.1.p.3">Note that gathering phases only gather the candidates needed by new/recycled/restarting m= lines; other m= lines continue to use their existing candidates.</p>
<h1 id="rfc.section.3.4.2"><a href="#rfc.section.3.4.2">3.4.2.</a> <a href="#sec.ice-candidate-trickling" id="sec.ice-candidate-trickling">ICE Candidate Trickling</a></h1>
<p id="rfc.section.3.4.2.p.1">Candidate trickling is a technique through which a caller may incrementally provide candidates to the callee after the initial offer has been dispatched; the semantics of "Trickle ICE" are defined in <a href="#I-D.ietf-mmusic-trickle-ice">[I-D.ietf-mmusic-trickle-ice]</a>. This process allows the callee to begin acting upon the call and setting up the ICE (and perhaps DTLS) connections immediately, without having to wait for the caller to gather all possible candidates.  This results in faster media setup in cases where gathering is not performed prior to initiating the call.</p>
<p id="rfc.section.3.4.2.p.2">JSEP supports optional candidate trickling by providing APIs, as described above, that provide control and feedback on the ICE candidate gathering process.  Applications that support candidate trickling can send the initial offer immediately and send individual candidates when they get the notified of a new candidate; applications that do not support this feature can simply wait for the indication that gathering is complete, and then create and send their offer, with all the candidates, at this time.</p>
<p id="rfc.section.3.4.2.p.3">Upon receipt of trickled candidates, the receiving application will supply them to its ICE Agent. This triggers the ICE Agent to start using the new remote candidates for connectivity checks.</p>
<h1 id="rfc.section.3.4.2.1"><a href="#rfc.section.3.4.2.1">3.4.2.1.</a> <a href="#sec.ice-candidate-format" id="sec.ice-candidate-format">ICE Candidate Format</a></h1>
<p id="rfc.section.3.4.2.1.p.1">As with session descriptions, the syntax of the IceCandidate object provides some abstraction, but can be easily converted to and from the SDP candidate lines.</p>
<p id="rfc.section.3.4.2.1.p.2">The candidate lines are the only SDP information that is contained within IceCandidate, as they represent the only information needed that is not present in the initial offer (i.e., for trickle candidates). This information is carried with the same syntax as the "candidate-attribute" field defined for ICE. For example:</p>
<pre>
candidate:1 1 UDP 1694498815 192.0.2.33 10000 typ host
</pre>
<p id="rfc.section.3.4.2.1.p.3">The IceCandidate object also contains fields to indicate which m= line it should be associated with. The m= line can be identified in one of two ways; either by a m= line index, or a MID.  The m= line index is a zero-based index, with index N referring to the N+1th m= line in the SDP sent by the entity which sent the IceCandidate.  The MID uses the "media stream identification" attribute, as defined in <a href="#RFC5888">[RFC5888]</a>, Section 4, to identify the m= line.  JSEP implementations creating an ICE Candidate object MUST populate both of these fields. Implementations receiving an ICE Candidate object MUST use the MID if present, or the m= line index, if not (as it could have come from a non-JSEP endpoint).</p>
<h1 id="rfc.section.3.4.3"><a href="#rfc.section.3.4.3">3.4.3.</a> <a href="#sec.ice-candidate-policy" id="sec.ice-candidate-policy">ICE Candidate Policy</a></h1>
<p id="rfc.section.3.4.3.p.1">Typically, when gathering ICE candidates, the browser will gather all possible forms of initial candidates - host, server reflexive, and relay. However, in certain cases, applications may want to have more specific control over the gathering process, due to privacy or related concerns. For example, one may want to suppress the use of host candidates, to avoid exposing information about the local network, or go as far as only using relay candidates, to leak as little location information as possible (note that these choices come with corresponding operational costs). To accomplish this, the browser MUST allow the application to restrict which ICE candidates are used in a session. In addition, administrators may also wish to control the set of ICE candidates, and so the browser SHOULD also allow control via local policy, with the most restrictive policy prevailing.  </p>
<p id="rfc.section.3.4.3.p.2">There may also be cases where the application wants to change which types of candidates are used while the session is active. A prime example is where a callee may initially want to use only relay candidates, to avoid leaking location information to an arbitrary caller, but then change to use all candidates (for lower operational cost) once the user has indicated they want to take the call. For this scenario, the browser MUST allow the candidate policy to be changed in mid-session, subject to the aforementioned interactions with local policy.</p>
<p id="rfc.section.3.4.3.p.3">To administer the ICE candidate policy, the browser will determine the current setting at the start of each gathering phase.  Then, during the gathering phase, the browser MUST NOT expose candidates disallowed by the current policy to the application, use them as the source of connectivity checks, or indirectly expose them via other fields, such as the raddr/rport attributes for other ICE candidates.  Later, if a different policy is specified by the application, the application can apply it by kicking off a new gathering phase via an ICE restart.  </p>
<h1 id="rfc.section.3.4.4"><a href="#rfc.section.3.4.4">3.4.4.</a> <a href="#sec.ice-candidate-pool" id="sec.ice-candidate-pool">ICE Candidate Pool</a></h1>
<p id="rfc.section.3.4.4.p.1">JSEP applications typically inform the browser to begin ICE gathering via the information supplied to setLocalDescription, as this is where the app specifies the number of media streams, and thereby ICE components, for which to gather candidates. However, to accelerate cases where the application knows the number of ICE components to use ahead of time, it may ask the browser to gather a pool of potential ICE candidates to help ensure rapid media setup.  </p>
<p id="rfc.section.3.4.4.p.2">When setLocalDescription is eventually called, and the browser goes to gather the needed ICE candidates, it SHOULD start by checking if any candidates are available in the pool.  If there are candidates in the pool, they SHOULD be handed to the application immediately via the ICE candidate event.  If the pool becomes depleted, either because a larger-than-expected number of ICE components is used, or because the pool has not had enough time to gather candidates, the remaining candidates are gathered as usual.  </p>
<p id="rfc.section.3.4.4.p.3">One example of where this concept is useful is an application that expects an incoming call at some point in the future, and wants to minimize the time it takes to establish connectivity, to avoid clipping of initial media. By pre-gathering candidates into the pool, it can exchange and start sending connectivity checks from these candidates almost immediately upon receipt of a call. Note though that by holding on to these pre-gathered candidates, which will be kept alive as long as they may be needed, the application will consume resources on the STUN/TURN servers it is using.  </p>
<h1 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#sec.imageattr" id="sec.imageattr">Video Size Negotiation</a></h1>
<p id="rfc.section.3.5.p.1">Video size negotiation is the process through which a receiver can use the "a=imageattr" SDP attribute <a href="#RFC6236">[RFC6236]</a> to indicate what video frame sizes it is capable of receiving. A receiver may have hard limits on what its video decoder can process, or it may wish to constrain what it receives due to application preferences, e.g. a specific size for the window in which the video will be displayed.  </p>
<h1 id="rfc.section.3.5.1"><a href="#rfc.section.3.5.1">3.5.1.</a> Creating an imageattr Attribute</h1>
<p id="rfc.section.3.5.1.p.1">In order to determine the limits on what video resolution a receiver wants to receive, it will intersect its decoder hard limits with any mandatory constraints that have been applied to the associated MediaStreamTrack. If the decoder limits are unknown, e.g. when using a software decoder, the mandatory constraints are used directly. For the answerer, these mandatory constraints can be applied to the remote MediaStreamTracks that are created by a setRemoteDescription call, and will affect the output of the ensuing createAnswer call. Any constraints set after setLocalDescription is used to set the answer will result in a new offer-answer exchange. For the offerer, because it does not know about any remote MediaStreamTracks until it receives the answer, the offer can only reflect decoder hard limits.  If the offerer wishes to set mandatory constraints on video resolution, it must do so after receiving the answer, and the result will be a new offer-answer to communicate them.</p>
<p id="rfc.section.3.5.1.p.2">If there are no known decoder limits or mandatory constraints, the "a=imageattr" attribute SHOULD be omitted.</p>
<p id="rfc.section.3.5.1.p.3">Otherwise, an "a=imageattr" attribute is created with "recv" direction, and the resulting resolution space formed by intersecting the decoder limits and constraints is used to specify its minimum and maximum x= and y= values. If the intersection is the null set, i.e., there are no resolutions that are permitted by both the decoder and the mandatory constraints, this SHOULD be represented by x=0 and y=0 values.</p>
<p id="rfc.section.3.5.1.p.4">The rules here express a single set of preferences, and therefore, the "a=imageattr" q= value is not important. It SHOULD be set to 1.0.</p>
<p id="rfc.section.3.5.1.p.5">The "a=imageattr" field is payload type specific.  When all video codecs supported have the same capabilities, use of a single attribute, with the wildcard payload type (*), is RECOMMENDED.  However, when the supported video codecs have differing capabilities, specific "a=imageattr" attributes MUST be inserted for each payload type.  </p>
<p id="rfc.section.3.5.1.p.6">As an example, consider a system with a HD-capable, multiformat video decoder, where the application has constrained the received track to at most 360p. In this case, the implemention would generate this attribute:</p>
<p id="rfc.section.3.5.1.p.7">a=imageattr:* recv [x=[16:640],y=[16:360],q=1.0]</p>
<h1 id="rfc.section.3.5.2"><a href="#rfc.section.3.5.2">3.5.2.</a> Interpreting an imageattr Attribute</h1>
<p><a href="#RFC6236">[RFC6236]</a> defines "a=imageattr" to be an advisory field. This means that it does not absolutely constrain the video formats that the sender can use, but gives an indication of the preferred values.</p>
<p id="rfc.section.3.5.2.p.2">This specification prescribes more specific behavior.  When a sender of a given MediaStreamTrack, which is producing video of a certain resolution, receives an "a=imageattr recv" attribute, it MUST first check to see if the original resolution meets the criteria specified in the attribute, and transmit it untouched if so. If the original resolution is too large for the attribute criteria, the sender SHOULD apply downscaling to the output of the MediaStreamTrack in order to satisfy the criteria.</p>
<p id="rfc.section.3.5.2.p.3">If the receiver requires a minimum resolution which is greater than the native resolution of the video, upscaling is needed, but this may not be appropriate in all cases. To address this concern, the application can set an upscaling policy for each sent track.  For this case, if upscaling is permitted by policy, the sender SHOULD apply upscaling in order to provide the desired resolution.  Otherwise, the sender MUST NOT apply upscaling.  The sender SHOULD NOT upscale in other cases, even if the policy permits it.  </p>
<p id="rfc.section.3.5.2.p.4">If there is no appropriate and permitted scaling mechanism that allows the received criteria to be satisfied, the sender MUST NOT transmit the track.  </p>
<p id="rfc.section.3.5.2.p.5">In the special case of receiving a maximum resolution of [0, 0], as described above, the sender MUST NOT transmit the track.  </p>
<h1 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6.</a> <a href="#sec.interactions-with-forking" id="sec.interactions-with-forking">Interactions With Forking</a></h1>
<p id="rfc.section.3.6.p.1">Some call signaling systems allow various types of forking where an SDP Offer may be provided to more than one device. For example, SIP <a href="#RFC3261">[RFC3261]</a> defines both a "Parallel Search" and "Sequential Search". Although these are primarily signaling level issues that are outside the scope of JSEP, they do have some impact on the configuration of the media plane that is relevant. When forking happens at the signaling layer, the Javascript application responsible for the signaling needs to make the decisions about what media should be sent or received at any point of time, as well as which remote endpoint it should communicate with; JSEP is used to make sure the media engine can make the RTP and media perform as required by the application. The basic operations that the applications can have the media engine do are: </p>

<ul>
  <li>Start exchanging media with a given remote peer, but keep all the resources reserved in the offer.</li>
  <li>Start exchanging media with a given remote peer, and free any resources in the offer that are not being used.</li>
</ul>
<h1 id="rfc.section.3.6.1"><a href="#rfc.section.3.6.1">3.6.1.</a> <a href="#sec.sequential-forking" id="sec.sequential-forking">Sequential Forking</a></h1>
<p id="rfc.section.3.6.1.p.1">Sequential forking involves a call being dispatched to multiple remote callees, where each callee can accept the call, but only one active session ever exists at a time; no mixing of received media is performed.</p>
<p id="rfc.section.3.6.1.p.2">JSEP handles sequential forking well, allowing the application to easily control the policy for selecting the desired remote endpoint.  When an answer arrives from one of the callees, the application can choose to apply it either as a provisional answer, leaving open the possibility of using a different answer in the future, or apply it as a final answer, ending the setup flow.</p>
<p id="rfc.section.3.6.1.p.3">In a "first-one-wins" situation, the first answer will be applied as a final answer, and the application will reject any subsequent answers. In SIP parlance, this would be ACK + BYE.</p>
<p id="rfc.section.3.6.1.p.4">In a "last-one-wins" situation, all answers would be applied as provisional answers, and any previous call leg will be terminated.  At some point, the application will end the setup process, perhaps with a timer; at this point, the application could reapply the existing remote description as a final answer.</p>
<h1 id="rfc.section.3.6.2"><a href="#rfc.section.3.6.2">3.6.2.</a> <a href="#sec.parallel-forking" id="sec.parallel-forking">Parallel Forking</a></h1>
<p id="rfc.section.3.6.2.p.1">Parallel forking involves a call being dispatched to multiple remote callees, where each callee can accept the call, and multiple simultaneous active signaling sessions can be established as a result. If multiple callees send media at the same time, the possibilities for handling this are described in Section 3.1 of <a href="#RFC3960">[RFC3960]</a>. Most SIP devices today only support exchanging media with a single device at a time, and do not try to mix multiple early media audio sources, as that could result in a confusing situation. For example, consider having a European ringback tone mixed together with the North American ringback tone - the resulting sound would not be like either tone, and would confuse the user. If the signaling application wishes to only exchange media with one of the remote endpoints at a time, then from a media engine point of view, this is exactly like the sequential forking case.</p>
<p id="rfc.section.3.6.2.p.2">In the parallel forking case where the Javascript application wishes to simultaneously exchange media with multiple peers, the flow is slightly more complex, but the Javascript application can follow the strategy that <a href="#RFC3960">[RFC3960]</a> describes using UPDATE. The UPDATE approach allows the signaling to set up a separate media flow for each peer that it wishes to exchange media with. In JSEP, this offer used in the UPDATE would be formed by simply creating a new PeerConnection and making sure that the same local media streams have been added into this new PeerConnection. Then the new PeerConnection object would produce a SDP offer that could be used by the signaling to perform the UPDATE strategy discussed in <a href="#RFC3960">[RFC3960]</a>.</p>
<p id="rfc.section.3.6.2.p.3">As a result of sharing the media streams, the application will end up with N parallel PeerConnection sessions, each with a local and remote description and their own local and remote addresses. The media flow from these sessions can be managed by specifying SDP direction attributes in the descriptions, or the application can choose to play out the media from all sessions mixed together. Of course, if the application wants to only keep a single session, it can simply terminate the sessions that it no longer needs.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#sec.interface" id="sec.interface">Interface</a></h1>
<p id="rfc.section.4.p.1">This section details the basic operations that must be present to implement JSEP functionality. The actual API exposed in the W3C API may have somewhat different syntax, but should map easily to these concepts.</p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#sec.methods" id="sec.methods">Methods</a></h1>
<h1 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#sec.constructor" id="sec.constructor">Constructor</a></h1>
<p id="rfc.section.4.1.1.p.1">The PeerConnection constructor allows the application to specify global parameters for the media session, such as the STUN/TURN servers and credentials to use when gathering candidates, as well as the initial ICE candidate policy and pool size, and also the BUNDLE policy to use.</p>
<p id="rfc.section.4.1.1.p.2">If an ICE candidate policy is specified, it functions as described in <a href="#sec.ice-candidate-policy">Section 3.4.3</a>, causing the browser to only surface the permitted candidates to the application, and only use those candidates for connectivity checks. The set of available policies is as follows: </p>

<dl>
  <dt>all:</dt>
  <dd style="margin-left: 8">All candidates will be gathered and used.</dd>
  <dt></dt>
  <dd style="margin-left: 8"/>
  <dt>public:</dt>
  <dd style="margin-left: 8">Candidates with private IP addresses [RFC1918] will be filtered out. This prevents exposure of internal network details, at the cost of requiring relay usage even for intranet calls, if the NAT does not allow hairpinning as described in [RFC4787], section 6.</dd>
  <dt></dt>
  <dd style="margin-left: 8"/>
  <dt>relay:</dt>
  <dd style="margin-left: 8">All candidates except relay candidates will be filtered out. This obfuscates the location information that might be ascertained by the remote peer from the received candidates. Depending on how the application deploys its relay servers, this could obfuscate location to a metro or possibly even global level.</dd>
</dl>

<p> </p>
<p id="rfc.section.4.1.1.p.3">Although it can be overridden by local policy, the default ICE candidate policy MUST be set to allow all candidates, as this minimizes use of application STUN/TURN server resources.</p>
<p id="rfc.section.4.1.1.p.4">If a size is specified for the ICE candidate pool, this indicates the number of ICE components to pre-gather candidates for. Because pre-gathering results in utilizing STUN/TURN server resources for potentially long periods of time, this must only occur upon application request, and therefore the default candidate pool size MUST be zero.  </p>
<p id="rfc.section.4.1.1.p.5">The application can specify its preferred policy regarding use of BUNDLE, the multiplexing mechanism defined in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>.  Regardless of policy, the application will always try to negotiate BUNDLE onto a single transport, and will offer a single BUNDLE group across all media section; use of this single transport is contingent upon the answerer accepting BUNDLE.  However, by specifying a policy from the list below, the application can control exactly how aggressively it will try to BUNDLE media streams together, which affects how it will interoperate with a non-BUNDLE-aware endpoint.  When negotiating with a non-BUNDLE-aware endpoint, only the streams not marked as bundle-only streams will be established.  </p>
<p id="rfc.section.4.1.1.p.6">The set of available policies is as follows: </p>

<dl>
  <dt>balanced:</dt>
  <dd style="margin-left: 8">The first media section of each type (audio, video, or application) will contain transport parameters, which will allow an answerer to unbundle that section.  The second and any subsequent media section of each type will be marked bundle-only. The result is that if there are N distinct media types, then candidates will be gathered for for N media streams. This policy balances desire to multiplex with the need to ensure basic audio and video can still be negotiated in legacy cases.  </dd>
  <dt></dt>
  <dd style="margin-left: 8"/>
  <dt>max-compat:</dt>
  <dd style="margin-left: 8">All media sections will contain transport parameters; none will be marked as bundle-only. This policy will allow all streams to be received by non-BUNDLE-aware endpoints, but require separate candidates to be gathered for each media stream.  </dd>
  <dt></dt>
  <dd style="margin-left: 8"/>
  <dt>max-bundle:</dt>
  <dd style="margin-left: 8">Only the first media section will contain transport parameters; all streams other than the first will be marked as bundle-only. This policy aims to minimize candidate gathering and maximize multiplexing, at the cost of less compatibility with legacy endpoints.  </dd>
</dl>

<p> </p>
<p id="rfc.section.4.1.1.p.7">As it provides the best tradeoff between performance and compatibility with legacy endpoints, the default BUNDLE policy MUST be set to "balanced".  </p>
<p id="rfc.section.4.1.1.p.8">The application can specify its preferred policy regarding use of RTP/RTCP multiplexing <a href="#RFC5761">[RFC5761]</a> using one of the following policies: </p>

<dl>
  <dt>negotiate:</dt>
  <dd style="margin-left: 8">The browser will gather both RTP and RTCP candidates but also will offer "a=rtcp-mux", thus allowing for compatibility with either multiplexing or non-multiplexing endpoints.</dd>
  <dt>require:</dt>
  <dd style="margin-left: 8">The browser will only gather RTP candidates.  This halves the number of candidates that the offerer needs to gather.  When acting as answerer, the browser will reject any m= section that does not provide an "a=rtcp-mux" attribute.  </dd>
</dl>

<p> </p>
<p id="rfc.section.4.1.1.p.9">The default multiplexing policy MUST be set to "require". Implementations MAY choose to reject attempts by the application to set the multiplexing policy to "negotiate".  </p>
<h1 id="rfc.section.4.1.2"><a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#sec.createoffer" id="sec.createoffer">createOffer</a></h1>
<p id="rfc.section.4.1.2.p.1">The createOffer method generates a blob of SDP that contains a <a href="#RFC3264">[RFC3264]</a> offer with the supported configurations for the session, including descriptions of the local MediaStreams attached to this PeerConnection, the codec/RTP/RTCP options supported by this implementation, and any candidates that have been gathered by the ICE Agent. An options parameter may be supplied to provide additional control over the generated offer.  This options parameter should allow for the following manipulations to be performed: </p>
<p/>

<ul>
  <li>To indicate support for a media type even if no MediaStreamTracks of that type have been added to the session (e.g., an audio call that wants to receive video.)</li>
  <li>To trigger an ICE restart, for the purpose of reestablishing connectivity.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.2.p.3">In the initial offer, the generated SDP will contain all desired functionality for the session (functionality that is supported but not desired by default may be omitted); for each SDP line, the generation of the SDP will follow the process defined for generating an initial offer from the document that specifies the given SDP line. The exact handling of initial offer generation is detailed in <a href="#sec.initial-offers">Section 5.2.1</a> below.</p>
<p id="rfc.section.4.1.2.p.4">In the event createOffer is called after the session is established, createOffer will generate an offer to modify the current session based on any changes that have been made to the session, e.g. adding or removing MediaStreams, or requesting an ICE restart. For each existing stream, the generation of each SDP line must follow the process defined for generating an updated offer from the RFC that specifies the given SDP line. For each new stream, the generation of the SDP must follow the process of generating an initial offer, as mentioned above. If no changes have been made, or for SDP lines that are unaffected by the requested changes, the offer will only contain the parameters negotiated by the last offer-answer exchange. The exact handling of subsequent offer generation is detailed in <a href="#sec.subsequent-offers">Section 5.2.2</a>. below.</p>
<p id="rfc.section.4.1.2.p.5">Session descriptions generated by createOffer must be immediately usable by setLocalDescription; if a system has limited resources (e.g. a finite number of decoders), createOffer should return an offer that reflects the current state of the system, so that setLocalDescription will succeed when it attempts to acquire those resources. Because this method may need to inspect the system state to determine the currently available resources, it may be implemented as an async operation.</p>
<p id="rfc.section.4.1.2.p.6">Calling this method may do things such as generate new ICE credentials, but does not result in candidate gathering, or cause media to start or stop flowing.</p>
<h1 id="rfc.section.4.1.3"><a href="#rfc.section.4.1.3">4.1.3.</a> <a href="#sec.createanswer" id="sec.createanswer">createAnswer</a></h1>
<p id="rfc.section.4.1.3.p.1">The createAnswer method generates a blob of SDP that contains a <a href="#RFC3264">[RFC3264]</a> SDP answer with the supported configuration for the session that is compatible with the parameters supplied in the most recent call to setRemoteDescription, which MUST have been called prior to calling createAnswer.  Like createOffer, the returned blob contains descriptions of the local MediaStreams attached to this PeerConnection, the codec/RTP/RTCP options negotiated for this session, and any candidates that have been gathered by the ICE Agent. An options parameter may be supplied to provide additional control over the generated answer.</p>
<p id="rfc.section.4.1.3.p.2">As an answer, the generated SDP will contain a specific configuration that specifies how the media plane should be established; for each SDP line, the generation of the SDP must follow the process defined for generating an answer from the document that specifies the given SDP line. The exact handling of answer generation is detailed in <a href="#sec.generating-an-answer">Section 5.3</a>. below.</p>
<p id="rfc.section.4.1.3.p.3">Session descriptions generated by createAnswer must be immediately usable by setLocalDescription; like createOffer, the returned description should reflect the current state of the system.  Because this method may need to inspect the system state to determine the currently available resources, it may need to be implemented as an async operation.</p>
<p id="rfc.section.4.1.3.p.4">Calling this method may do things such as generate new ICE credentials, but does not trigger candidate gathering or change media state.</p>
<h1 id="rfc.section.4.1.4"><a href="#rfc.section.4.1.4">4.1.4.</a> <a href="#sec.sessiondescriptiontype" id="sec.sessiondescriptiontype">SessionDescriptionType</a></h1>
<p id="rfc.section.4.1.4.p.1">Session description objects (RTCSessionDescription) may be of type "offer", "pranswer", "answer" or "rollback". These types provide information as to how the description parameter should be parsed, and how the media state should be changed.</p>
<p id="rfc.section.4.1.4.p.2">"offer" indicates that a description should be parsed as an offer; said description may include many possible media configurations. A description used as an "offer" may be applied anytime the PeerConnection is in a stable state, or as an update to a previously supplied but unanswered "offer".</p>
<p id="rfc.section.4.1.4.p.3">"pranswer" indicates that a description should be parsed as an answer, but not a final answer, and so should not result in the freeing of allocated resources. It may result in the start of media transmission, if the answer does not specify an inactive media direction. A description used as a "pranswer" may be applied as a response to an "offer", or an update to a previously sent "pranswer".</p>
<p id="rfc.section.4.1.4.p.4">"answer" indicates that a description should be parsed as an answer, the offer-answer exchange should be considered complete, and any resources (decoders, candidates) that are no longer needed can be released. A description used as an "answer" may be applied as a response to an "offer", or an update to a previously sent "pranswer".</p>
<p id="rfc.section.4.1.4.p.5">The only difference between a provisional and final answer is that the final answer results in the freeing of any unused resources that were allocated as a result of the offer. As such, the application can use some discretion on whether an answer should be applied as provisional or final, and can change the type of the session description as needed. For example, in a serial forking scenario, an application may receive multiple "final" answers, one from each remote endpoint. The application could choose to accept the initial answers as provisional answers, and only apply an answer as final when it receives one that meets its criteria (e.g. a live user instead of voicemail).</p>
<p id="rfc.section.4.1.4.p.6">"rollback" is a special session description type implying that the state machine should be rolled back to the previous state, as described in <a href="#sec.rollback">Section 4.1.4.2</a>.  The contents MUST be empty.</p>
<h1 id="rfc.section.4.1.4.1"><a href="#rfc.section.4.1.4.1">4.1.4.1.</a> <a href="#sec.use-of-provisional-answer" id="sec.use-of-provisional-answer">Use of Provisional Answers</a></h1>
<p id="rfc.section.4.1.4.1.p.1">Most web applications will not need to create answers using the "pranswer" type. While it is good practice to send an immediate response to an "offer", in order to warm up the session transport and prevent media clipping, the preferred handling for a web application would be to create and send an "inactive" final answer immediately after receiving the offer. Later, when the called user actually accepts the call, the application can create a new "sendrecv" offer to update the previous offer/answer pair and start the media flow. While this could also be done with an inactive "pranswer", followed by a sendrecv "answer", the initial "pranswer" leaves the offer-answer exchange open, which means that neither side can send an updated offer during this time.</p>
<p id="rfc.section.4.1.4.1.p.2">As an example, consider a typical web application that will set up a data channel, an audio channel, and a video channel. When an endpoint receives an offer with these channels, it could send an answer accepting the data channel for two-way data, and accepting the audio and video tracks as inactive or receive-only. It could then ask the user to accept the call, acquire the local media streams, and send a new offer to the remote side moving the audio and video to be two-way media. By the time the human has accepted the call and triggered the new offer, it is likely that the ICE and DTLS handshaking for all the channels will already have finished.</p>
<p id="rfc.section.4.1.4.1.p.3">Of course, some applications may not be able to perform this double offer-answer exchange, particularly ones that are attempting to gateway to legacy signaling protocols. In these cases, "pranswer" can still provide the application with a mechanism to warm up the transport.</p>
<h1 id="rfc.section.4.1.4.2"><a href="#rfc.section.4.1.4.2">4.1.4.2.</a> <a href="#sec.rollback" id="sec.rollback">Rollback</a></h1>
<p id="rfc.section.4.1.4.2.p.1">In certain situations it may be desirable to "undo" a change made to setLocalDescription or setRemoteDescription. Consider a case where a call is ongoing, and one side wants to change some of the session parameters; that side generates an updated offer and then calls setLocalDescription. However, the remote side, either before or after setRemoteDescription, decides it does not want to accept the new parameters, and sends a reject message back to the offerer. Now, the offerer, and possibly the answerer as well, need to return to a stable state and the previous local/remote description. To support this, we introduce the concept of "rollback".</p>
<p id="rfc.section.4.1.4.2.p.2">A rollback discards any proposed changes to the session, returning the state machine to the stable state, and setting the modified local and/or remote description back to their previous values. Any resources or candidates that were allocated by the abandoned local description are discarded; any media that is received will be processed according to the previous local and remote descriptions. Rollback can only be used to cancel proposed changes; there is no support for rolling back from a stable state to a previous stable state. Note that this implies that once the answerer has performed setLocalDescription with his answer, this cannot be rolled back.  </p>
<p id="rfc.section.4.1.4.2.p.3">A rollback is performed by supplying a session description of type "rollback" with empty contents to either setLocalDescription or setRemoteDescription, depending on which was most recently used (i.e. if the new offer was supplied to setLocalDescription, the rollback should be done using setLocalDescription as well).  </p>
<h1 id="rfc.section.4.1.5"><a href="#rfc.section.4.1.5">4.1.5.</a> <a href="#sec.setlocaldescription" id="sec.setlocaldescription">setLocalDescription</a></h1>
<p id="rfc.section.4.1.5.p.1">The setLocalDescription method instructs the PeerConnection to apply the supplied session description as its local configuration. The type field indicates whether the description should be processed as an offer, provisional answer, or final answer; offers and answers are checked differently, using the various rules that exist for each SDP line.</p>
<p id="rfc.section.4.1.5.p.2">This API changes the local media state; among other things, it sets up local resources for receiving and decoding media. In order to successfully handle scenarios where the application wants to offer to change from one media format to a different, incompatible format, the PeerConnection must be able to simultaneously support use of both the old and new local descriptions (e.g. support codecs that exist in both descriptions) until a final answer is received, at which point the PeerConnection can fully adopt the new local description, or roll back to the old description if the remote side denied the change.</p>
<p id="rfc.section.4.1.5.p.3">This API indirectly controls the candidate gathering process.  When a local description is supplied, and the number of transports currently in use does not match the number of transports needed by the local description, the PeerConnection will create transports as needed and begin gathering candidates for them.</p>
<p id="rfc.section.4.1.5.p.4">If setRemoteDescription was previous called with an offer, and setLocalDescription is called with an answer (provisional or final), and the media directions are compatible, and media are available to send, this will result in the starting of media transmission.</p>
<h1 id="rfc.section.4.1.6"><a href="#rfc.section.4.1.6">4.1.6.</a> <a href="#sec.setremotedescription" id="sec.setremotedescription">setRemoteDescription</a></h1>
<p id="rfc.section.4.1.6.p.1">The setRemoteDescription method instructs the PeerConnection to apply the supplied session description as the desired remote configuration. As in setLocalDescription, the type field of the description indicates how it should be processed.</p>
<p id="rfc.section.4.1.6.p.2">This API changes the local media state; among other things, it sets up local resources for sending and encoding media.</p>
<p id="rfc.section.4.1.6.p.3">If setLocalDescription was previously called with an offer, and setRemoteDescription is called with an answer (provisional or final), and the media directions are compatible, and media are available to send, this will result in the starting of media transmission.</p>
<h1 id="rfc.section.4.1.7"><a href="#rfc.section.4.1.7">4.1.7.</a> <a href="#sec.localdescription" id="sec.localdescription">localDescription</a></h1>
<p id="rfc.section.4.1.7.p.1">The localDescription method returns a copy of the current local configuration, i.e. what was most recently passed to setLocalDescription, plus any local candidates that have been generated by the ICE Agent.</p>
<p id="rfc.section.4.1.7.p.2">[[OPEN ISSUE: Do we need to expose accessors for both the current and proposed local description? https://github.com/rtcweb-wg/jsep/issues/16]]</p>
<p id="rfc.section.4.1.7.p.3">A null object will be returned if the local description has not yet been established.</p>
<h1 id="rfc.section.4.1.8"><a href="#rfc.section.4.1.8">4.1.8.</a> <a href="#sec.remotedescription" id="sec.remotedescription">remoteDescription</a></h1>
<p id="rfc.section.4.1.8.p.1">The remoteDescription method returns a copy of the current remote configuration, i.e. what was most recently passed to setRemoteDescription, plus any remote candidates that have been supplied via processIceMessage.</p>
<p id="rfc.section.4.1.8.p.2">[[OPEN ISSUE: Do we need to expose accessors for both the current and proposed remote description? https://github.com/rtcweb-wg/jsep/issues/16]]</p>
<p id="rfc.section.4.1.8.p.3">A null object will be returned if the remote description has not yet been established.</p>
<h1 id="rfc.section.4.1.9"><a href="#rfc.section.4.1.9">4.1.9.</a> <a href="#sec.cantrickle" id="sec.cantrickle">canTrickleIceCandidates</a></h1>
<p id="rfc.section.4.1.9.p.1">The canTrickleIceCandidates property indicates whether the remote side supports receiving trickled candidates. There are three potential values: </p>

<dl>
  <dt>null:</dt>
  <dd style="margin-left: 8">No SDP has been received from the other side, so it is not known if it can handle trickle. This is the initial value before setRemoteDescription() is called.</dd>
  <dt>true:</dt>
  <dd style="margin-left: 8">SDP has been received from the other side indicating that it can support trickle.</dd>
  <dt>false:</dt>
  <dd style="margin-left: 8">SDP has been received from the other side indicating that it cannot support trickle.</dd>
</dl>

<p> </p>
<p id="rfc.section.4.1.9.p.2">As described in <a href="#sec.ice-candidate-trickling">Section 3.4.2</a>, JSEP implementations always provide candidates to the application individually, consistent with what is needed for Trickle ICE.  However, applications can use the canTrickleIceCandidates property to determine whether their peer can actually do Trickle ICE, i.e., whether it is safe to send an initial offer or answer followed later by candidates as they are gathered.  As "true" is the only value that definitively indicates remote Trickle ICE support, an application which compares canTrickleIceCandidates against "true" will by default attempt Half Trickle on initial offers and Full Trickle on subsequent interactions with a Trickle ICE-compatible agent.  </p>
<h1 id="rfc.section.4.1.10"><a href="#rfc.section.4.1.10">4.1.10.</a> <a href="#sec.setconfiguration" id="sec.setconfiguration">setConfiguration</a></h1>
<p id="rfc.section.4.1.10.p.1">The setConfiguration method allows the global configuration of the PeerConnection, which was initially set by constructor parameters, to be changed during the session. The effects of this method call depend on when it is invoked, and differ depending on which specific parameters are changed:</p>
<p/>

<ul>
  <li>Any changes to the STUN/TURN servers to use affect the next gathering phase. If gathering has already occurred, this will cause the next call to createOffer to generate new ICE credentials, for the purpose of forcing an ICE restart and kicking off a new gathering phase, in which the new servers will be used.  If the ICE candidate pool has a nonzero size, any existing candidates will be discarded, and new candidates will be gathered from the new servers.  </li>
  <li>Any changes to the ICE candidate policy also affect the next gathering phase, in similar fashion to the server changes described above. Note though that changes to the policy have no effect on the candidate pool, because pooled candidates are not surfaced to the application until a gathering phase occurs, and so any necessary filtering can still be done on any pooled candidates.  </li>
  <li>Any changes to the ICE candidate pool size take effect immediately; if increased, additional candidates are pre-gathered; if decreased, the now-superfluous candidates are discarded.  </li>
  <li>The BUNDLE and RTCP-multiplexing policies MUST NOT be changed after the construction of the PeerConnection.  </li>
</ul>
<p id="rfc.section.4.1.10.p.3">This call may result in a change to the state of the ICE Agent, and may result in a change to media state if it results in connectivity being established.</p>
<h1 id="rfc.section.4.1.11"><a href="#rfc.section.4.1.11">4.1.11.</a> <a href="#sec.addicecandidate" id="sec.addicecandidate">addIceCandidate</a></h1>
<p id="rfc.section.4.1.11.p.1">The addIceCandidate method provides a remote candidate to the ICE Agent, which, if parsed successfully, will be added to the remote description according to the rules defined for Trickle ICE.  Connectivity checks will be sent to the new candidate.</p>
<p id="rfc.section.4.1.11.p.2">This call will result in a change to the state of the ICE Agent, and may result in a change to media state if it results in connectivity being established.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#sec.sdp-interaction-procedure" id="sec.sdp-interaction-procedure">SDP Interaction Procedures</a></h1>
<p id="rfc.section.5.p.1">This section describes the specific procedures to be followed when creating and parsing SDP objects.</p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#sec.requirements-overview" id="sec.requirements-overview">Requirements Overview</a></h1>
<p id="rfc.section.5.1.p.1">JSEP implementations must comply with the specifications listed below that govern the creation and processing of offers and answers.  </p>
<p id="rfc.section.5.1.p.2">The first set of specifications is the "mandatory-to-implement" set.  All implementations must support these behaviors, but may not use all of them if the remote side, which may not be a JSEP endpoint, does not support them.</p>
<p id="rfc.section.5.1.p.3">The second set of specifications is the "mandatory-to-use" set.  The local JSEP endpoint and any remote endpoint must indicate support for these specifications in their session descriptions.</p>
<h1 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#sec.implementation-requiremen" id="sec.implementation-requiremen">Implementation Requirements</a></h1>
<p id="rfc.section.5.1.1.p.1">This list of mandatory-to-implement specifications is derived from the requirements outlined in <a href="#I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</a>.  </p>

<dl>
  <dt>R-1   </dt>
  <dd><a href="#RFC4566">[RFC4566]</a> is the base SDP specification and MUST be implemented.</dd>
  <dt>R-2   </dt>
  <dd><a href="#RFC5764">[RFC5764]</a> MUST be supported for signaling the UDP/TLS/RTP/SAVPF <a href="#RFC5764">[RFC5764]</a> and TCP/DTLS/RTP/SAVPF <a href="#I-D.nandakumar-mmusic-proto-iana-registration">[I-D.nandakumar-mmusic-proto-iana-registration]</a> RTP profiles.  </dd>
  <dt>R-3   </dt>
  <dd><a href="#RFC5245">[RFC5245]</a> MUST be implemented for signaling the ICE credentials and candidate lines corresponding to each media stream. The ICE implementation MUST be a Full implementation, not a Lite implementation.</dd>
  <dt>R-4   </dt>
  <dd><a href="#RFC5763">[RFC5763]</a> MUST be implemented to signal DTLS certificate fingerprints.</dd>
  <dt>R-5   </dt>
  <dd><a href="#RFC4568">[RFC4568]</a> MUST NOT be implemented to signal SDES SRTP keying information.</dd>
  <dt>R-6   </dt>
  <dd>The <a href="#RFC5888">[RFC5888]</a> grouping framework MUST be implemented for signaling grouping information, and MUST be used to identify m= lines via the a=mid attribute.</dd>
  <dt>R-7   </dt>
  <dd><a href="#I-D.ietf-mmusic-msid">[I-D.ietf-mmusic-msid]</a> MUST be supported, in order to signal associations between RTP objects and W3C MediaStreams and MediaStreamTracks in a standard way.  </dd>
  <dt>R-8   </dt>
  <dd>The bundle mechanism in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a> MUST be supported to signal the ability to multiplex RTP streams on a single UDP port, in order to avoid excessive use of port number resources.</dd>
  <dt>R-9   </dt>
  <dd>The SDP attributes of "sendonly", "recvonly", "inactive", and "sendrecv" from <a href="#RFC4566">[RFC4566]</a> MUST be implemented to signal information about media direction.</dd>
  <dt>R-10  </dt>
  <dd><a href="#RFC5576">[RFC5576]</a> MUST be implemented to signal RTP SSRC values and grouping semantics.</dd>
  <dt>R-11  </dt>
  <dd><a href="#RFC4585">[RFC4585]</a> MUST be implemented to signal RTCP based feedback.</dd>
  <dt>R-12  </dt>
  <dd><a href="#RFC5761">[RFC5761]</a> MUST be implemented to signal multiplexing of RTP and RTCP.</dd>
  <dt>R-13  </dt>
  <dd><a href="#RFC5506">[RFC5506]</a> MUST be implemented to signal reduced-size RTCP messages.</dd>
  <dt>R-14  </dt>
  <dd><a href="#RFC4588">[RFC4588]</a> MUST be implemented to signal RTX payload type associations.</dd>
  <dt>R-15  </dt>
  <dd><a href="#RFC3556">[RFC3556]</a> with bandwidth modifiers MAY be supported for specifying RTCP bandwidth as a fraction of the media bandwidth, RTCP fraction allocated to the senders and setting maximum media bit-rate boundaries.</dd>
  <dt>R-16  </dt>
  <dd>TODO: any others?</dd>
</dl>
<p id="rfc.section.5.1.1.p.2">As required by <a href="#RFC4566">[RFC4566]</a>, Section 5.13, JSEP implementations MUST ignore unknown attribute (a=) lines.</p>
<h1 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#sec.usage-requirements" id="sec.usage-requirements">Usage Requirements</a></h1>
<p id="rfc.section.5.1.2.p.1">All session descriptions handled by JSEP endpoints, both local and remote, MUST indicate support for the following specifications. If any of these are absent, this omission MUST be treated as an error. </p>

<dl>
  <dt>R-1   </dt>
  <dd>ICE, as specified in <a href="#RFC5245">[RFC5245]</a>, MUST be used. Note that the remote endpoint may use a Lite implementation; implementations MUST properly handle remote endpoints which do ICE-Lite.</dd>
  <dt>R-2   </dt>
  <dd>DTLS <a href="#RFC6347">[RFC6347]</a> or DTLS-SRTP <a href="#RFC5763">[RFC5763]</a>, MUST be used, as appropriate for the media type, as specified in <a href="#I-D.ietf-rtcweb-security-arch">[I-D.ietf-rtcweb-security-arch]</a></dd>
</dl>
<h1 id="rfc.section.5.1.3"><a href="#rfc.section.5.1.3">5.1.3.</a> <a href="#sec.profile-names" id="sec.profile-names">Profile Names and Interoperability</a></h1>
<p id="rfc.section.5.1.3.p.1">For media m= sections, JSEP endpoints MUST support both the "UDP/TLS/ RTP/SAVPF" and "TCP/DTLS/RTP/SAVPF" profiles and MUST indicate one of these two profiles for each media m= line they produce in an offer.  For data m= sections, JSEP endpoints must support both the "UDP/DTLS/SCTP" and "TCP/DTLS/SCTP" profiles and MUST indicate one of these two profiles for each data m= line they produce in an offer.  Because ICE can select either TCP or UDP transport depending on network conditions, both advertisements are consistent with ICE eventually selecting either either UDP or TCP.  </p>
<p id="rfc.section.5.1.3.p.2">Unfortunately, in an attempt at compatibility, some endpoints generate other profile strings even when they mean to support one of these profiles.  For instance, an endpoint might generate "RTP/AVP" but supply "a=fingerprint" and "a=rtcp-fb" attributes, indicating its willingness to support "(UDP,TCP)/TLS/RTP/SAVPF". In order to simplify compatibility with such endpoints, JSEP endpoints MUST follow the following rules when processing the media m= sections in an offer: </p>
<p/>

<ul>
  <li>The profile in any "m=" line in any answer MUST exactly match the profile provided in the offer.</li>
  <li>Any profile matching the following patterns MUST be accepted: "RTP/[S]AVP[F]" and "(UDP/TCP)/TLS/RTP/SAVP[F]"</li>
  <li>Because DTLS-SRTP is REQUIRED, the choice of SAVP or AVP has no effect; support for DTLS-SRTP is determined by the presence of one or more "a=fingerprint" attribute. Note that lack of an "a=fingerprint" attribute will lead to negotiation failure.  </li>
  <li>The use of AVPF or AVP simply controls the timing rules used for RTCP feedback. If AVPF is provided, or an "a=rtcp-fb" attribute is present, assume AVPF timing, i.e. a default value of "trr-int=0". Otherwise, assume that AVPF is being used in an AVP compatible mode and use AVP timing, i.e., "trr-int=4".</li>
  <li>For data m= sections, JSEP endpoints MUST support receiving the "UDP/ DTLS/SCTP", "TCP/DTLS/SCTP", or "DTLS/SCTP" (for backwards compatibility) profiles.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.3.p.4">Note that re-offers by JSEP endpoints MUST use the correct profile strings even if the initial offer/answer exchange used an (incorrect) older profile string.</p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#sec-create-offer" id="sec-create-offer">Constructing an Offer</a></h1>
<p id="rfc.section.5.2.p.1">When createOffer is called, a new SDP description must be created that includes the functionality specified in <a href="#I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</a>. The exact details of this process are explained below.</p>
<h1 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#sec.initial-offers" id="sec.initial-offers">Initial Offers</a></h1>
<p id="rfc.section.5.2.1.p.1">When createOffer is called for the first time, the result is known as the initial offer.</p>
<p id="rfc.section.5.2.1.p.2">The first step in generating an initial offer is to generate session-level attributes, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 5. Specifically: </p>

<ul>
  <li>The first SDP line MUST be "v=0", as specified in <a href="#RFC4566">[RFC4566]</a>, Section 5.1</li>
  <li>The second SDP line MUST be an "o=" line, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 5.2. The value of the &lt;username&gt; field SHOULD be "-". The value of the &lt;sess-id&gt; field SHOULD be a cryptographically random number. To ensure uniqueness, this number SHOULD be at least 64 bits long. The value of the &lt;sess-version&gt; field SHOULD be zero. The value of the &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt; tuple SHOULD be set to a non-meaningful address, such as IN IP4 0.0.0.0, to prevent leaking the local address in this field. As mentioned in <a href="#RFC4566">[RFC4566]</a>, the entire o= line needs to be unique, but selecting a random number for &lt;sess-id&gt; is sufficient to accomplish this.</li>
  <li>The third SDP line MUST be a "s=" line, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 5.3; to match the "o=" line, a single dash SHOULD be used as the session name, e.g. "s=-".  Note that this differs from the advice in <a href="#RFC4566">[RFC4566]</a> which proposes a single space, but as both "o=" and "s=" are meaningless, having the same meaningless value seems clearer.  </li>
  <li>Session Information ("i="), URI ("u="), Email Address ("e="), Phone Number ("p="), Bandwidth ("b="), Repeat Times ("r="), and Time Zones ("z=") lines are not useful in this context and SHOULD NOT be included.</li>
  <li>Encryption Keys ("k=") lines do not provide sufficient security and MUST NOT be included.</li>
  <li>A "t=" line MUST be added, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 5.9; both &lt;start-time&gt; and &lt;stop-time&gt; SHOULD be set to zero, e.g. "t=0 0".</li>
  <li>An "a=ice-options" line with the "trickle" option MUST be added, as specified in <a href="#I-D.ietf-mmusic-trickle-ice">[I-D.ietf-mmusic-trickle-ice]</a>, Section 4.</li>
</ul>
<p id="rfc.section.5.2.1.p.3">The next step is to generate m= sections, as specified in <a href="#RFC4566">[RFC4566]</a> Section 5.14, for each MediaStreamTrack that has been added to the PeerConnection via the addStream method. (Note that this method takes a MediaStream, which can contain multiple MediaStreamTracks, and therefore multiple m= sections can be generated even if addStream is only called once.) m=sections MUST be sorted first by the order in which the MediaStreams were added to the PeerConnection, and then by the alphabetical ordering of the media type for the MediaStreamTrack.  For example, if a MediaStream containing both an audio and a video MediaStreamTrack is added to a PeerConnection, the resultant m=audio section will precede the m=video section. If a second MediaStream containing an audio MediaStreamTrack was added, it would follow the m=video section.</p>
<p id="rfc.section.5.2.1.p.4">Each m= section, provided it is not being bundled into another m= section, MUST generate a unique set of ICE credentials and gather its own unique set of ICE candidates. Otherwise, it MUST use the same ICE credentials and candidates as the m= section into which it is being bundled. Note that this means that for offers, any m= sections which are not bundle-only MUST have unique ICE credentials and candidates, since it is possible that the answerer will accept them without bundling them.  </p>
<p id="rfc.section.5.2.1.p.5">For DTLS, all m= sections MUST use the certificate for the identity that has been specified for the PeerConnection; as a result, they MUST all have the same <a href="#RFC4572">[RFC4572]</a> fingerprint value, or this value MUST be a session-level attribute.</p>
<p id="rfc.section.5.2.1.p.6">Each m= section should be generated as specified in <a href="#RFC4566">[RFC4566]</a>, Section 5.14. For the m= line itself, the following rules MUST be followed:</p>

<ul>
  <li>The port value is set to the port of the default ICE candidate for this m= section, but given that no candidates have yet been gathered, the "dummy" port value of 9 (Discard) MUST be used, as indicated in <a href="#I-D.ietf-mmusic-trickle-ice">[I-D.ietf-mmusic-trickle-ice]</a>, Section 5.1.</li>
  <li>To properly indicate use of DTLS, the &lt;proto&gt; field MUST be set to "UDP/TLS/RTP/SAVPF", as specified in <a href="#RFC5764">[RFC5764]</a>, Section 8, if the default candidate uses UDP transport, or "TCP/DTLS/RTP/SAVPF", as specified in<a href="#I-D.nandakumar-mmusic-proto-iana-registration">[I-D.nandakumar-mmusic-proto-iana-registration]</a> if the default candidate uses TCP transport.</li>
</ul>

<p> </p>
<p id="rfc.section.5.2.1.p.7">The m= line MUST be followed immediately by a "c=" line, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 5.7. Again, as no candidates have yet been gathered, the "c=" line must contain the "dummy" value "IN IP4 0.0.0.0", as defined in <a href="#I-D.ietf-mmusic-trickle-ice">[I-D.ietf-mmusic-trickle-ice]</a>, Section 5.1. [[NOTE: This has not yet changed in the trickle ICE draft.]]</p>
<p id="rfc.section.5.2.1.p.8">Each m= section MUST include the following attribute lines: </p>

<ul>
  <li>An "a=mid" line, as specified in <a href="#RFC5888">[RFC5888]</a>, Section 4. When generating mid values, it is RECOMMENDED that the values be 3 bytes or less, to allow them to efficiently fit into the RTP header extension defined in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 11.</li>
  <li>An "a=rtcp" line, as specified in <a href="#RFC3605">[RFC3605]</a>, Section 2.1, containing the dummy value "9 IN IP4 0.0.0.0", because no candidates have yet been gathered.</li>
  <li>An "a=msid" line, as specified in <a href="#I-D.ietf-mmusic-msid">[I-D.ietf-mmusic-msid]</a>, Section 2.</li>
  <li>An "a=sendrecv" line, as specified in <a href="#RFC3264">[RFC3264]</a>, Section 5.1.</li>
  <li>For each supported codec, "a=rtpmap" and "a=fmtp" lines, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 6.  The audio and video codecs that MUST be supported are specified in <a href="#I-D.ietf-rtcweb-audio">[I-D.ietf-rtcweb-audio]</a> (see Section 3) and <a href="#I-D.ietf-rtcweb-video">[I-D.ietf-rtcweb-video]</a> (see Section 5).</li>
  <li>If this m= section is for media with configurable frame sizes, e.g. audio, an "a=maxptime" line, indicating the smallest of the maximum supported frame sizes out of all codecs included above, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 6.</li>
  <li>If this m= section is for video media, and there are known limitations on the size of images which can be decoded, an "a=imageattr" line, as specified in <a href="#sec.imageattr">Section 3.5</a>.  </li>
  <li>For each primary codec where RTP retransmission should be used, a corresponding "a=rtpmap" line indicating "rtx" with the clock rate of the primary codec and an "a=fmtp" line that references the payload type of the primary codec, as specified in <a href="#RFC4588">[RFC4588]</a>, Section 8.1.</li>
  <li>For each supported FEC mechanism, "a=rtpmap" and "a=fmtp" lines, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 6. The FEC mechanisms that MUST be supported are specified in <a href="#I-D.ietf-rtcweb-fec">[I-D.ietf-rtcweb-fec]</a>, Section 6, and specific usage for each media type is outlined in Sections 4 and 5.</li>
  <li>"a=ice-ufrag" and "a=ice-pwd" lines, as specified in <a href="#RFC5245">[RFC5245]</a>, Section 15.4.</li>
  <li>An "a=fingerprint" line for each of the endpoint's certificates, as specified in <a href="#RFC4572">[RFC4572]</a>, Section 5; the digest algorithm used for the fingerprint MUST match that used in the certificate signature.  </li>
  <li>An "a=setup" line, as specified in <a href="#RFC4145">[RFC4145]</a>, Section 4, and clarified for use in DTLS-SRTP scenarios in <a href="#RFC5763">[RFC5763]</a>, Section 5. The role value in the offer MUST be "actpass".</li>
  <li>An "a=rtcp-mux" line, as specified in <a href="#RFC5761">[RFC5761]</a>, Section 5.1.1.</li>
  <li>An "a=rtcp-rsize" line, as specified in <a href="#RFC5506">[RFC5506]</a>, Section 5.</li>
  <li>For each supported RTP header extension, an "a=extmap" line, as specified in <a href="#RFC5285">[RFC5285]</a>, Section 5. The list of header extensions that SHOULD/MUST be supported is specified in <a href="#I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</a>, Section 5.2. Any header extensions that require encryption MUST be specified as indicated in <a href="#RFC6904">[RFC6904]</a>, Section 4.</li>
  <li>For each supported RTCP feedback mechanism, an "a=rtcp-fb" mechanism, as specified in <a href="#RFC4585">[RFC4585]</a>, Section 4.2. The list of RTCP feedback mechanisms that SHOULD/MUST be supported is specified in <a href="#I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</a>, Section 5.1.</li>
  <li>An "a=ssrc" line, as specified in <a href="#RFC5576">[RFC5576]</a>, Section 4.1, indicating the SSRC to be used for sending media, along with the mandatory "cname" source attribute, as specified in Section 6.1, indicating the CNAME for the source. The CNAME MUST be generated in accordance with Section 4.9 of <a href="#I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</a>.</li>
  <li>If RTX is supported for this media type, another "a=ssrc" line with the RTX SSRC, and an "a=ssrc-group" line, as specified in <a href="#RFC5576">[RFC5576]</a>, section 4.2, with semantics set to "FID" and including the primary and RTX SSRCs.</li>
  <li>If FEC is supported for this media type, another "a=ssrc" line with the FEC SSRC, and an "a=ssrc-group" line with semantics set to "FEC-FR" and including the primary and FEC SSRCs, as specified in <a href="#RFC5956">[RFC5956]</a>, section 4.3. For simplicity, if both RTX and FEC are supported, the FEC SSRC MUST be the same as the RTX SSRC.</li>
  <li>If the BUNDLE policy for this PeerConnection is set to "max-bundle", and this is not the first m= section, or the BUNDLE policy is set to "balanced", and this is not the first m= section for this media type, an "a=bundle-only" line.</li>
</ul>
<p id="rfc.section.5.2.1.p.9">Lastly, if a data channel has been created, a m= section MUST be generated for data. The &lt;media&gt; field MUST be set to "application" and the &lt;proto&gt; field MUST be set to "UDP/DTLS/SCTP" if the default candidate uses UDP transport, or "TCP/DTLS/SCTP" if the default candidate uses TCP transport <a href="#I-D.ietf-mmusic-sctp-sdp">[I-D.ietf-mmusic-sctp-sdp]</a>. The "fmt" value MUST be set to "webrtc-datachannel" as specified in <a href="#I-D.ietf-mmusic-sctp-sdp">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 4.1.  </p>
<p id="rfc.section.5.2.1.p.10">Within the data m= section, the "a=mid", "a=ice-ufrag", "a=ice-pwd", "a=fingerprint", and "a=setup" lines MUST be included as mentioned above, along with an "a=fmtp:webrtc-datachannel" line and an "a=sctp-port" line referencing the SCTP port number as defined in <a href="#I-D.ietf-mmusic-sctp-sdp">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 4.1.</p>
<p id="rfc.section.5.2.1.p.11">Once all m= sections have been generated, a session-level "a=group" attribute MUST be added as specified in <a href="#RFC5888">[RFC5888]</a>. This attribute MUST have semantics "BUNDLE", and MUST include the mid identifiers of each m= section.  The effect of this is that the browser offers all m= sections as one BUNDLE group. However, whether the m= sections are bundle-only or not depends on the BUNDLE policy.  </p>
<p id="rfc.section.5.2.1.p.12">The next step is to generate session-level lip sync groups as defined in <a href="#RFC5888">[RFC5888]</a>, Section 7.  For each MediaStream with more than one MediaStreamTrack, a group of type "LS" MUST be added that contains the mid values for each MediaStreamTrack in that MediaStream. </p>
<p id="rfc.section.5.2.1.p.13">Attributes which SDP permits to either be at the session level or the media level SHOULD generally be at the media level even if they are identical. This promotes readability, especially if one of a set of initially identical attributes is subsequently changed.  </p>
<p id="rfc.section.5.2.1.p.14">Attributes other than the ones specified above MAY be included, except for the following attributes which are specifically incompatible with the requirements of <a href="#I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</a>, and MUST NOT be included: </p>

<ul>
  <li>"a=crypto"</li>
  <li>"a=key-mgmt"</li>
  <li>"a=ice-lite"</li>
</ul>
<p id="rfc.section.5.2.1.p.15">Note that when BUNDLE is used, any additional attributes that are added MUST follow the advice in <a href="#I-D.ietf-mmusic-sdp-mux-attributes">[I-D.ietf-mmusic-sdp-mux-attributes]</a> on how those attributes interact with BUNDLE.</p>
<p id="rfc.section.5.2.1.p.16">Note that these requirements are in some cases stricter than those of SDP. Implementations MUST be prepared to accept compliant SDP even if it would not conform to the requirements for generating SDP in this specification.</p>
<h1 id="rfc.section.5.2.2"><a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#sec.subsequent-offers" id="sec.subsequent-offers">Subsequent Offers</a></h1>
<p id="rfc.section.5.2.2.p.1">When createOffer is called a second (or later) time, or is called after a local description has already been installed, the processing is somewhat different than for an initial offer.</p>
<p id="rfc.section.5.2.2.p.2">If the initial offer was not applied using setLocalDescription, meaning the PeerConnection is still in the "stable" state, the steps for generating an initial offer should be followed, subject to the following restriction: </p>

<ul>
  <li>The fields of the "o=" line MUST stay the same except for the &lt;session-version&gt; field, which MUST increment if the session description changes in any way, including the addition of ICE candidates.</li>
</ul>

<p> </p>
<p id="rfc.section.5.2.2.p.3">If the initial offer was applied using setLocalDescription, but an answer from the remote side has not yet been applied, meaning the PeerConnection is still in the "local-offer" state, an offer is generated by following the steps in the "stable" state above, along with these exceptions: </p>

<ul>
  <li>The "s=" and "t=" lines MUST stay the same.</li>
  <li>Each "m=" and c=" line MUST be filled in with the port, protocol, and address of the default candidate for the m= section, as described in <a href="#RFC5245">[RFC5245]</a>, Section 4.3. If ICE checking has already completed for one or more candidate pairs and a candidate pair is in active use, then that pair MUST be used, even if ICE has not yet completed. Note that this differs from the guidance in <a href="#RFC5245">[RFC5245]</a>, Section 9.1.2.2, which only refers to offers created when ICE has completed. Each "a=rtcp" attribute line MUST also be filled in with the port and address of the appropriate default candidate, either the default RTP or RTCP candidate, depending on whether RTCP multiplexing is currently active or not. Note that if RTCP multiplexing is being offered, but not yet active, the default RTCP candidate MUST be used, as indicated in <a href="#RFC5761">[RFC5761]</a>, section 5.1.3. In each case, if no candidates of the desired type have yet been gathered, dummy values MUST be used, as described above.</li>
  <li>Each "a=mid" line MUST stay the same.</li>
  <li>Each "a=ice-ufrag" and "a=ice-pwd" line MUST stay the same, unless the ICE configuration has changed (either changes to the supported STUN/TURN servers, or the ICE candidate policy), or the "IceRestart" option (<a href="#sec.icerestart">Section 5.2.3.3</a> was specified.  </li>
  <li>Within each m= section, for each candidate that has been gathered during the most recent gathering phase (see <a href="#sec.ice-gather-overview">Section 3.4.1</a>), an "a=candidate" line MUST be added, as specified in <a href="#RFC5245">[RFC5245]</a>, Section 4.3., paragraph 3. If candidate gathering for the section has completed, an "a=end-of-candidates" attribute MUST be added, as described in <a href="#I-D.ietf-mmusic-trickle-ice">[I-D.ietf-mmusic-trickle-ice]</a>, Section 9.3.  </li>
  <li>For MediaStreamTracks that are still present, the "a=msid", "a=ssrc", and "a=ssrc-group" lines MUST stay the same.</li>
  <li>If any MediaStreamTracks have been removed, either through the removeStream method or by removing them from an added MediaStream, their m= sections MUST be marked as recvonly by changing the value of the <a href="#RFC3264">[RFC3264]</a> directional attribute to "a=recvonly". The "a=msid", "a=ssrc", and "a=ssrc-group" lines MUST be removed from the associated m= sections.</li>
  <li>If any MediaStreamTracks have been added, and there exist m= sections of the appropriate media type with no associated MediaStreamTracks (i.e. as described in the preceding paragraph), those m= sections MUST be recycled by adding the new MediaStreamTrack to the m= section. This is done by adding the necessary "a=msid", "a=ssrc", and "a=ssrc-group" lines to the recycled m= section, and removing the "a=recvonly" attribute.  </li>
</ul>
<p id="rfc.section.5.2.2.p.4">If the initial offer was applied using setLocalDescription, and an answer from the remote side has been applied using setRemoteDescription, meaning the PeerConnection is in the "remote-pranswer" or "stable" states, an offer is generated based on the negotiated session descriptions by following the steps mentioned for the "local-offer" state above, along with these exceptions: [OPEN ISSUE: should this be permitted in the remote-pranswer state? https://github.com/rtcweb-wg/jsep/issues/143] </p>

<ul>
  <li>If a m= section exists in the current local description, but does not have an associated local MediaStreamTrack (possibly because said MediaStreamTrack was removed since the last exchange), a m= section MUST still be generated in the new offer, as indicated in <a href="#RFC3264">[RFC3264]</a>, Section 8. The disposition of this section will depend on the state of the remote MediaStreamTrack associated with this m= section. If one exists, and it is still in the "live" state, the new m= section MUST be marked as "a=recvonly", with no "a=msid" or related attributes present. If no remote MediaStreamTrack exists, or it is in the "ended" state, the m= section MUST be marked as rejected, by setting the port to zero, as indicated in <a href="#RFC3264">[RFC3264]</a>, Section 8.2.</li>
  <li>If any MediaStreamTracks have been added, and there exist recvonly m= sections of the appropriate media type with no associated MediaStreamTracks, or rejected m= sections of any media type, those m= sections MUST be recycled, and a local MediaStreamTrack associated with these recycled m= sections until all such existing m= sections have been used. This includes any recvonly or rejected m= sections created by the preceding paragraph.</li>
</ul>
<p id="rfc.section.5.2.2.p.5">In addition, for each non-recycled, non-rejected m= section in the new offer, the following adjustments are made based on the contents of the corresponding m= section in the current remote description: </p>

<ul>
  <li>The m= line and corresponding "a=rtpmap" and "a=fmtp" lines MUST only include codecs present in the remote description.</li>
  <li>The RTP header extensions MUST only include those that are present in the remote description.</li>
  <li>The RTCP feedback extensions MUST only include those that are present in the remote description.</li>
  <li>The "a=rtcp-mux" line MUST only be added if present in the remote description.</li>
  <li>The "a=rtcp-rsize" line MUST only be added if present in the remote description.</li>
</ul>
<p id="rfc.section.5.2.2.p.6">The "a=group:BUNDLE" attribute MUST include the mid identifiers specified in the BUNDLE group in the most recent answer, minus any m= sections that have been marked as rejected, plus any newly added or re-enabled m= sections. In other words, the BUNDLE attribute must contain all m= sections that were previously bundled, as long as they are still alive, as well as any new m= sections.</p>
<p id="rfc.section.5.2.2.p.7">The "LS" groups are generated in the same way as with initial offers.</p>
<h1 id="rfc.section.5.2.3"><a href="#rfc.section.5.2.3">5.2.3.</a> <a href="#sec.options-handling1" id="sec.options-handling1">Options Handling</a></h1>
<p id="rfc.section.5.2.3.p.1">The createOffer method takes as a parameter an RTCOfferOptions object. Special processing is performed when generating a SDP description if the following options are present.</p>
<h1 id="rfc.section.5.2.3.1"><a href="#rfc.section.5.2.3.1">5.2.3.1.</a> <a href="#sec.offertoreceiveaudio" id="sec.offertoreceiveaudio">OfferToReceiveAudio</a></h1>
<p id="rfc.section.5.2.3.1.p.1">If the "OfferToReceiveAudio" option is specified, with an integer value of N, and M audio MediaStreamTracks have been added to the PeerConnection, the offer MUST include N non-rejected m= sections with media type "audio", even if N is greater than M.  This allows the offerer to receive audio, including multiple independent streams, even when not sending it; accordingly, the directional attribute on the N-M audio m= sections without associated MediaStreamTracks MUST be set to recvonly.</p>
<p id="rfc.section.5.2.3.1.p.2">If N is set to a value less than M, the offer MUST mark the m= sections associated with the M-N most recently added (since the last setLocalDescription) MediaStreamTracks as sendonly.  This allows the offerer to indicate that it does not want to receive audio on some or all of its newly created streams.  For m= sections that have previously been negotiated, this setting has no effect. [TODO: refer to RTCRtpSender in the future] </p>
<p id="rfc.section.5.2.3.1.p.3">For backwards compatibility with pre-standard versions of this specification, a value of "true" is interpreted as equivalent to N=1, and "false" as N=0.  </p>
<h1 id="rfc.section.5.2.3.2"><a href="#rfc.section.5.2.3.2">5.2.3.2.</a> <a href="#sec.offertoreceivevideo" id="sec.offertoreceivevideo">OfferToReceiveVideo</a></h1>
<p id="rfc.section.5.2.3.2.p.1">If the "OfferToReceiveVideo" option is specified, with an integer value of N, and M video MediaStreamTracks have been added to the PeerConnection, the offer MUST include N non-rejected m= sections with media type "video", even if N is greater than M.  This allows the offerer to receive video, including multiple independent streams, even when not sending it; accordingly, the directional attribute on the N-M video m= sections without associated MediaStreamTracks MUST be set to recvonly.</p>
<p id="rfc.section.5.2.3.2.p.2">If N is set to a value less than M, the offer MUST mark the m= sections associated with the M-N most recently added (since the last setLocalDescription) MediaStreamTracks as sendonly.  This allows the offerer to indicate that it does not want to receive video on some or all of its newly created streams.  For m= sections that have previously been negotiated, this setting has no effect. [TODO: refer to RTCRtpSender in the future] </p>
<p id="rfc.section.5.2.3.2.p.3">For backwards compatibility with pre-standard versions of this specification, a value of "true" is interpreted as equivalent to N=1, and "false" as N=0.  </p>
<h1 id="rfc.section.5.2.3.3"><a href="#rfc.section.5.2.3.3">5.2.3.3.</a> <a href="#sec.icerestart" id="sec.icerestart">IceRestart</a></h1>
<p id="rfc.section.5.2.3.3.p.1">If the "IceRestart" option is specified, with a value of "true", the offer MUST indicate an ICE restart by generating new ICE ufrag and pwd attributes, as specified in <a href="#RFC5245">[RFC5245]</a>, Section 9.1.1.1. If this option is specified on an initial offer, it has no effect (since a new ICE ufrag and pwd are already generated). Similarly, if the ICE configuration has changed, this option has no effect, since new ufrag and pwd attributes will be generated automatically. This option is primarily useful for reestablishing connectivity in cases where failures are detected by the application.  </p>
<h1 id="rfc.section.5.2.3.4"><a href="#rfc.section.5.2.3.4">5.2.3.4.</a> <a href="#sec.voiceactivitydetection1" id="sec.voiceactivitydetection1">VoiceActivityDetection</a></h1>
<p id="rfc.section.5.2.3.4.p.1">If the "VoiceActivityDetection" option is specified, with a value of "true", the offer MUST indicate support for silence suppression in the audio it receives by including comfort noise ("CN") codecs for each offered audio codec, as specified in <a href="#RFC3389">[RFC3389]</a>, Section 5.1, except for codecs that have their own internal silence suppression support. For codecs that have their own internal silence suppression support, the appropriate fmtp parameters for that codec MUST be specified to indicate that silence suppression for received audio is desired. For example, when using the Opus codec, the "usedtx=1" parameter would be specified in the offer.  This option allows the endpoint to significantly reduce the amount of audio bandwidth it receives, at the cost of some fidelity, depending on the quality of the remote VAD algorithm.</p>
<h1 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#sec.generating-an-answer" id="sec.generating-an-answer">Generating an Answer</a></h1>
<p id="rfc.section.5.3.p.1">When createAnswer is called, a new SDP description must be created that is compatible with the supplied remote description as well as the requirements specified in <a href="#I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</a>. The exact details of this process are explained below.</p>
<h1 id="rfc.section.5.3.1"><a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#sec.initial-answers" id="sec.initial-answers">Initial Answers</a></h1>
<p id="rfc.section.5.3.1.p.1">When createAnswer is called for the first time after a remote description has been provided, the result is known as the initial answer. If no remote description has been installed, an answer cannot be generated, and an error MUST be returned.</p>
<p id="rfc.section.5.3.1.p.2">Note that the remote description SDP may not have been created by a JSEP endpoint and may not conform to all the requirements listed in <a href="#sec-create-offer">Section 5.2</a>. For many cases, this is not a problem. However, if any mandatory SDP attributes are missing, or functionality listed as mandatory-to-use above is not present, this MUST be treated as an error, and MUST cause the affected m= sections to be marked as rejected.</p>
<p id="rfc.section.5.3.1.p.3">The first step in generating an initial answer is to generate session-level attributes. The process here is identical to that indicated in the Initial Offers section above, except that the "a=ice-options" line, with the "trickle" option as specified in <a href="#I-D.ietf-mmusic-trickle-ice">[I-D.ietf-mmusic-trickle-ice]</a>, Section 4, is only included if such an option was present in the offer.</p>
<p id="rfc.section.5.3.1.p.4">The next step is to generate lip sync groups as defined in <a href="#RFC5888">[RFC5888]</a>, Section 7.  For each MediaStream with more than one MediaStreamTrack, a group of type "LS" MUST be added that contains the mid values for each MediaStreamTrack in that MediaStream. In some cases this may result in adding a mid to a given LS group that was not in that LS group in the associated offer. Although this is not allowed by <a href="#RFC5888">[RFC5888]</a>, it is allowed when implementing this specification.  [[OPEN ISSUE: This is still under discussion. See: https://github.com/rtcweb-wg/jsep/issues/162.]] </p>
<p id="rfc.section.5.3.1.p.5">The next step is to generate m= sections for each m= section that is present in the remote offer, as specified in <a href="#RFC3264">[RFC3264]</a>, Section 6. For the purposes of this discussion, any session-level attributes in the offer that are also valid as media-level attributes SHALL be considered to be present in each m= section.</p>
<p id="rfc.section.5.3.1.p.6">The next step is to go through each offered m= section.  If there is a local MediaStreamTrack of the same type which has been added to the PeerConnection via addStream and not yet associated with a m= section, and the specific m= section is either sendrecv or recvonly, the MediaStreamTrack will be associated with the m= section at this time. MediaStreamTracks are assigned to m= sections using the canonical order described in <a href="#sec.initial-offers">Section 5.2.1</a>. If there are more m= sections of a certain type than MediaStreamTracks, some m= sections will not have an associated MediaStreamTrack. If there are more MediaStreamTracks of a certain type than compatible m= sections, only the first N MediaStreamTracks will be able to be associated in the constructed answer. The remainder will need to be associated in a subsequent offer.</p>
<p id="rfc.section.5.3.1.p.7">For each offered m= section, if the associated remote MediaStreamTrack has been stopped, and is therefore in state "ended", and no local MediaStreamTrack has been associated, the corresponding m= section in the answer MUST be marked as rejected by setting the port in the m= line to zero, as indicated in <a href="#RFC3264">[RFC3264]</a>, Section 6., and further processing for this m= section can be skipped.</p>
<p id="rfc.section.5.3.1.p.8">Provided that is not the case, each m= section in the answer should then be generated as specified in <a href="#RFC3264">[RFC3264]</a>, Section 6.1. For the m= line itself, the following rules must be followed:</p>

<ul>
  <li>The port value would normally be set to the port of the default ICE candidate for this m= section, but given that no candidates have yet been gathered, the "dummy" port value of 9 (Discard) MUST be used, as indicated in <a href="#I-D.ietf-mmusic-trickle-ice">[I-D.ietf-mmusic-trickle-ice]</a>, Section 5.1.</li>
  <li>The &lt;proto&gt; field MUST be set to exactly match the &lt;proto&gt; field for the corresponding m= line in the offer.</li>
</ul>

<p> </p>
<p id="rfc.section.5.3.1.p.9">The m= line MUST be followed immediately by a "c=" line, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 5.7. Again, as no candidates have yet been gathered, the "c=" line must contain the "dummy" value "IN IP4 0.0.0.0", as defined in <a href="#I-D.ietf-mmusic-trickle-ice">[I-D.ietf-mmusic-trickle-ice]</a>, Section 5.1.</p>
<p id="rfc.section.5.3.1.p.10">If the offer supports BUNDLE, all m= sections to be BUNDLEd must use the same ICE credentials and candidates; all m= sections not being BUNDLEd must use unique ICE credentials and candidates. Each m= section MUST include the following: </p>

<ul>
  <li>If and only if present in the offer, an "a=mid" line, as specified in <a href="#RFC5888">[RFC5888]</a>, Section 9.1. The "mid" value MUST match that specified in the offer.</li>
  <li>An "a=rtcp" line, as specified in <a href="#RFC3605">[RFC3605]</a>, Section 2.1, containing the dummy value "9 IN IP4 0.0.0.0", because no candidates have yet been gathered.</li>
  <li>If a local MediaStreamTrack has been associated, an "a=msid" line, as specified in <a href="#I-D.ietf-mmusic-msid">[I-D.ietf-mmusic-msid]</a>, Section 2.</li>
  <li>Depending on the directionality of the offer, the disposition of any associated remote MediaStreamTrack, and the presence of an associated local MediaStreamTrack, the appropriate directionality attribute, as specified in <a href="#RFC3264">[RFC3264]</a>, Section 6.1. If the offer was sendrecv, and the remote MediaStreamTrack is still "live", and there is a local MediaStreamTrack that has been associated, the directionality MUST be set as sendrecv. If the offer was sendonly, and the remote MediaStreamTrack is still "live", the directionality MUST be set as recvonly. If the offer was recvonly, and a local MediaStreamTrack has been associated, the directionality MUST be set as sendonly. If the offer was inactive, the directionality MUST be set as inactive.</li>
  <li>For each supported codec that is present in the offer, "a=rtpmap" and "a=fmtp" lines, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 6, and <a href="#RFC3264">[RFC3264]</a>, Section 6.1.  The audio and video codecs that MUST be supported are specified in <a href="#I-D.ietf-rtcweb-audio">[I-D.ietf-rtcweb-audio]</a> (see Section 3) and <a href="#I-D.ietf-rtcweb-video">[I-D.ietf-rtcweb-video]</a> (see Section 5).  Note that for simplicity, the answerer MAY use different payload types for codecs than the offerer, as it is not prohibited by Section 6.1.</li>
  <li>If this m= section is for media with configurable frame sizes, e.g. audio, an "a=maxptime" line, indicating the smallest of the maximum supported frame sizes out of all codecs included above, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 6.</li>
  <li>If this m= section is for video media, and there are known limitations on the size of images which can be decoded, an "a=imageattr" line, as specified in <a href="#sec.imageattr">Section 3.5</a>.  </li>
  <li>If "rtx" is present in the offer, for each primary codec where RTP retransmission should be used, a corresponding "a=rtpmap" line indicating "rtx" with the clock rate of the primary codec and an "a=fmtp" line that references the payload type of the primary codec, as specified in <a href="#RFC4588">[RFC4588]</a>, Section 8.1.</li>
  <li>For each supported FEC mechanism, "a=rtpmap" and "a=fmtp" lines, as specified in <a href="#RFC4566">[RFC4566]</a>, Section 6. The FEC mechanisms that MUST be supported are specified in <a href="#I-D.ietf-rtcweb-fec">[I-D.ietf-rtcweb-fec]</a>, Section 6, and specific usage for each media type is outlined in Sections 4 and 5.</li>
  <li>"a=ice-ufrag" and "a=ice-pwd" lines, as specified in <a href="#RFC5245">[RFC5245]</a>, Section 15.4.</li>
  <li>An "a=fingerprint" line for each of the endpoint's certificates, as specified in <a href="#RFC4572">[RFC4572]</a>, Section 5; the digest algorithm used for the fingerprint MUST match that used in the certificate signature.  </li>
  <li>An "a=setup" line, as specified in <a href="#RFC4145">[RFC4145]</a>, Section 4, and clarified for use in DTLS-SRTP scenarios in <a href="#RFC5763">[RFC5763]</a>, Section 5. The role value in the answer MUST be "active" or "passive"; the "active" role is RECOMMENDED.</li>
  <li>If present in the offer, an "a=rtcp-mux" line, as specified in <a href="#RFC5761">[RFC5761]</a>, Section 5.1.1. If the "require" RTCP multiplexing policy is set and no "a=rtcp-mux" line is present in the offer,  then the m=line MUST be marked as rejected by setting the port in the m= line to zero, as indicated in <a href="#RFC3264">[RFC3264]</a>, Section 6.  </li>
  <li>If present in the offer, an "a=rtcp-rsize" line, as specified in <a href="#RFC5506">[RFC5506]</a>, Section 5.</li>
  <li>For each supported RTP header extension that is present in the offer, an "a=extmap" line, as specified in <a href="#RFC5285">[RFC5285]</a>, Section 5. The list of header extensions that SHOULD/MUST be supported is specified in <a href="#I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</a>, Section 5.2. Any header extensions that require encryption MUST be specified as indicated in <a href="#RFC6904">[RFC6904]</a>, Section 4.</li>
  <li>For each supported RTCP feedback mechanism that is present in the offer, an "a=rtcp-fb" mechanism, as specified in <a href="#RFC4585">[RFC4585]</a>, Section 4.2. The list of RTCP feedback mechanisms that SHOULD/MUST be supported is specified in <a href="#I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</a>, Section 5.1.</li>
  <li>If a local MediaStreamTrack has been associated, an "a=ssrc" line, as specified in <a href="#RFC5576">[RFC5576]</a>, Section 4.1, indicating the SSRC to be used for sending media, along with the mandatory "cname" source attribute, as specified in Section 6.1, indicating the CNAME for the source.  The CNAME MUST be generated in accordance with Section 4.9 of <a href="#I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</a>.</li>
  <li>If a local MediaStreamTrack has been associated, and RTX has been negotiated for this m= section, another "a=ssrc" line with the RTX SSRC, and an "a=ssrc-group" line, as specified in <a href="#RFC5576">[RFC5576]</a>, section 4.2, with semantics set to "FID" and including the primary and RTX SSRCs.</li>
  <li>If a local MediaStreamTrack has been associated, and FEC has been negotiated for this m= section, another "a=ssrc" line with the FEC SSRC, and an "a=ssrc-group" line with semantics set to "FEC-FR" and including the primary and FEC SSRCs, as specified in <a href="#RFC5956">[RFC5956]</a>, section 4.3. For simplicity, if both RTX and FEC are supported, the FEC SSRC MUST be the same as the RTX SSRC.</li>
</ul>
<p id="rfc.section.5.3.1.p.11">If a data channel m= section has been offered, a m= section MUST also be generated for data. The &lt;media&gt; field MUST be set to "application" and the &lt;proto&gt; and "fmt" fields MUST be set to exactly match the fields in the offer.</p>
<p id="rfc.section.5.3.1.p.12">Within the data m= section, the "a=mid", "a=ice-ufrag", "a=ice-pwd", "a=candidate", "a=fingerprint", and "a=setup" lines MUST be included as mentioned above, along with an "a=fmtp:webrtc-datachannel" line and an "a=sctp-port" line referencing the SCTP port number as defined in <a href="#I-D.ietf-mmusic-sctp-sdp">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 4.1.  </p>
<p id="rfc.section.5.3.1.p.13">If "a=group" attributes with semantics of "BUNDLE" are offered, corresponding session-level "a=group" attributes MUST be added as specified in <a href="#RFC5888">[RFC5888]</a>. These attributes MUST have semantics "BUNDLE", and MUST include the all mid identifiers from the offered BUNDLE groups that have not been rejected.  Note that regardless of the presence of "a=bundle-only" in the offer, no m= sections in the answer should have an "a=bundle-only" line.  </p>
<p id="rfc.section.5.3.1.p.14">Attributes that are common between all m= sections MAY be moved to session-level, if explicitly defined to be valid at session-level.</p>
<p id="rfc.section.5.3.1.p.15">The attributes prohibited in the creation of offers are also prohibited in the creation of answers.</p>
<h1 id="rfc.section.5.3.2"><a href="#rfc.section.5.3.2">5.3.2.</a> <a href="#sec.subsequent-answers" id="sec.subsequent-answers">Subsequent Answers</a></h1>
<p id="rfc.section.5.3.2.p.1">When createAnswer is called a second (or later) time, or is called after a local description has already been installed, the processing is somewhat different than for an initial answer.</p>
<p id="rfc.section.5.3.2.p.2">If the initial answer was not applied using setLocalDescription, meaning the PeerConnection is still in the "have-remote-offer" state, the steps for generating an initial answer should be followed, subject to the following restriction: </p>

<ul>
  <li>The fields of the "o=" line MUST stay the same except for the &lt;session-version&gt; field, which MUST increment if the session description changes in any way from the previously generated answer.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.3.2.p.3">If any session description was previously supplied to setLocalDescription, an answer is generated by following the steps in the "have-remote-offer" state above, along with these exceptions: </p>

<ul>
  <li>The "s=" and "t=" lines MUST stay the same.</li>
  <li>Each "m=" and c=" line MUST be filled in with the port and address of the default candidate for the m= section, as described in <a href="#RFC5245">[RFC5245]</a>, Section 4.3. Note, however, that the m= line protocol need not match the default candidate, because this protocol value must instead match what was supplied in the offer, as described above. Each "a=rtcp" attribute line MUST also be filled in with the port and address of the appropriate default candidate, either the default RTP or RTCP candidate, depending on whether RTCP multiplexing is enabled in the answer. In each case, if no candidates of the desired type have yet been gathered, dummy values MUST be used, as described in the initial answer section above.</li>
  <li>Each "a=ice-ufrag" and "a=ice-pwd" line MUST stay the same.  </li>
  <li>Within each m= section, for each candidate that has been gathered during the most recent gathering phase (see <a href="#sec.ice-gather-overview">Section 3.4.1</a>), an "a=candidate" line MUST be added, as specified in <a href="#RFC5245">[RFC5245]</a>, Section 4.3., paragraph 3. If candidate gathering for the section has completed, an "a=end-of-candidates" attribute MUST be added, as described in <a href="#I-D.ietf-mmusic-trickle-ice">[I-D.ietf-mmusic-trickle-ice]</a>, Section 9.3.  </li>
  <li>For MediaStreamTracks that are still present, the "a=msid", "a=ssrc", and "a=ssrc-group" lines MUST stay the same.</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.3.3"><a href="#rfc.section.5.3.3">5.3.3.</a> <a href="#sec.options-handling2" id="sec.options-handling2">Options Handling</a></h1>
<p id="rfc.section.5.3.3.p.1">The createAnswer method takes as a parameter an RTCAnswerOptions object. The set of parameters for RTCAnswerOptions is different than those supported in RTCOfferOptions; the OfferToReceiveAudio, OfferToReceiveVideo, and IceRestart options mentioned in <a href="#sec.options-handling1">Section 5.2.3</a> are meaningless in the context of generating an answer, as there is no need to generate extra m= lines in an answer, and ICE credentials will automatically be changed for all m= lines where the offerer chose to perform ICE restart.</p>
<p id="rfc.section.5.3.3.p.2">The following options are supported in RTCAnswerOptions.</p>
<h1 id="rfc.section.5.3.3.1"><a href="#rfc.section.5.3.3.1">5.3.3.1.</a> <a href="#sec.voiceactivitydetection2" id="sec.voiceactivitydetection2">VoiceActivityDetection</a></h1>
<p id="rfc.section.5.3.3.1.p.1">Silence suppression in the answer is handled as described in <a href="#sec.voiceactivitydetection1">Section 5.2.3.4</a>.  </p>
<h1 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> <a href="#sec.processing-a-local-desc" id="sec.processing-a-local-desc">Processing a Local Description</a></h1>
<p id="rfc.section.5.4.p.1">When a SessionDescription is supplied to setLocalDescription, the following steps MUST be performed: </p>

<ul>
  <li>First, the type of the SessionDescription is checked against the current state of the PeerConnection: <ul><li>If the type is "offer", the PeerConnection state MUST be either "stable" or "have-local-offer".</li><li>If the type is "pranswer" or "answer", the PeerConnection state MUST be either "have-remote-offer" or "have-local-pranswer".</li></ul><p> </p></li>
  <li>If the type is not correct for the current state, processing MUST stop and an error MUST be returned.</li>
  <li>Next, the SessionDescription is parsed into a data structure, as described in the <a href="#sec.parsing-a-desc">Section 5.6</a> section below. If parsing fails for any reason, processing MUST stop and an error MUST be returned.  </li>
  <li>Finally, the parsed SessionDescription is applied as described in the <a href="#sec.applying-a-local-desc">Section 5.7</a> section below.</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a> <a href="#sec.processing-a-remote-desc" id="sec.processing-a-remote-desc">Processing a Remote Description</a></h1>
<p id="rfc.section.5.5.p.1">When a SessionDescription is supplied to setRemoteDescription, the following steps MUST be performed: </p>

<ul>
  <li>First, the type of the SessionDescription is checked against the current state of the PeerConnection: <ul><li>If the type is "offer", the PeerConnection state MUST be either "stable" or "have-remote-offer".</li><li>If the type is "pranswer" or "answer", the PeerConnection state MUST be either "have-local-offer" or "have-remote-pranswer".</li></ul><p> </p></li>
  <li>If the type is not correct for the current state, processing MUST stop and an error MUST be returned.</li>
  <li>Next, the SessionDescription is parsed into a data structure, as described in the <a href="#sec.parsing-a-desc">Section 5.6</a> section below. If parsing fails for any reason, processing MUST stop and an error MUST be returned.  </li>
  <li>Finally, the parsed SessionDescription is applied as described in the <a href="#sec.applying-a-remote-desc">Section 5.8</a> section below.</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.6"><a href="#rfc.section.5.6">5.6.</a> <a href="#sec.parsing-a-desc" id="sec.parsing-a-desc">Parsing a Session Description</a></h1>
<p id="rfc.section.5.6.p.1">[The behavior described herein is a draft version, and needs more discussion to resolve various open issues.]</p>
<p id="rfc.section.5.6.p.2">When a SessionDescription of any type is supplied to setLocal/RemoteDescription, the implementation must parse it and reject it if it is invalid. The exact details of this process are explained below.</p>
<p id="rfc.section.5.6.p.3">The SDP contained in the session description object consists of a sequence of text lines, each containing a key-value expression, as described in <a href="#RFC4566">[RFC4566]</a>, Section 5.  The SDP is read, line-by-line, and converted to a data structure that contains the deserialized information. However, SDP allows many types of lines, not all of which are relevant to JSEP applications.  For each line, the implementation will first ensure it is syntactically correct according its defining ABNF, check that it conforms to <a href="#RFC4566">[RFC4566]</a> and <a href="#RFC3264">[RFC3264]</a> semantics, and then either parse and store or discard the provided value, as described below. A partial list of ABNF definitions for SDP attributes can found in:</p>
<div id="rfc.table.1"/>
<div id="sdp_abnf"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>SDP ABNF References</caption>
  <thead>
    <tr>
      <th class="left">Attribute</th>
      <th class="left">Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">ptime  </td>
      <td class="left"><a href="#RFC4566">[RFC4566]</a> Section 9  </td>
    </tr>
    <tr>
      <td class="left">maxptime  </td>
      <td class="left"><a href="#RFC4566">[RFC4566]</a> Section 9  </td>
    </tr>
    <tr>
      <td class="left">rtpmap  </td>
      <td class="left"><a href="#RFC4566">[RFC4566]</a> Section 9  </td>
    </tr>
    <tr>
      <td class="left">recvonly  </td>
      <td class="left"><a href="#RFC4566">[RFC4566]</a> Section 9  </td>
    </tr>
    <tr>
      <td class="left">sendrecv  </td>
      <td class="left"><a href="#RFC4566">[RFC4566]</a> Section 9  </td>
    </tr>
    <tr>
      <td class="left">sendonly  </td>
      <td class="left"><a href="#RFC4566">[RFC4566]</a> Section 9  </td>
    </tr>
    <tr>
      <td class="left">inactive  </td>
      <td class="left"><a href="#RFC4566">[RFC4566]</a> Section 9  </td>
    </tr>
    <tr>
      <td class="left">framerate  </td>
      <td class="left"><a href="#RFC4566">[RFC4566]</a> Section 9  </td>
    </tr>
    <tr>
      <td class="left">fmtp  </td>
      <td class="left"><a href="#RFC4566">[RFC4566]</a> Section 9  </td>
    </tr>
    <tr>
      <td class="left">quality  </td>
      <td class="left"><a href="#RFC4566">[RFC4566]</a> Section 9  </td>
    </tr>
    <tr>
      <td class="left">msid  </td>
      <td class="left"><a href="#I-D.ietf-mmusic-msid">[I-D.ietf-mmusic-msid]</a> Section 2  </td>
    </tr>
    <tr>
      <td class="left">rtcp  </td>
      <td class="left"><a href="#RFC3605">[RFC3605]</a> Section 2.1 </td>
    </tr>
    <tr>
      <td class="left">setup  </td>
      <td class="left"><a href="#RFC4145">[RFC4145]</a> Section 3, 4, and 5 </td>
    </tr>
    <tr>
      <td class="left">connection  </td>
      <td class="left"><a href="#RFC4145">[RFC4145]</a> Section 3, 4, and 5 </td>
    </tr>
    <tr>
      <td class="left">fingerprint  </td>
      <td class="left"><a href="#RFC4572">[RFC4572]</a> Section 5 </td>
    </tr>
    <tr>
      <td class="left">rtcp-fb  </td>
      <td class="left"><a href="#RFC4585">[RFC4585]</a> Section 4.2 </td>
    </tr>
    <tr>
      <td class="left">candidate  </td>
      <td class="left"><a href="#RFC5245">[RFC5245]</a> Section 15 </td>
    </tr>
    <tr>
      <td class="left">extmap  </td>
      <td class="left"><a href="#RFC5285">[RFC5285]</a> Section 7 </td>
    </tr>
    <tr>
      <td class="left">mid  </td>
      <td class="left"><a href="#RFC5888">[RFC5888]</a> Section 4 and 5 </td>
    </tr>
    <tr>
      <td class="left">group  </td>
      <td class="left"><a href="#RFC5888">[RFC5888]</a> Section 4 and 5 </td>
    </tr>
    <tr>
      <td class="left">imageattr  </td>
      <td class="left"><a href="#RFC6236">[RFC6236]</a> Section 3.1 </td>
    </tr>
    <tr>
      <td class="left">extmap (encrypt option)  </td>
      <td class="left"><a href="#RFC6904">[RFC6904]</a> Section 4 </td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.5.6.p.4">[TODO: ensure that every line is listed below.] </p>
<p id="rfc.section.5.6.p.5">If the line is not well-formed, or cannot be parsed as described, the parser MUST stop with an error and reject the session description. This ensures that implementations do not accidentally misinterpret ambiguous SDP.</p>
<h1 id="rfc.section.5.6.1"><a href="#rfc.section.5.6.1">5.6.1.</a> <a href="#sec.session-level-parse" id="sec.session-level-parse">Session-Level Parsing</a></h1>
<p id="rfc.section.5.6.1.p.1">First, the session-level lines are checked and parsed. These lines MUST occur in a specific order, and with a specific syntax, as defined in <a href="#RFC4566">[RFC4566]</a>, Section 5. Note that while the specific line types (e.g. "v=", "c=") MUST occur in the defined order, lines of the same type (typically "a=") can occur in any order, and their ordering is not meaningful.</p>
<p id="rfc.section.5.6.1.p.2">For non-attribute (non-"a=") lines, their sequencing, syntax, and semantics, are checked, as mentioned above. The following lines are not meaningful in the JSEP context and MAY be discarded once they have been checked.  </p>

<ul class="empty">
  <li>The "c=" line MUST be checked for syntax but its value is not used.  This supersedes the guidance in <a href="#RFC5245">[RFC5245]</a>, Section 6.1, to use "ice-mismatch" to indicate mismatches between "c=" and the candidate lines; because JSEP always uses ICE, "ice-mismatch" is not useful in this context.  </li>
  <li>TODO</li>
</ul>

<p> </p>
<p id="rfc.section.5.6.1.p.3">The remaining lines are processed as follows: </p>

<ul class="empty">
  <li>The "b=" line, if present, MUST be parsed as specified in <a href="#RFC4566">[RFC4566]</a>, Section 5.8, and the bwtype and bandwidth values stored.</li>
  <li>[OPEN ISSUE: is this WG consensus? Are there other non-a= lines that we need to do more than just syntactical validation, e.g. v=?] </li>
</ul>

<p> </p>
<p id="rfc.section.5.6.1.p.4">Specific processing MUST be applied for the following session-level attribute ("a=") lines: </p>

<ul>
  <li>Any "a=group" lines are parsed as specified in <a href="#RFC5888">[RFC5888]</a>, Section 5, and the group's semantics and mids are stored.</li>
  <li>If present, a single "a=ice-lite" line is parsed as specified in <a href="#RFC5245">[RFC5245]</a>, Section 15.3, and a value indicating the presence of ice-lite is stored.</li>
  <li>If present, a single "a=ice-ufrag" line is parsed as specified in <a href="#RFC5245">[RFC5245]</a>, Section 15.4, and the ufrag value is stored.</li>
  <li>If present, a single "a=ice-pwd" line is parsed as specified in <a href="#RFC5245">[RFC5245]</a>, Section 15.4, and the password value is stored.</li>
  <li>If present, a single "a=ice-options" line is parsed as specified in <a href="#RFC5245">[RFC5245]</a>, Section 15.5, and the set of specified options is stored.</li>
  <li>Any "a=fingerprint" lines are parsed as specified in <a href="#RFC4572">[RFC4572]</a>, Section 5, and the set of fingerprint and algorithm values is stored.</li>
  <li>If present, a single "a=setup" line is parsed as specified in <a href="#RFC4145">[RFC4145]</a>, Section 4, and the setup value is stored.</li>
  <li>Any "a=extmap" lines are parsed as specified in <a href="#RFC5285">[RFC5285]</a>, Section 5, and their values are stored.</li>
  <li>TODO: identity, rtcp-rsize, rtcp-mux, and any other attribs valid at session level.</li>
</ul>

<p> </p>
<p id="rfc.section.5.6.1.p.5">Once all the session-level lines have been parsed, processing continues with the lines in media sections.  </p>
<h1 id="rfc.section.5.6.2"><a href="#rfc.section.5.6.2">5.6.2.</a> Media Section Parsing</h1>
<p id="rfc.section.5.6.2.p.1">Like the session-level lines, the media session lines MUST occur in the specific order and with the specific syntax defined in <a href="#RFC4566">[RFC4566]</a>, Section 5.</p>
<p id="rfc.section.5.6.2.p.2">The "m=" line itself MUST be parsed as described in <a href="#RFC4566">[RFC4566]</a>, Section 5.14, and the media, port, proto, and fmt values stored.</p>
<p id="rfc.section.5.6.2.p.3">Following the "m=" line, specific processing MUST be applied for the following non-attribute lines: </p>

<ul>
  <li>As with the "c=" line at the session level, the "c=" line MUST be parsed according to <a href="#RFC4566">[RFC4566]</a>, Section 5.7, but its value is not used.</li>
  <li>The "b=" line, if present, MUST be parsed as specified in <a href="#RFC4566">[RFC4566]</a>, Section 5.8, and the bwtype and bandwidth values stored.</li>
</ul>

<p> </p>
<p id="rfc.section.5.6.2.p.4">Specific processing MUST also be applied for the following attribute lines: </p>

<ul>
  <li>If present, a single "a=ice-ufrag" line is parsed as specified in <a href="#RFC5245">[RFC5245]</a>, Section 15.4, and the ufrag value is stored.</li>
  <li>If present, a single "a=ice-pwd" line is parsed as specified in <a href="#RFC5245">[RFC5245]</a>, Section 15.4, and the password value is stored.</li>
  <li>If present, a single "a=ice-options" line is parsed as specified in <a href="#RFC5245">[RFC5245]</a>, Section 15.5, and the set of specified options is stored.</li>
  <li>Any "a=fingerprint" lines are parsed as specified in <a href="#RFC4572">[RFC4572]</a>, Section 5, and the set of fingerprint and algorithm values is stored.</li>
  <li>If present, a single "a=setup" line is parsed as specified in <a href="#RFC4145">[RFC4145]</a>, Section 4, and the setup value is stored.</li>
</ul>

<p> </p>
<p id="rfc.section.5.6.2.p.5">If the "m=" proto value indicates use of RTP, as decribed in the <a href="#sec.profile-names">Section 5.1.3</a> section above, the following attribute lines MUST be processed: </p>

<ul>
  <li>The "m=" fmt value MUST be parsed as specified in <a href="#RFC4566">[RFC4566]</a>, Section 5.14, and the individual values stored.</li>
  <li>Any "a=rtpmap" or "a=fmtp" lines MUST be parsed as specified in <a href="#RFC4566">[RFC4566]</a>, Section 6, and their values stored.</li>
  <li>If present, a single "a=ptime" line MUST be parsed as described in <a href="#RFC4566">[RFC4566]</a>, Section 6, and its value stored.</li>
  <li>If present, a single direction attribute line (e.g. "a=sendrecv") MUST be parsed as described in <a href="#RFC4566">[RFC4566]</a>, Section 6, and its value stored.</li>
  <li>Any "a=ssrc" or "a=ssrc-group" attributes MUST be parsed as specified in <a href="#RFC5576">[RFC5576]</a>, Sections 4.1-4.2, and their values stored.</li>
  <li>Any "a=extmap" attributes MUST be parsed as specified in <a href="#RFC5285">[RFC5285]</a>, Section 5, and their values stored.</li>
  <li>Any "a=rtcp-fb" attributes MUST be parsed as specified in <a href="#RFC4585">[RFC4585]</a>, Section 4.2., and their values stored.</li>
  <li>If present, a single "a=rtcp-mux" line MUST be parsed as specified in <a href="#RFC5761">[RFC5761]</a>, Section 5.1.1, and its presence or absence flagged and stored.</li>
  <li>TODO: a=rtcp-rsize, a=rtcp, a=msid, a=candidate, a=end-of-candidates</li>
</ul>

<p> </p>
<p id="rfc.section.5.6.2.p.6">Otherwise, if the "m=" proto value indicats use of SCTP, the following attribute lines MUST be processed: </p>

<ul>
  <li>The "m=" fmt value MUST be parsed as specified in <a href="#I-D.ietf-mmusic-sctp-sdp">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 4.3, and the application protocol value stored.</li>
  <li>An "a=sctp-port" attribute MUST be present, and it MUST be parsed as specified in <a href="#I-D.ietf-mmusic-sctp-sdp">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 5.2, and the value stored.</li>
  <li>TODO: max message size</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.6.3"><a href="#rfc.section.5.6.3">5.6.3.</a> Semantics Verification</h1>
<p id="rfc.section.5.6.3.p.1">Assuming parsing completes successfully, the parsed description is then evaluated to ensure internal consistency as well as proper support for mandatory features. Specifically, the following checks are performed: </p>

<ul>
  <li>For each m= section, valid values for each of the mandatory-to-use features enumerated in <a href="#sec.usage-requirements">Section 5.1.2</a> MUST be present. These values MAY either be present at the media level, or inherited from the session level.  <ul><li>ICE ufrag and password values, which MUST comply with the size limits specified in <a href="#RFC5245">[RFC5245]</a>, Section 15.4.</li><li>DTLS setup value, which MUST be set according to the rules specified in <a href="#RFC5763">[RFC5763]</a>, Section 5, and MUST be consistent with the selected role of the current DTLS connection, if one exists.[TODO: may need revision, i.e., use of actpass</li><li>DTLS fingerprint values, where at least one fingerprint MUST be present.</li></ul><p> </p></li>
  <li>Each m= section is also checked to ensure prohibited features are not used. If this is a local description, the "ice-lite" attribute MUST NOT be specified.</li>
</ul>

<p> </p>
<p id="rfc.section.5.6.3.p.2">If this session description is of type "pranswer" or "answer", the following additional checks are applied: </p>

<ul>
  <li>The session description must follow the rules defined in <a href="#RFC3264">[RFC3264]</a>, Section 6, including the requirement that the number of m= sections MUST exactly match the number of m= sections in the associated offer.</li>
  <li>For each m= section, the media type and protocol values MUST exactly match the media type and protocol values in the corresponding m= section in the associated offer.</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.7"><a href="#rfc.section.5.7">5.7.</a> <a href="#sec.applying-a-local-desc" id="sec.applying-a-local-desc">Applying a Local Description</a></h1>
<p id="rfc.section.5.7.p.1">The following steps are performed at the media engine level to apply a local description.</p>
<p id="rfc.section.5.7.p.2">First, the parsed parameters are checked to ensure that any modifications performed fall within those explicitly permitted by <a href="#sec.configurable-sdp-paramete">Section 6</a>; otherwise, processing MUST stop and an error MUST be returned.</p>
<p id="rfc.section.5.7.p.3">Next, media sections are processed. For each media section, the following steps MUST be performed; if any parameters are out of bounds, or cannot be applied, processing MUST stop and an error MUST be returned.  </p>

<ul>
  <li>If this media section is new, begin gathering candidates for it, as defined in <a href="#RFC5245">[RFC5245]</a>, Section 4.1.1, unless it has been marked as bundle-only.</li>
  <li>Or, if the ICE ufrag and password values have changed, trigger the ICE Agent to start an ICE restart and begin gathering new candidates for the media section, as defined in <a href="#RFC5245">[RFC5245]</a>, Section 9.1.1.1, unless it has been marked as bundle-only.</li>
  <li>If the media section proto value indicates use of RTP: <ul><li>If RTCP mux is indicated, prepare to demux RTP and RTCP from the RTP ICE component, as specified in <a href="#RFC5761">[RFC5761]</a>, Section 5.1.1.  If RTCP mux is not indicated, but was indicated in a previous description, this MUST result in an error.</li><li>For each specified RTP header extension, establish a mapping between the extension ID and URI, as described in section 6 of <a href="#RFC5285">[RFC5285]</a>.  If any indicated RTP header extension is unknown, this MUST result in an error. </li><li>If the MID header extension is supported, prepare to demux RTP data intended for this media section based on the MID header extension, as described in <a href="#I-D.ietf-mmusic-msid">[I-D.ietf-mmusic-msid]</a>, Section 3.2. </li><li>For each specified payload type, establish a mapping between the payload type ID and the actual media format, as descibed in <a href="#RFC3264">[RFC3264]</a>.  If any indicated payload type is unknown, this MUST result in an error.</li><li>For each specified "rtx" media format, establish a mapping between the RTX payload type and its associated primary payload type, as described in <a href="#RFC4588">[RFC4588]</a>, Sections 8.6 and 8.7. If any referenced primary payload types are not present, this MUST result in an error.</li><li>If the directional attribute is of type "sendrecv" or "recvonly", enable receipt and decoding of media.  </li></ul><p> </p></li>
</ul>

<p> </p>
<p id="rfc.section.5.7.p.4">Finally, if this description is of type "pranswer" or "answer", follow the processing defined in the <a href="#sec.applying-an-answer">Section 5.9</a> section below.</p>
<h1 id="rfc.section.5.8"><a href="#rfc.section.5.8">5.8.</a> <a href="#sec.applying-a-remote-desc" id="sec.applying-a-remote-desc">Applying a Remote Description</a></h1>
<p id="rfc.section.5.8.p.1">If the answer contains any "a=ice-options" attributes where "trickle" is listed as an attribute, update the PeerConnection canTrickle property to be true. Otherwise, set this property to false.</p>
<p id="rfc.section.5.8.p.2">The following steps are performed at the media engine level to apply a remote description.</p>
<p id="rfc.section.5.8.p.3">For each media section, the following steps MUST be performed; if any parameters are out of bounds, or cannot be applied, processing MUST stop and an error MUST be returned.  </p>

<ul>
  <li>If the description is of type "offer", and the ICE ufrag or password changed from the previous remote description, as described in Section 9.1.1.1 of <a href="#RFC5245">[RFC5245]</a>, mark that an ICE restart is needed.</li>
  <li>Configure the ICE components associated with this media section to use the supplied ICE remote ufrag and password for their connectivity checks.</li>
  <li>Pair any supplied ICE candidates with any gathered local candidates, as described in Section 5.7 of <a href="#RFC5245">[RFC5245]</a> and start connectivity checks with the appropriate credentials.</li>
  <li>If the media section proto value indicates use of RTP: <ul><li>[TODO: header extensions]</li><li>For each specified payload type that is also supported by the local implementation, establish a mapping between the payload type ID and the actual media format.  [TODO - Justin to add more to explain mapping.] If any indicated payload type is unknown, it MUST be ignored. [TODO: should fail on answers]</li><li>For each specified "rtx" media format, establish a mapping between the RTX payload type and its associated primary payload type, as described in <a href="#RFC4588">[RFC4588]</a>. If any referenced primary payload types are not present, this MUST result in an error.</li><li>For each specified fmtp parameter that is supported by the local implementation, enable them on the associated payload types.</li><li>For each specified RTCP feedback mechanism that is supported by the local implementation, enable them on the associated payload types.</li><li>For any specified "TIAS" bandwidth value, set this value as the maximum RTP bitrate to be used when sending media. If a "TIAS" value is not present, but an "AS" value is, generate a TIAS a value using this formula: [TODO: convert AS to TIAS].</li><li>[TODO: handling of CN, telephone-event, "red"]</li><li>If the media section if of type audio: <ul><li>For any specified "ptime" value, configure the available payload types to use the specified packet size. If the specified size is not supported for a payload type, use the next closest value instead.</li></ul><p> </p></li></ul><p> </p></li>
</ul>

<p> </p>
<p id="rfc.section.5.8.p.4">Finally, if this description is of type "pranswer" or "answer", follow the processing defined in the <a href="#sec.applying-an-answer">Section 5.9</a> section below.</p>
<h1 id="rfc.section.5.9"><a href="#rfc.section.5.9">5.9.</a> <a href="#sec.applying-an-answer" id="sec.applying-an-answer">Applying an Answer</a></h1>
<p id="rfc.section.5.9.p.1">In addition to the steps mentioned above for processing a local or remote description, the following steps are performed when processing a description of type "pranswer" or "answer".</p>
<p id="rfc.section.5.9.p.2">For each media section, the following steps MUST be performed: </p>

<ul>
  <li>If the media section has been rejected (i.e. port is set to zero in the answer), stop any reception or transmission of media for this section, and discard any associated ICE components, as described in Section 9.2.1.3 of <a href="#RFC5245">[RFC5245]</a>.</li>
  <li>If the remote DTLS fingerprint has been changed, tear down the existing DTLS connection.</li>
  <li>If no valid DTLS connection exists, prepare to start a DTLS connection, using the specified roles and fingerprints, on any underlying ICE components, once they are active.</li>
  <li>If the media section proto value indicates use of RTP: <ul><li>If the media section has RTCP mux enabled, discard any RTCP component, and begin or continue muxing RTCP over the RTP component, as specified in <a href="#RFC5761">[RFC5761]</a>, Section 5.1.3. Otherwise, transmit RTCP over the RTCP component; if no RTCP component exists, because RTCP mux was previously enabled, this MUST result in an error.</li><li>If the media section has reduced-size RTCP enabled, configure the RTCP transmission for this media section to use reduced-size RTCP, as specified in <a href="#RFC5506">[RFC5506]</a>. </li><li>If the directional attribute in the answer is of type "sendrecv" or "sendonly", prepare to start transmitting media using the specified primary SSRC and one of the selected payload types, once the underlying transport layers have been established. Otherwise, stop transmitting RTP media, although RTCP should still be sent, as described in <a href="#RFC3264">[RFC3264]</a>, Section 5.1. </li></ul><p> </p></li>
  <li>If the media section proto value indicates use of SCTP: <ul><li>If no SCTP association yet exists, prepare to initiate a SCTP association over the associated ICE component and DTLS connection, using the local SCTP port value from the local description, and the remote SCTP port value from the remote description, as described in <a href="#I-D.ietf-mmusic-sctp-sdp">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 10.2.</li></ul><p> </p></li>
</ul>

<p> </p>
<p id="rfc.section.5.9.p.3">If the answer contains valid BUNDLE groups, discard any ICE components for the m= sections that will be bundled onto the primary ICE components in each BUNDLE, and begin muxing these m= sections accordingly, as described in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 8.2.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#sec.configurable-sdp-paramete" id="sec.configurable-sdp-paramete">Configurable SDP Parameters</a></h1>
<p id="rfc.section.6.p.1">It is possible to change elements in the SDP returned from createOffer before passing it to setLocalDescription. When an implementation receives modified SDP it MUST either: </p>
<p/>

<ul>
  <li>Accept the changes and adjust its behavior to match the SDP.</li>
  <li>Reject the changes and return an error via the error callback.</li>
</ul>

<p> </p>
<p id="rfc.section.6.p.3">Changes MUST NOT be silently ignored.  </p>
<p id="rfc.section.6.p.4">The following elements of the session description MUST NOT be changed between the createOffer and the setLocalDescription (or between the createAnswer and the setLocalDescription), since they reflect transport attributes that are solely under browser control, and the browser MUST NOT honor an attempt to change them:</p>
<p/>

<ul>
  <li>The number, type and port number of m= lines.</li>
  <li>The generated ICE credentials (a=ice-ufrag and a=ice-pwd).</li>
  <li>The set of ICE candidates and their parameters (a=candidate).</li>
  <li>The DTLS fingerprint(s) (a=fingerprint).</li>
  <li>The contents of BUNDLE groups, bundle-only parameters, or "a=rtcp-mux" parameters.</li>
</ul>
<p id="rfc.section.6.p.6">The following modifications, if done by the browser to a description between createOffer/createAnswer and the setLocalDescription, MUST be honored by the browser:</p>
<p/>

<ul>
  <li>Remove or reorder codecs (m=)</li>
</ul>
<p id="rfc.section.6.p.8">The following parameters may be controlled by options passed into createOffer/createAnswer. As an open issue, these changes may also be be performed by manipulating the SDP returned from createOffer/createAnswer, as indicated above, as long as the capabilities of the endpoint are not exceeded (e.g. asking for a resolution greater than what the endpoint can encode):</p>
<p/>

<ul>
  <li>[[OPEN ISSUE: This is a placeholder for other modifications, which we may continue adding as use cases appear.]]</li>
</ul>
<p id="rfc.section.6.p.10">Implementations MAY choose to either honor or reject any elements not listed in the above two categories, but must do so explicitly as described at the beginning of this section. Note that future standards may add new SDP elements to the list of elements which must be accepted or rejected, but due to version skew, applications must be prepared for implementations to accept changes which must be rejected and vice versa.</p>
<p id="rfc.section.6.p.11">The application can also modify the SDP to reduce the capabilities in the offer it sends to the far side or the offer that it installs from the far side in any way the application sees fit, as long as it is a valid SDP offer and specifies a subset of what was in the original offer.  This is safe because the answer is not permitted to expand capabilities and therefore will just respond to what is actually in the offer.</p>
<p id="rfc.section.6.p.12">As always, the application is solely responsible for what it sends to the other party, and all incoming SDP will be processed by the browser to the extent of its capabilities. It is an error to assume that all SDP is well-formed; however, one should be able to assume that any implementation of this specification will be able to process, as a remote offer or answer, unmodified SDP coming from any other implementation of this specification.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#sec.examples" id="sec.examples">Examples</a></h1>
<p id="rfc.section.7.p.1">Note that this example section shows several SDP fragments. To format in 72 columns, some of the lines in SDP have been split into multiple lines, where leading whitespace indicates that a line is a continuation of the previous line.  In addition, some blank lines have been added to improve readability but are not valid in SDP.</p>
<p id="rfc.section.7.p.2">More examples of SDP for WebRTC call flows can be found in <a href="#I-D.nandakumar-rtcweb-sdp">[I-D.nandakumar-rtcweb-sdp]</a>. </p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#sec.simple-examples" id="sec.simple-examples">Simple Example</a></h1>
<p id="rfc.section.7.1.p.1">This section shows a very simple example that sets up a minimal audio / video call between two browsers and does not use trickle ICE. The example in the following section provides a more realistic example of what would happen in a normal browser to browser connection. </p>
<p id="rfc.section.7.1.p.2">The flow shows Alice's browser initiating the session to Bob's browser. The messages from Alice's JS to Bob's JS are assumed to flow over some signaling protocol via a web server. The JS on both Alice's side and Bob's side waits for all candidates before sending the offer or answer, so the offers and answers are complete. Trickle ICE is not used. Both Alice and Bob are using the default policy of balanced. </p>
<pre>
//                  set up local media state
AliceJS-&gt;AliceUA:   create new PeerConnection
AliceJS-&gt;AliceUA:   addStream with stream containing audio and video
AliceJS-&gt;AliceUA:   createOffer to get offer
AliceJS-&gt;AliceUA:   setLocalDescription with offer
AliceUA-&gt;AliceJS:   multiple onicecandidate events with candidates

//                  wait for ICE gathering to complete
AliceUA-&gt;AliceJS:   onicecandidate event with null candidate
AliceJS-&gt;AliceUA:   get |offer-A1| from value of localDescription

//                  |offer-A1| is sent over signaling protocol to Bob
AliceJS-&gt;WebServer: signaling with |offer-A1|
WebServer-&gt;BobJS:   signaling with |offer-A1|

//                  |offer-A1| arrives at Bob
BobJS-&gt;BobUA:       create a PeerConnection
BobJS-&gt;BobUA:       setRemoteDescription with |offer-A1|
BobUA-&gt;BobJS:       onaddstream event with remoteStream

//                  Bob accepts call
BobJS-&gt;BobUA:       addStream with local media
BobJS-&gt;BobUA:       createAnswer
BobJS-&gt;BobUA:       setLocalDescription with answer
BobUA-&gt;BobJS:       multiple onicecandidate events with candidates

//                  wait for ICE gathering to complete
BobUA-&gt;BobJS:       onicecandidate event with null candidate
BobJS-&gt;BobUA:       get |answer-A1| from value of localDescription

//                  |answer-A1| is sent over signaling protocol to Alice
BobJS-&gt;WebServer:   signaling with |answer-A1|
WebServer-&gt;AliceJS: signaling with |answer-A1|

//                  |answer-A1| arrives at Alice
AliceJS-&gt;AliceUA:   setRemoteDescription with |answer-A1|
AliceUA-&gt;AliceJS:   onaddstream event with remoteStream

//                  media flows
BobUA-&gt;AliceUA:     media sent from Bob to Alice
AliceUA-&gt;BobUA:     media sent from Alice to Bob
</pre>
<p/>
<p id="rfc.section.7.1.p.4">The SDP for |offer-A1| looks like: </p>
<pre>
v=0
o=- 4962303333179871722 1 IN IP4 0.0.0.0
s=-
t=0 0
a=group:BUNDLE a1 v1
a=ice-options:trickle
m=audio 56500 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 192.0.2.1
a=mid:a1
a=rtcp:56501 IN IP4 192.0.2.1
a=msid:47017fee-b6c1-4162-929c-a25110252400
       f83006c5-a0ff-4e0a-9ed9-d3e6747be7d9
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=maxptime:120
a=ice-ufrag:ETEn1v9DoTMB9J4r
a=ice-pwd:OtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
             :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=rtcp-mux
a=rtcp-rsize
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
a=ssrc:1732846380 cname:EocUG1f0fcg/yvY7
a=candidate:3348148302 1 udp 2113937151 192.0.2.1 56500
            typ host
a=candidate:3348148302 2 udp 2113937151 192.0.2.1 56501
            typ host
a=end-of-candidates

m=video 56502 UDP/TLS/RTP/SAVPF 100 101
c=IN IP4 192.0.2.1
a=rtcp:56503 IN IP4 192.0.2.1
a=mid:v1
a=msid:61317484-2ed4-49d7-9eb7-1414322a7aae
       f30bdb4a-5db8-49b5-bcdc-e0c9a23172e0
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 rtx/90000
a=fmtp:101 apt=100
a=ice-ufrag:BGKkWnG5GmiUpdIV
a=ice-pwd:mqyWsAjvtKwTGnvhPztQ9mIf
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
             :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=rtcp-mux
a=rtcp-rsize
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:mid
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=ssrc:1366781083 cname:EocUG1f0fcg/yvY7
a=ssrc:1366781084 cname:EocUG1f0fcg/yvY7
a=ssrc-group:FID 1366781083 1366781084
a=candidate:3348148302 1 udp 2113937151 192.0.2.1 56502
            typ host
a=candidate:3348148302 2 udp 2113937151 192.0.2.1 56503
            typ host
a=end-of-candidates
          </pre>
<p/>
<p id="rfc.section.7.1.p.6">The SDP for |answer-A1| looks like: </p>
<pre>
v=0
o=- 6729291447651054566 1 IN IP4 0.0.0.0
s=-
t=0 0
m=audio 20000 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 192.0.2.2
a=mid:a1
a=rtcp:20000 IN IP4 192.0.2.2
a=msid:PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1
       PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1a0
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=maxptime:120
a=ice-ufrag:6sFvz2gdLkEwjZEr
a=ice-pwd:cOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
            :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:active
a=rtcp-mux
a=rtcp-rsize
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=ssrc:3429951804 cname:Q/NWs1ao1HmN4Xa5
a=candidate:2299743422 1 udp 2113937151 192.0.2.2 20000
            typ host
a=end-of-candidates

m=video 20001 UDP/TLS/RTP/SAVPF 100 101
c=IN IP4 192.0.2.2
a=rtcp 20001 IN IP4 192.0.2.2
a=mid:v1
a=msid:PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1
       PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1v0
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 rtx/90000
a=fmtp:101 apt=100
a=ice-ufrag:6sFvz2gdLkEwjZEr
a=ice-pwd:cOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                     :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:active
a=rtcp-mux
a=rtcp-rsize
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=ssrc:3229706345 cname:Q/NWs1ao1HmN4Xa5
a=ssrc:3229706346 cname:Q/NWs1ao1HmN4Xa5
a=ssrc-group:FID 3229706345 3229706346
a=candidate:2299743422 1 udp 2113937151 192.0.2.2 20001
            typ host
a=end-of-candidates
          </pre>
<p/>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#sec.normal-examples" id="sec.normal-examples">Normal Examples</a></h1>
<p id="rfc.section.7.2.p.1">This section shows a typical example of a session between two browsers setting up an audio channel and a data channel. Trickle ICE is used in full trickle mode with a bundle policy of max-bundle, an RTCP mux policy of require, and a single TURN server.  Later, two video flows, one for the presenter and one for screen sharing, are added to the session.  This example shows Alice's browser initiating the session to Bob's browser. The messages from Alice's JS to Bob's JS are assumed to flow over some signaling protocol via a web server. </p>
<pre>
//                  set up local media state
AliceJS-&gt;AliceUA:   create new PeerConnection
AliceJS-&gt;AliceUA:   addStream that contains audio track
AliceJS-&gt;AliceUA:   createDataChannel to get data channel
AliceJS-&gt;AliceUA:   createOffer to get |offer-B1|
AliceJS-&gt;AliceUA:   setLocalDescription with |offer-B1|

//                  |offer-B1| is sent over signaling protocol to Bob
AliceJS-&gt;WebServer: signaling with |offer-B1|
WebServer-&gt;BobJS:   signaling with |offer-B1|

//                  |offer-B1| arrives at Bob
BobJS-&gt;BobUA:       create a PeerConnection
BobJS-&gt;BobUA:       setRemoteDescription with |offer-B1|
BobUA-&gt;BobJS:       onaddstream with audio track from Alice

//                  candidates are sent to Bob
AliceUA-&gt;AliceJS:   onicecandidate event with |candidate-B1| (host)
AliceJS-&gt;WebServer: signaling with |candidate-B1|
AliceUA-&gt;AliceJS:   onicecandidate event with |candidate-B2| (srflx)
AliceJS-&gt;WebServer: signaling with |candidate-B2|
AliceUA-&gt;AliceJS:   onicecandidate event with |candidate-B3| (relay)
AliceJS-&gt;WebServer: signaling with |candidate-B3|

WebServer-&gt;BobJS:   signaling with |candidate-B1|
BobJS-&gt;BobUA:       addIceCandidate with |candidate-B1|
WebServer-&gt;BobJS:   signaling with |candidate-B2|
BobJS-&gt;BobUA:       addIceCandidate with |candidate-B2|
WebServer-&gt;BobJS:   signaling with |candidate-B3|
BobJS-&gt;BobUA:       addIceCandidate with |candidate-B3|

//                  Bob accepts call
BobJS-&gt;BobUA:       addStream with local audio stream
BobJS-&gt;BobUA:       createDataChannel to get data channel
BobJS-&gt;BobUA:       createAnswer to get |answer-B1|
BobJS-&gt;BobUA:       setLocalDescription with |answer-B1|

//                  |answer-B1| is sent to Alice
BobJS-&gt;WebServer:   signaling with |answer-B1|
WebServer-&gt;AliceJS: signaling with |answer-B1|
AliceJS-&gt;AliceUA:   setRemoteDescription with |answer-B1|
AliceUA-&gt;AliceJS:   onaddstream event with audio track from Bob

//                  candidates are sent to Alice
BobUA-&gt;BobJS:       onicecandidate event with |candidate-B4| (host)
BobJS-&gt;WebServer:   signaling with |candidate-B4|
BobUA-&gt;BobJS:       onicecandidate event with |candidate-B5| (srflx)
BobJS-&gt;WebServer:   signaling with |candidate-B5|
BobUA-&gt;BobJS:       onicecandidate event with |candidate-B6| (relay)
BobJS-&gt;WebServer:   signaling with |candidate-B6|

WebServer-&gt;AliceJS: signaling with |candidate-B4|
AliceJS-&gt;AliceUA:   addIceCandidate with |candidate-B4|
WebServer-&gt;AliceJS: signaling with |candidate-B5|
AliceJS-&gt;AliceUA:   addIceCandidate with |candidate-B5|
WebServer-&gt;AliceJS: signaling with |candidate-B6|
AliceJS-&gt;AliceUA:   addIceCandidate with |candidate-B6|

//                  data channel opens
BobUA-&gt;BobJS:       ondatachannel event
AliceUA-&gt;AliceJS:   ondatachannel event
BobUA-&gt;BobJS:       onopen
AliceUA-&gt;AliceJS:   onopen

//                  media is flowing between browsers
BobUA-&gt;AliceUA:     audio+data sent from Bob to Alice
AliceUA-&gt;BobUA:     audio+data sent from Alice to Bob

//                  some time later Bob adds two video streams
//                  note, no candidates exchanged, because of BUNDLE
BobJS-&gt;BobUA:       addStream with first video stream
BobJS-&gt;BobUA:       addStream with second video stream
BobJS-&gt;BobUA:       createOffer to get |offer-B2|
BobJS-&gt;BobUA:       setLocalDescription with |offer-B2|

//                  |offer-B2| is sent to Alice
BobJS-&gt;WebServer:   signaling with |offer-B2|
WebServer-&gt;AliceJS: signaling with |offer-B2|
AliceJS-&gt;AliceUA:   setRemoteDescription with |offer-B2|
AliceUA-&gt;AliceJS:   onaddstream event with first video stream
AliceUA-&gt;AliceJS:   onaddstream event with second video stream
AliceJS-&gt;AliceUA:   createAnswer to get |answer-B2|
AliceJS-&gt;AliceUA:   setLocalDescription with |answer-B2|

//                  |answer-B2| is sent over signaling protocol to Bob
AliceJS-&gt;WebServer: signaling with |answer-B2|
WebServer-&gt;BobJS:   signaling with |answer-B2|
BobJS-&gt;BobUA:       setRemoteDescription with |answer-B2|

//                  media is flowing between browsers
BobUA-&gt;AliceUA:     audio+video+data sent from Bob to Alice
AliceUA-&gt;BobUA:     audio+video+data sent from Alice to Bob
</pre>
<p/>
<p id="rfc.section.7.2.p.3">The SDP for |offer-B1| looks like: </p>
<pre>
v=0
o=- 4962303333179871723 1 IN IP4 0.0.0.0
s=-
t=0 0
a=group:BUNDLE a1 d1
a=ice-options:trickle
m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 0.0.0.0
a=rtcp:9 IN IP4 0.0.0.0
a=mid:a1
a=msid:57017fee-b6c1-4162-929c-a25110252400
       e83006c5-a0ff-4e0a-9ed9-d3e6747be7d9
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=maxptime:120
a=ice-ufrag:ATEn1v9DoTMB9J4r
a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
             :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=rtcp-mux
a=rtcp-rsize
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
a=ssrc:1732846380 cname:FocUG1f0fcg/yvY7

m=application 9 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 0.0.0.0
a=mid:d1
a=fmtp:webrtc-datachannel max-message-size=65536
a=sctp-port 5000
a=ice-ufrag:ATEn1v9DoTMB9J4r
a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                     :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
         </pre>
<p/>
<p id="rfc.section.7.2.p.5">The SDP for |candidate-B1| looks like: </p>
<pre>
candidate:109270923 1 udp 2122194687 192.168.1.2 51556 typ host
         </pre>
<p/>
<p id="rfc.section.7.2.p.7">The SDP for |candidate-B2| looks like: </p>
<pre>
candidate:4036177503 1 udp 1685987071 11.22.33.44 52546 typ srflx
          raddr 192.168.1.2 rport 51556
         </pre>
<p/>
<p id="rfc.section.7.2.p.9">The SDP for |candidate-B3| looks like: </p>
<pre>
candidate:3671762466 1 udp 41819903 22.33.44.55 61405 typ relay
          raddr 11.22.33.44 rport 52546
         </pre>
<p/>
<p id="rfc.section.7.2.p.11">The SDP for |answer-B1| looks like: </p>
<pre>
v=0
o=- 7729291447651054566 1 IN IP4 0.0.0.0
s=-
t=0 0
a=group:BUNDLE a1 d1
a=ice-options:trickle
m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 0.0.0.0
a=rtcp:9 IN IP4 0.0.0.0
a=mid:a1
a=msid:QI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1
       QI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1a0
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=maxptime:120
a=ice-ufrag:7sFvz2gdLkEwjZEr
a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                     :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:active
a=rtcp-mux
a=rtcp-rsize
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
a=ssrc:4429951804 cname:Q/NWs1ao1HmN4Xa5

m=application 9 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 0.0.0.0
a=mid:d1
a=fmtp:webrtc-datachannel max-message-size=65536
a=sctp-port 5000
a=ice-ufrag:7sFvz2gdLkEwjZEr
a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                     :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:active
         </pre>
<p/>
<p id="rfc.section.7.2.p.13">The SDP for |candidate-B4| looks like: </p>
<pre>
candidate:109270924 1 udp 2122194687 192.168.2.3 61665 typ host
     </pre>
<p/>
<p id="rfc.section.7.2.p.15">The SDP for |candidate-B5| looks like: </p>
<pre>
candidate:4036177504 1 udp 1685987071 55.66.77.88 64532 typ srflx
          raddr 192.168.2.3 rport 61665
     </pre>
<p/>
<p id="rfc.section.7.2.p.17">The SDP for |candidate-B6| looks like: </p>
<pre>
candidate:3671762467 1 udp 41819903 66.77.88.99 50416 typ relay
          raddr 55.66.77.88 rport 64532
     </pre>
<p/>
<p id="rfc.section.7.2.p.19">The SDP for |offer-B2| looks like: (note the increment of the version number in the o= line, and the c= and a=rtcp lines, which indicate the local candidate that was selected) </p>
<pre>
v=0
o=- 7729291447651054566 2 IN IP4 0.0.0.0
s=-
t=0 0
a=group:BUNDLE a1 d1 v1 v2
a=ice-options:trickle
m=audio 64532 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 55.66.77.88
a=rtcp:64532 IN IP4 55.66.77.88
a=mid:a1
a=msid:QI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1
       QI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1a0
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=maxptime:120
a=ice-ufrag:7sFvz2gdLkEwjZEr
a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                     :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:actpass
a=rtcp-mux
a=rtcp-rsize
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
a=ssrc:4429951804 cname:Q/NWs1ao1HmN4Xa5
a=candidate:109270924 1 udp 2122194687 192.168.2.3 61665 typ host
a=candidate:4036177504 1 udp 1685987071 55.66.77.88 64532 typ srflx
            raddr 192.168.2.3 rport 61665
a=candidate:3671762467 1 udp 41819903 66.77.88.99 50416 typ relay
            raddr 55.66.77.88 rport 64532
a=end-of-candidates

m=application 64532 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 55.66.77.88
a=mid:d1
a=fmtp:webrtc-datachannel max-message-size=65536
a=sctp-port 5000
a=ice-ufrag:7sFvz2gdLkEwjZEr
a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                     :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:actpass
a=candidate:109270924 1 udp 2122194687 192.168.2.3 61665 typ host
a=candidate:4036177504 1 udp 1685987071 55.66.77.88 64532 typ srflx
            raddr 192.168.2.3 rport 61665
a=candidate:3671762467 1 udp 41819903 66.77.88.99 50416 typ relay
            raddr 55.66.77.88 rport 64532
a=end-of-candidates

m=video 64532 UDP/TLS/RTP/SAVPF 100 101
c=IN IP4 55.66.77.88
a=rtcp:64532 IN IP4 55.66.77.88
a=mid:v1
a=msid:61317484-2ed4-49d7-9eb7-1414322a7aae
       f30bdb4a-5db8-49b5-bcdc-e0c9a23172e0
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 rtx/90000
a=fmtp:101 apt=100
a=ice-ufrag:7sFvz2gdLkEwjZEr
a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
             :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=rtcp-mux
a=rtcp-rsize
a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=ssrc:1366781083 cname:Q/NWs1ao1HmN4Xa5
a=ssrc:1366781084 cname:Q/NWs1ao1HmN4Xa5
a=ssrc-group:FID 1366781083 1366781084
a=candidate:109270924 1 udp 2122194687 192.168.2.3 61665 typ host
a=candidate:4036177504 1 udp 1685987071 55.66.77.88 64532 typ srflx
            raddr 192.168.2.3 rport 61665
a=candidate:3671762467 1 udp 41819903 66.77.88.99 50416 typ relay
            raddr 55.66.77.88 rport 64532
a=end-of-candidates

m=video 64532 UDP/TLS/RTP/SAVPF 100 101
c=IN IP4 55.66.77.88
a=rtcp:64532 IN IP4 55.66.77.88
a=mid:v1
a=msid:71317484-2ed4-49d7-9eb7-1414322a7aae
       f30bdb4a-5db8-49b5-bcdc-e0c9a23172e0
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 rtx/90000
a=fmtp:101 apt=100
a=ice-ufrag:7sFvz2gdLkEwjZEr
a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
             :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=rtcp-mux
a=rtcp-rsize
a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=ssrc:2366781083 cname:Q/NWs1ao1HmN4Xa5
a=ssrc:2366781084 cname:Q/NWs1ao1HmN4Xa5
a=ssrc-group:FID 2366781083 2366781084
a=candidate:109270924 1 udp 2122194687 192.168.2.3 61665 typ host
a=candidate:4036177504 1 udp 1685987071 55.66.77.88 64532 typ srflx
            raddr 192.168.2.3 rport 61665
a=candidate:3671762467 1 udp 41819903 66.77.88.99 50416 typ relay
            raddr 55.66.77.88 rport 64532
a=end-of-candidates

         </pre>
<p/>
<p id="rfc.section.7.2.p.21">The SDP for |answer-B2| looks like: (note the use of setup:passive to maintain the existing DTLS roles, and the use of a=recvonly to indicate that the video streams are one-way) </p>
<pre>
v=0
o=- 4962303333179871723 2 IN IP4 0.0.0.0
s=-
t=0 0
a=group:BUNDLE a1 d1 v1 v2
a=ice-options:trickle
m=audio 52546 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 11.22.33.44
a=rtcp:52546 IN IP4 11.22.33.44
a=mid:a1
a=msid:57017fee-b6c1-4162-929c-a25110252400
       e83006c5-a0ff-4e0a-9ed9-d3e6747be7d9
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=maxptime:120
a=ice-ufrag:ATEn1v9DoTMB9J4r
a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
             :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:passive
a=rtcp-mux
a=rtcp-rsize
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
a=ssrc:1732846380 cname:FocUG1f0fcg/yvY7
a=candidate:109270923 1 udp 2122194687 192.168.1.2 51556 typ host
a=candidate:4036177503 1 udp 1685987071 11.22.33.44 52546 typ srflx
            raddr 192.168.1.2 rport 51556
a=candidate:3671762466 1 udp 41819903 22.33.44.55 61405 typ relay
            raddr 11.22.33.44 rport 52546
a=end-of-candidates

m=application 52546 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 11.22.33.44
a=mid:d1
a=fmtp:webrtc-datachannel max-message-size=65536
a=sctp-port 5000
a=ice-ufrag:ATEn1v9DoTMB9J4r
a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                     :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:passive
a=candidate:109270923 1 udp 2122194687 192.168.1.2 51556 typ host
a=candidate:4036177503 1 udp 1685987071 11.22.33.44 52546 typ srflx
            raddr 192.168.1.2 rport 51556
a=candidate:3671762466 1 udp 41819903 22.33.44.55 61405 typ relay
            raddr 11.22.33.44 rport 52546
a=end-of-candidates

m=video 52546 UDP/TLS/RTP/SAVPF 100 101
c=IN IP4 11.22.33.44
a=rtcp:52546 IN IP4 11.22.33.44
a=mid:v1
a=recvonly
a=rtpmap:100 VP8/90000
a=rtpmap:101 rtx/90000
a=fmtp:101 apt=100
a=ice-ufrag:ATEn1v9DoTMB9J4r
a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
             :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:passive
a=rtcp-mux
a=rtcp-rsize
a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=candidate:109270923 1 udp 2122194687 192.168.1.2 51556 typ host
a=candidate:4036177503 1 udp 1685987071 11.22.33.44 52546 typ srflx
          raddr 192.168.1.2 rport 51556
a=candidate:3671762466 1 udp 41819903 22.33.44.55 61405 typ relay
          raddr 11.22.33.44 rport 52546
a=end-of-candidates

m=video 52546 UDP/TLS/RTP/SAVPF 100 101
c=IN IP4 11.22.33.44
a=rtcp:52546 IN IP4 11.22.33.44
a=mid:v2
a=recvonly
a=rtpmap:100 VP8/90000
a=rtpmap:101 rtx/90000
a=fmtp:101 apt=100
a=ice-ufrag:ATEn1v9DoTMB9J4r
a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
             :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:passive
a=rtcp-mux
a=rtcp-rsize
a=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=candidate:109270923 1 udp 2122194687 192.168.1.2 51556 typ host
a=candidate:4036177503 1 udp 1685987071 11.22.33.44 52546 typ srflx
            raddr 192.168.1.2 rport 51556
a=candidate:3671762466 1 udp 41819903 22.33.44.55 61405 typ relay
            raddr 11.22.33.44 rport 52546
a=end-of-candidates
         </pre>
<p/>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#sec.security-considerations" id="sec.security-considerations">Security Considerations</a></h1>
<p id="rfc.section.8.p.1">The IETF has published separate documents <a href="#I-D.ietf-rtcweb-security-arch">[I-D.ietf-rtcweb-security-arch]</a> <a href="#I-D.ietf-rtcweb-security">[I-D.ietf-rtcweb-security]</a> describing the security architecture for WebRTC as a whole.  The remainder of this section describes security considerations for this document.  </p>
<p id="rfc.section.8.p.2">While formally the JSEP interface is an API, it is better to think of it is an Internet protocol, with the JS being untrustworthy from the perspective of the browser. Thus, the threat model of <a href="#RFC3552">[RFC3552]</a> applies.  In particular, JS can call the API in any order and with any inputs, including malicious ones. This is particularly relevant when we consider the SDP which is passed to setLocalDescription(). While correct API usage requires that the application pass in SDP which was derived from createOffer() or createAnswer() (perhaps suitably modified as described in <a href="#sec.configurable-sdp-paramete">Section 6</a>, there is no guarantee that applications do so. The browser MUST be prepared for the JS to pass in bogus data instead.  </p>
<p id="rfc.section.8.p.3">Conversely, the application programmer MUST recognize that the JS does not have complete control of browser behavior. One case that bears particular mention is that editing ICE candidates out of the SDP or suppressing trickled candidates does not have the expected behavior: implementations will still perform checks from those candidates even if they are not sent to the other side.  Thus, for instance, it is not possible to prevent the remote peer from learning your public IP address by removing server reflexive candidates. Applications which wish to conceal their public IP address should instead configure the ICE agent to use only relay candidates.  </p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#sec.iana-considerations" id="sec.iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.9.p.1">This document requires no actions from IANA.</p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#sec.acknowledgements" id="sec.acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.10.p.1">Significant text incorporated in the draft as well and review was provided by Harald Alvestrand and Suhas Nandakumar.  Dan Burnett, Neil Stratford, Eric Rescorla, Anant Narayanan, Andrew Hutton, Richard Ejzak,    Adam Bergkvist and Matthew Kaufman all provided valuable feedback on this proposal.  </p>
<h1 id="rfc.references"><a href="#rfc.references">11.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">11.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-mmusic-msid">[I-D.ietf-mmusic-msid]</b>
      </td>
      <td class="top"><a>Alvestrand, H.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-mmusic-msid-01">Cross Session Stream Identification in the Session Description Protocol</a>", Internet-Draft draft-ietf-mmusic-msid-01, August 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-mmusic-sctp-sdp">[I-D.ietf-mmusic-sctp-sdp]</b>
      </td>
      <td class="top"><a>Loreto, S.</a> and <a>G. Camarillo</a>, "<a href="http://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-04">Stream Control Transmission Protocol (SCTP)-Based Media Transport in the Session Description Protocol (SDP)</a>", Internet-Draft draft-ietf-mmusic-sctp-sdp-04, June 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-mmusic-sdp-bundle-negotiation">[I-D.ietf-mmusic-sdp-bundle-negotiation]</b>
      </td>
      <td class="top"><a>Holmberg, C.</a>, <a>Alvestrand, H.</a> and <a>C. Jennings</a>, "<a href="http://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-04">Multiplexing Negotiation Using Session Description Protocol (SDP) Port Numbers</a>", Internet-Draft draft-ietf-mmusic-sdp-bundle-negotiation-04, June 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-mmusic-sdp-mux-attributes">[I-D.ietf-mmusic-sdp-mux-attributes]</b>
      </td>
      <td class="top"><a>Nandakumar, S.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-mmusic-sdp-mux-attributes-01">A Framework for SDP Attributes when Multiplexing</a>", Internet-Draft draft-ietf-mmusic-sdp-mux-attributes-01, February 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-mmusic-trickle-ice">[I-D.ietf-mmusic-trickle-ice]</b>
      </td>
      <td class="top"><a>Ivov, E.</a>, <a>Rescorla, E.</a> and <a>J. Uberti</a>, "<a href="http://tools.ietf.org/html/draft-ietf-mmusic-trickle-ice-00">Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol</a>", Internet-Draft draft-ietf-mmusic-trickle-ice-00, March 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-audio">[I-D.ietf-rtcweb-audio]</b>
      </td>
      <td class="top"><a>Valin, J.</a> and <a>C. Bran</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-audio-02">WebRTC Audio Codec and Processing Requirements</a>", Internet-Draft draft-ietf-rtcweb-audio-02, August 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-data-protocol">[I-D.ietf-rtcweb-data-protocol]</b>
      </td>
      <td class="top"><a>Jesup, R.</a>, <a>Loreto, S.</a> and <a>M. Tuexen</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-data-protocol-04">WebRTC Data Channel Protocol</a>", Internet-Draft draft-ietf-rtcweb-data-protocol-04, February 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-fec">[I-D.ietf-rtcweb-fec]</b>
      </td>
      <td class="top"><a>Uberti, J.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-fec-00">WebRTC Forward Error Correction Requirements</a>", Internet-Draft draft-ietf-rtcweb-fec-00, February 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</b>
      </td>
      <td class="top"><a>Perkins, C.</a>, <a>Westerlund, M.</a> and <a>J. Ott</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage-09">Web Real-Time Communication (WebRTC): Media Transport and Use of RTP</a>", Internet-Draft draft-ietf-rtcweb-rtp-usage-09, September 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-security">[I-D.ietf-rtcweb-security]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-security-06">Security Considerations for WebRTC</a>", Internet-Draft draft-ietf-rtcweb-security-06, January 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-security-arch">[I-D.ietf-rtcweb-security-arch]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-security-arch-09">WebRTC Security Architecture</a>", Internet-Draft draft-ietf-rtcweb-security-arch-09, February 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-video">[I-D.ietf-rtcweb-video]</b>
      </td>
      <td class="top"><a>Roach, A.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-video-00">WebRTC Video Processing and Codec Requirements</a>", Internet-Draft draft-ietf-rtcweb-video-00, July 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.nandakumar-mmusic-proto-iana-registration">[I-D.nandakumar-mmusic-proto-iana-registration]</b>
      </td>
      <td class="top"><a href="mailto:snandaku@cisco.com" title="Cisco Systems Inc">Nandakumar, S.</a>, "<a>IANA registration of SDP 'proto' attribute for transporting RTP Media over TCP under various RTP profiles.</a>", September 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3261">[RFC3261]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, <a>Schulzrinne, H.</a>, <a>Camarillo, G.</a>, <a>Johnston, A.</a>, <a>Peterson, J.</a>, <a>Sparks, R.</a>, <a>Handley, M.</a> and <a>E. Schooler</a>, "<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>", RFC 3261, June 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3264">[RFC3264]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a> and <a>H. Schulzrinne</a>, "<a href="http://tools.ietf.org/html/rfc3264">An Offer/Answer Model with Session Description Protocol (SDP)</a>", RFC 3264, June 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3552">[RFC3552]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, July 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3605">[RFC3605]</b>
      </td>
      <td class="top"><a>Huitema, C.</a>, "<a href="http://tools.ietf.org/html/rfc3605">Real Time Control Protocol (RTCP) attribute in Session Description Protocol (SDP)</a>", RFC 3605, October 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4145">[RFC4145]</b>
      </td>
      <td class="top"><a>Yon, D.</a> and <a>G. Camarillo</a>, "<a href="http://tools.ietf.org/html/rfc4145">TCP-Based Media Transport in the Session Description Protocol (SDP)</a>", RFC 4145, September 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4566">[RFC4566]</b>
      </td>
      <td class="top"><a>Handley, M.</a>, <a>Jacobson, V.</a> and <a>C. Perkins</a>, "<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>", RFC 4566, July 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4572">[RFC4572]</b>
      </td>
      <td class="top"><a>Lennox, J.</a>, "<a href="http://tools.ietf.org/html/rfc4572">Connection-Oriented Media Transport over the Transport Layer Security (TLS) Protocol in the Session Description Protocol (SDP)</a>", RFC 4572, July 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4585">[RFC4585]</b>
      </td>
      <td class="top"><a>Ott, J.</a>, <a>Wenger, S.</a>, <a>Sato, N.</a>, <a>Burmeister, C.</a> and <a>J. Rey</a>, "<a href="http://tools.ietf.org/html/rfc4585">Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)</a>", RFC 4585, July 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5124">[RFC5124]</b>
      </td>
      <td class="top"><a>Ott, J.</a> and <a>E. Carrara</a>, "<a href="http://tools.ietf.org/html/rfc5124">Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)</a>", RFC 5124, February 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5245">[RFC5245]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, "<a href="http://tools.ietf.org/html/rfc5245">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>", RFC 5245, April 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5285">[RFC5285]</b>
      </td>
      <td class="top"><a>Singer, D.</a> and <a>H. Desineni</a>, "<a href="http://tools.ietf.org/html/rfc5285">A General Mechanism for RTP Header Extensions</a>", RFC 5285, July 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5761">[RFC5761]</b>
      </td>
      <td class="top"><a>Perkins, C.</a> and <a>M. Westerlund</a>, "<a href="http://tools.ietf.org/html/rfc5761">Multiplexing RTP Data and Control Packets on a Single Port</a>", RFC 5761, April 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5888">[RFC5888]</b>
      </td>
      <td class="top"><a>Camarillo, G.</a> and <a>H. Schulzrinne</a>, "<a href="http://tools.ietf.org/html/rfc5888">The Session Description Protocol (SDP) Grouping Framework</a>", RFC 5888, June 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6236">[RFC6236]</b>
      </td>
      <td class="top"><a>Johansson, I.</a> and <a>K. Jung</a>, "<a href="http://tools.ietf.org/html/rfc6236">Negotiation of Generic Image Attributes in the Session Description Protocol (SDP)</a>", RFC 6236, May 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6347">[RFC6347]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="http://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, January 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6904">[RFC6904]</b>
      </td>
      <td class="top"><a>Lennox, J.</a>, "<a href="http://tools.ietf.org/html/rfc6904">Encryption of Header Extensions in the Secure Real-time Transport Protocol (SRTP)</a>", RFC 6904, April 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7022">[RFC7022]</b>
      </td>
      <td class="top"><a>Begen, A.</a>, <a>Perkins, C.</a>, <a>Wing, D.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc7022">Guidelines for Choosing RTP Control Protocol (RTCP) Canonical Names (CNAMEs)</a>", RFC 7022, September 2013.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">11.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.nandakumar-rtcweb-sdp">[I-D.nandakumar-rtcweb-sdp]</b>
      </td>
      <td class="top"><a>Nandakumar, S.</a> and <a>C. Jennings</a>, "<a href="http://tools.ietf.org/html/draft-nandakumar-rtcweb-sdp-02">SDP for the WebRTC</a>", Internet-Draft draft-nandakumar-rtcweb-sdp-02, July 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3389">[RFC3389]</b>
      </td>
      <td class="top"><a>Zopf, R.</a>, "<a href="http://tools.ietf.org/html/rfc3389">Real-time Transport Protocol (RTP) Payload for Comfort Noise (CN)</a>", RFC 3389, September 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3556">[RFC3556]</b>
      </td>
      <td class="top"><a>Casner, S.</a>, "<a href="http://tools.ietf.org/html/rfc3556">Session Description Protocol (SDP) Bandwidth Modifiers for RTP Control Protocol (RTCP) Bandwidth</a>", RFC 3556, July 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3960">[RFC3960]</b>
      </td>
      <td class="top"><a>Camarillo, G.</a> and <a>H. Schulzrinne</a>, "<a href="http://tools.ietf.org/html/rfc3960">Early Media and Ringing Tone Generation in the Session Initiation Protocol (SIP)</a>", RFC 3960, December 2004.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4568">[RFC4568]</b>
      </td>
      <td class="top"><a>Andreasen, F.</a>, <a>Baugher, M.</a> and <a>D. Wing</a>, "<a href="http://tools.ietf.org/html/rfc4568">Session Description Protocol (SDP) Security Descriptions for Media Streams</a>", RFC 4568, July 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4588">[RFC4588]</b>
      </td>
      <td class="top"><a>Rey, J.</a>, <a>Leon, D.</a>, <a>Miyazaki, A.</a>, <a>Varsa, V.</a> and <a>R. Hakenberg</a>, "<a href="http://tools.ietf.org/html/rfc4588">RTP Retransmission Payload Format</a>", RFC 4588, July 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5506">[RFC5506]</b>
      </td>
      <td class="top"><a>Johansson, I.</a> and <a>M. Westerlund</a>, "<a href="http://tools.ietf.org/html/rfc5506">Support for Reduced-Size Real-Time Transport Control Protocol (RTCP): Opportunities and Consequences</a>", RFC 5506, April 2009.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5576">[RFC5576]</b>
      </td>
      <td class="top"><a>Lennox, J.</a>, <a>Ott, J.</a> and <a>T. Schierl</a>, "<a href="http://tools.ietf.org/html/rfc5576">Source-Specific Media Attributes in the Session Description Protocol (SDP)</a>", RFC 5576, June 2009.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5763">[RFC5763]</b>
      </td>
      <td class="top"><a>Fischl, J.</a>, <a>Tschofenig, H.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5763">Framework for Establishing a Secure Real-time Transport Protocol (SRTP) Security Context Using Datagram Transport Layer Security (DTLS)</a>", RFC 5763, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5764">[RFC5764]</b>
      </td>
      <td class="top"><a>McGrew, D.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5764">Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)</a>", RFC 5764, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5956">[RFC5956]</b>
      </td>
      <td class="top"><a>Begen, A.</a>, "<a href="http://tools.ietf.org/html/rfc5956">Forward Error Correction Grouping Semantics in the Session Description Protocol</a>", RFC 5956, September 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="W3C.WD-webrtc-20140617">[W3C.WD-webrtc-20140617]</b>
      </td>
      <td class="top"><a>Bergkvist, A.</a>, <a>Burnett, D.</a>, <a>Narayanan, A.</a> and <a>C. Jennings</a>, "<a href="http://www.w3.org/TR/2011/WD-webrtc-20140617">WebRTC 1.0: Real-time Communication Between Browsers</a>", World Wide Web Consortium WD WD-webrtc-20140617, June 2014.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#sec.change-log" id="sec.change-log">Change log</a></h1>
<p id="rfc.section.A.p.1">Note: This section will be removed by RFC Editor before publication. </p>
<p id="rfc.section.A.p.2">Changes in draft-12:</p>
<p/>

<ul>
  <li>Filled in sections on applying local and remote descriptions.</li>
  <li>Discussed downscaling and upscaling to fulfill imageattr requirements.</li>
  <li>Updated what SDP can be modified by the application.</li>
  <li>Updated to latest datachannel SDP.</li>
  <li>Allowed multiple fingerprint lines.</li>
  <li>Switched back to IPv4 for dummy candidates.</li>
  <li>Added additional clarity on ICE default candidates.</li>
</ul>

<p> </p>
<p id="rfc.section.A.p.4">Changes in draft-11:</p>
<p/>

<ul>
  <li>Clarified handling of RTP CNAMEs.</li>
  <li>Updated what SDP lines should be processed or ignored.</li>
  <li>Specified how a=imageattr should be used.</li>
</ul>

<p> </p>
<p id="rfc.section.A.p.6">Changes in draft-10:</p>
<p/>

<ul>
  <li>TODO</li>
</ul>

<p> </p>
<p id="rfc.section.A.p.8">Changes in draft-09:</p>
<p/>

<ul>
  <li>Don't return null for {local,remote}Description after close().  </li>
  <li>Changed TCP/TLS to UDP/DTLS in RTP profile names.  </li>
  <li>Separate out bundle and mux policy.  </li>
  <li>Added specific references to FEC mechanisms.  </li>
  <li>Added canTrickle mechanism.  </li>
  <li>Added section on subsequent answers and, answer options.  </li>
  <li>Added text defining set{Local,Remote}Description behavior.  </li>
</ul>

<p> </p>
<p id="rfc.section.A.p.10">Changes in draft-08: </p>

<ul>
  <li>Added new example section and removed old examples in appendix. </li>
  <li>Fixed &lt;proto&gt; field handling.</li>
  <li>Added text describing a=rtcp attribute.</li>
  <li>Reworked handling of OfferToReceiveAudio and OfferToReceiveVideo per discussion at IETF 90.</li>
  <li>Reworked trickle ICE handling and its impact on m= and c= lines per discussion at interim.</li>
  <li>Added max-bundle-and-rtcp-mux policy.</li>
  <li>Added description of maxptime handling.</li>
  <li>Updated ICE candidate pool default to 0.</li>
  <li>Resolved open issues around AppID/receiver-ID.</li>
  <li>Reworked and expanded how changes to the ICE configuration are handled.</li>
  <li>Some reference updates.</li>
  <li>Editorial clarification.</li>
</ul>
<p id="rfc.section.A.p.11">Changes in draft-07: </p>

<ul>
  <li>Expanded discussion of VAD and Opus DTX.</li>
  <li>Added a security considerations section.</li>
  <li>Rewrote the section on modifying SDP to require implementations to clearly indicate whether any given modification is allowed.</li>
  <li>Clarified impact of IceRestart on CreateOffer in local-offer state.</li>
  <li>Guidance on whether attributes should be defined at the media level or the session level.</li>
  <li>Renamed "default" bundle policy to "balanced".</li>
  <li>Removed default ICE candidate pool size and clarify how it works.</li>
  <li>Defined a canonical order for assignment of MSTs to m= lines.</li>
  <li>Removed discussion of rehydration.</li>
  <li>Added Eric Rescorla as a draft editor.</li>
  <li>Cleaned up references.</li>
  <li>Editorial cleanup</li>
</ul>
<p id="rfc.section.A.p.12">Changes in draft-06: </p>

<ul>
  <li>Reworked handling of m= line recycling.</li>
  <li>Added handling of BUNDLE and bundle-only.</li>
  <li>Clarified handling of rollback.</li>
  <li>Added text describing the ICE Candidate Pool and its behavior.</li>
  <li>Allowed OfferToReceiveX to create multiple recvonly m= sections.  </li>
</ul>
<p id="rfc.section.A.p.13">Changes in draft-05: </p>

<ul>
  <li>Fixed several issues identified in the createOffer/Answer sections during document review.</li>
  <li>Updated references.</li>
</ul>
<p id="rfc.section.A.p.14">Changes in draft-04: </p>

<ul>
  <li>Filled in sections on createOffer and createAnswer.</li>
  <li>Added SDP examples.</li>
  <li>Fixed references.</li>
</ul>
<p id="rfc.section.A.p.15">Changes in draft-03: </p>

<ul>
  <li>Added text describing relationship to W3C specification</li>
</ul>
<p id="rfc.section.A.p.16">Changes in draft-02: </p>

<ul>
  <li>Converted from nroff</li>
  <li>Removed comparisons to old approaches abandoned by the working group</li>
  <li>Removed stuff that has moved to W3C specification</li>
  <li>Align SDP handling with W3C draft</li>
  <li>Clarified section on forking.</li>
</ul>
<p id="rfc.section.A.p.17">Changes in draft-01: </p>

<ul>
  <li>Added diagrams for architecture and state machine.</li>
  <li>Added sections on forking and rehydration.</li>
  <li>Clarified meaning of "pranswer" and "answer".</li>
  <li>Reworked how ICE restarts and media directions are controlled.</li>
  <li>Added list of parameters that can be changed in a description.</li>
  <li>Updated suggested API and examples to match latest thinking.</li>
  <li>Suggested API and examples have been moved to an appendix.</li>
</ul>
<p id="rfc.section.A.p.18">Changes in draft -00: </p>

<ul>
  <li>Migrated from draft-uberti-rtcweb-jsep-02.</li>
</ul>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Justin Uberti</span> 
	  <span class="n hidden">
		<span class="family-name">Uberti</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  <span class="vcardline">747 6th Ave S</span>

	  <span class="vcardline">
		<span class="locality">Kirkland</span>,  
		<span class="region">WA</span> 
		<span class="code">98033</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:justin@uberti.name">justin@uberti.name</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Cullen Jennings</span> 
	  <span class="n hidden">
		<span class="family-name">Jennings</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco</span>
	<span class="adr">
	  <span class="vcardline">170 West Tasman Drive</span>

	  <span class="vcardline">
		<span class="locality">San Jose</span>,  
		<span class="region">CA</span> 
		<span class="code">95134</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:fluffy@iii.ca">fluffy@iii.ca</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Eric Rescorla</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Rescorla</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  <span class="vcardline">331 Evelyn Ave</span>

	  <span class="vcardline">
		<span class="locality">Mountain View</span>,  
		<span class="region">CA</span> 
		<span class="code">94041</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ekr@rtfm.com">ekr@rtfm.com</a></span>

  </address>
</div>

</body>
</html>
