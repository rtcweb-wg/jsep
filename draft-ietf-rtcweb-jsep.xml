<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std"
     docName="draft-uberti-rtcweb-rfc8829bis-01" number="8829" consensus="true"
     ipr="trust200902" obsoletes="8829" updates="" submissionType="IETF"
     xml:lang="en" tocInclude="true" symRefs="true" sortRefs="true"
     tocDepth="4" version="3">
  <!-- xml2rfc v2v3 conversion 2.34.0 -->
  <front>
    <title abbrev="JSEP">JavaScript Session Establishment Protocol (JSEP)</title>
    <seriesInfo name="RFC" value="8829"/>

    <author fullname="Justin Uberti" initials="J." surname="Uberti">
      <organization>Clubhouse</organization>
      <address>
        <email>justin@uberti.name</email>
      </address>
    </author>
    <author fullname="Cullen Jennings" initials="C." surname="Jennings">
      <organization>Cisco</organization>
      <address>
        <postal>
          <street>400 3rd Avenue SW</street>
          <city>Calgary</city>
          <region>AB</region>
          <code>T2P 4H2</code>
          <country>Canada</country>
        </postal>
        <email>fluffy@iii.ca</email>
      </address>
    </author>
    <author fullname="Eric Rescorla" initials="E." surname="Rescorla" role="editor">
      <organization>Mozilla</organization>
      <address>
        <email>ekr@rtfm.com</email>
      </address>
    </author>

    <date day="25" month="Oct" year="2021"/>

    <keyword>webrtc</keyword>
    <keyword>sdp</keyword>
    <keyword>negotiation</keyword>
    <keyword>signaling</keyword>
    <keyword>peerconnection</keyword>
    <keyword>api</keyword>
    <keyword>ice</keyword>
    <keyword>rtp</keyword>
    <keyword>offer</keyword>
    <keyword>answer</keyword>

    <abstract>
      <t>This document describes the mechanisms for allowing a
      JavaScript application to control the signaling plane of a
      multimedia session via the interface specified in the W3C
      RTCPeerConnection API and discusses how this relates to existing
      signaling protocols.</t>
      <t>This specification obsoletes RFC 8829.</t>
    </abstract>
  </front>
  <middle>

    <section anchor="sec.introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>This document describes how the W3C Web Real-Time Communication (WebRTC) RTCPeerConnection
      interface
      <xref target="W3C.webrtc" format="default"/> is used to control the setup,
      management, and teardown of a multimedia session.</t>
      <section anchor="sec.general-design-of-jsep" numbered="true" toc="default">
        <name>General Design of JSEP</name>
        <t>WebRTC call setup has been designed to focus on controlling
        the media plane, leaving signaling-plane behavior up to the
        application as much as possible. The rationale is that
        different applications may prefer to use different protocols,
        such as the existing SIP call signaling protocol, or something
        custom to the particular application, perhaps for a novel use
        case. In this approach, the key information that needs to be
        exchanged is the multimedia session description, which
        specifies the transport and media configuration
        information necessary to establish the media plane.</t>
        <t>With these considerations in mind, this document describes
        the JavaScript Session Establishment Protocol (JSEP), which
        allows for full control of the signaling state machine from
        JavaScript. As described above, JSEP assumes a model in which a
        JavaScript application executes inside a runtime containing
        WebRTC APIs (the "JSEP implementation"). The JSEP
        implementation is almost entirely divorced from the core
        signaling flow, which is instead handled by the JavaScript
        making use of two interfaces: (1) passing in local and remote
        session descriptions and (2) interacting with the Interactive
        Connectivity Establishment (ICE) state
        machine <xref target="RFC8445"/>. The combination of the JSEP implementation and the
        JavaScript application is referred to throughout this document
        as a "JSEP endpoint".</t>
        <t>In this document, the use of JSEP is described as if it
        always occurs between two JSEP endpoints. Note, though, that in many
        cases it will actually be between a JSEP endpoint and some kind
        of server, such as a gateway or Multipoint Control Unit (MCU). This distinction is
        invisible to the JSEP endpoint; it just follows the
        instructions it is given via the API.</t>
        <t>JSEP's handling of session descriptions is simple and
        straightforward. Whenever an offer/answer exchange is needed,
        the initiating side creates an offer by calling a createOffer
        API. The application then uses that offer to set up its local
        configuration via the setLocalDescription API. The offer is finally
        sent off to the remote side over its preferred signaling
        mechanism (e.g., WebSockets); upon receipt of that offer, the
        remote party installs it using the setRemoteDescription
        API.</t>
        <t>To complete the offer/answer exchange, the remote party uses
        the createAnswer API to generate an appropriate answer,
        applies it using the setLocalDescription API, and sends the
        answer back to the initiator over the signaling channel. When
        the initiator gets that answer, it installs it using the
        setRemoteDescription API, and initial setup is complete. This
        process can be repeated for additional offer/answer
        exchanges.</t>
        <t>Regarding ICE
        <xref target="RFC8445" format="default"/>, JSEP decouples the ICE state
        machine from the overall signaling state machine. The ICE
        state machine must remain in the JSEP implementation because
        only the implementation has the necessary knowledge of
        candidates and other transport information. Performing this
        separation provides additional flexibility in protocols that
        decouple session descriptions from transport. For instance, in
        traditional SIP, each offer or answer is self-contained,
        including both the session descriptions and the transport
        information. However,
        <xref target="RFC8840" format="default"/> allows SIP to
        be used with Trickle ICE
        <xref target="RFC8838" format="default"/>, in which the session
        description can be sent immediately and the transport
        information can be sent when available. Sending transport
        information separately can allow for faster ICE and DTLS
        startup, since ICE checks can start as soon as any transport
        information is available rather than waiting for all of it.
        JSEP's decoupling of the ICE and signaling state machines
        allows it to accommodate either model.</t>
        <t>Although it abstracts signaling, the JSEP approach
        requires that the application be aware of the signaling process.
        While the application does not need to understand the contents
        of session descriptions to set up a call, the application must
        call the right APIs at the right times, convert the session
        descriptions and ICE information into the defined messages of
        its chosen signaling protocol, and perform the reverse
        conversion on the messages it receives from the other side.</t>
        <t>One way to make life easier for the application is to
        provide a JavaScript library that hides this complexity from
        the developer; said library would implement a given signaling
        protocol along with its state machine and serialization code,
        presenting a higher-level call-oriented interface to the
        application developer. For example, libraries exist to provide
        implementations of the SIP <xref target="RFC3261"/> and Extensible Messaging
        and Presence Protocol (XMPP) <xref target="RFC6120"/> signaling
        protocols atop the JSEP API.
        Thus, JSEP
        provides greater control for the experienced developer without
        forcing any additional complexity on the novice developer.</t>
      </section>
      <section anchor="sec.other-approaches-consider" numbered="true" toc="default">
        <name>Other Approaches Considered</name>
        <t>One approach that was considered instead of JSEP was to
        include a lightweight signaling protocol. Instead of providing
        session descriptions to the API, the API would produce and
        consume messages from this protocol. While providing a more
        high-level API, this put more control of signaling within the
        JSEP implementation, forcing it to have to understand and
        handle concepts like signaling glare (see
        <xref target="RFC3264" sectionFormat="comma" section="4"/>).</t>
        <t>A second approach that was considered but not chosen was to
        decouple the management of the media control objects from
        session descriptions, instead offering APIs that would control
        each component directly. This was rejected based on the
        argument that requiring exposure of this level of complexity to
        the application programmer would not be beneficial; it would
        (1) result in an API where even a simple example would require a
        significant amount of code to orchestrate all the needed
        interactions and (2) create a large API surface that
        would need to be agreed upon and documented.
        In addition, these API
        points could be called in any order, resulting in a more
        complex set of interactions with the media subsystem than the
        JSEP approach, which specifies how session descriptions are to
        be evaluated and applied.</t>
        <t>One variation on JSEP that was considered was to keep the
        basic session-description-oriented API but to move the
        mechanism for generating offers and answers out of the JSEP
        implementation. Instead of providing createOffer/createAnswer
        methods within the implementation, this approach would instead
        expose a getCapabilities API, which would provide the
        application with the information it needed in order to generate
        its own session descriptions. This increases the amount of work
        that the application needs to do; it needs to know how to
        generate session descriptions from capabilities, and especially
        how to generate the correct answer from an arbitrary offer and
        the supported capabilities. While this could certainly be
        addressed by using a library like the one mentioned above, it
        basically forces the use of said library even for a simple
        example. Providing createOffer/createAnswer avoids this
        problem.</t>
      </section>
      <section>
        <name>Changes from RFC 8829</name>
        <t>
          When <xref target="RFC8829"/> was published, inconsistencies regarding BUNDLE
          <xref target="RFC8843"/> operation were identified with regard to
          both the specification text as well as implementation behavior. The
          former concern was addressed via an update to BUNDLE, see <xref target="RFC9143"/>.
          For the latter concern, it was observed that some implementations 
          implemented the "max-bundle" bundle policy defined in <xref target="RFC8829"/>
          by assuming that bundling had already been negotiated, rather than marking "m=" sections
          as bundle-only as indicated by the BUNDLE specification.
          In order to prevent unexpected changes to applications relying
          on the pre-standard behavior, the decision
          was made to deprecate "max-bundle" and instead
          introduce an identically defined "must-bundle" policy that, when selected,
          provides the behavior originally specified by <xref target="RFC8829"/>.
        </t>
      </section>
    </section>
    <section anchor="sec.terminology" numbered="true" toc="default">
      <name>Terminology</name>
    <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>",
    "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>",
    "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
    to be interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/>
    <xref target="RFC8174"/> when, and only when, they appear in all capitals,
    as shown here.</t>
    </section>
    <section anchor="sec.semantics-and-syntax" numbered="true" toc="default">
      <name>Semantics and Syntax</name>
      <section anchor="sec.signaling-model" numbered="true" toc="default">
        <name>Signaling Model</name>
        <t>JSEP does not specify a particular signaling model or state
        machine, other than the generic need to exchange session
        descriptions in the fashion described by
        <xref target="RFC3264" format="default"/> (offer/answer) in order for both
        sides of the session to know how to conduct the session. JSEP
        provides mechanisms to create offers and answers, as well as to
        apply them to a session. However, the JSEP implementation is
        totally decoupled from the actual mechanism by which these
        offers and answers are communicated to the remote side,
        including addressing, retransmission, forking, and glare
        handling. These issues are left entirely up to the application;
        the application has complete control over which offers and
        answers get handed to the implementation, and when.</t>
        <figure anchor="fig-sigModel">
          <name>JSEP Signaling Model</name>
          <artwork name="" type="ascii-art" align="left" alt=""><![CDATA[
      +-----------+                               +-----------+
      |  Web App  |<--- App-Specific Signaling -->|  Web App  |
      +-----------+                               +-----------+
            ^                                            ^
            |  SDP                                       |  SDP
            V                                            V
      +-----------+                                +-----------+
      |   JSEP    |<----------- Media ------------>|   JSEP    |
      |   Impl.   |                                |   Impl.   |
      +-----------+                                +-----------+ ]]></artwork>
        </figure>
      </section>
      <section anchor="sec.session-descriptions-and-state-machine" numbered="true" toc="default">
        <name>Session Descriptions and State Machine</name>
        <t>In order to establish the media plane, the JSEP
        implementation needs specific parameters to indicate what to
        transmit to the remote side, as well as how to handle the media
        that is received. These parameters are determined by the
        exchange of session descriptions in offers and answers, and
        there are certain details to this process that must be handled
        in the JSEP APIs.</t>
        <t>Whether a session description applies to the local side or
        the remote side affects the meaning of that description. For
        example, the list of codecs sent to a remote party indicates
        what the local side is willing to receive, which, when
        intersected with the set of codecs the remote side supports,
        specifies what the remote side should send. However, not all
        parameters follow this rule; some parameters are declarative,
        and the remote side must either accept them or reject them
        altogether. An example of such a parameter is the TLS
        fingerprints <xref target="RFC8122" format="default"/>
        as used in the context of DTLS <xref target="RFC6347" format="default"/>;
        these fingerprints are calculated based on
        the local certificate(s) offered and are not subject to
        negotiation.
        </t>
        <t>In addition, various RFCs put different conditions on the
        format of offers versus answers. For example, an offer may
        propose an arbitrary number of "m=" sections (i.e., media
        descriptions as described in
        <xref target="RFC4566" sectionFormat="comma" section="5.14"/>), but an answer must
        contain the exact same number as the offer.</t>
        <t>Lastly, while the exact media parameters are known only
        after an offer and an answer have been exchanged, the offerer
        may receive ICE checks, and possibly media (e.g., in the case
        of a re-offer after a connection has been established) before
        it receives an answer. To properly process incoming media in
        this case, the offerer's media handler must be aware of the
        details of the offer before the answer arrives.</t>
        <t>Therefore, in order to handle session descriptions properly,
        the JSEP implementation needs:
        </t>
        <ol spacing="normal" type="1">
          <li>To know if a session description pertains to the local or
          remote side.</li>
          <li>To know if a session description is an offer or an
          answer.</li>
          <li>To allow the offer to be specified independently of the
          answer.</li>
        </ol>
        <t>JSEP addresses this by adding both setLocalDescription
        and setRemoteDescription methods and having session description
        objects contain a type field indicating the type of session
        description being supplied. This satisfies the requirements
        listed above for both the offerer, who first calls
        setLocalDescription(sdp [offer]) and then later
        setRemoteDescription(sdp [answer]), and the
        answerer, who first calls setRemoteDescription(sdp [offer]) and
        then later setLocalDescription(sdp [answer]).</t>
        <t>During the offer/answer exchange, the outstanding offer is
        considered to be "pending" at the offerer and the answerer, as
        it may be either accepted or rejected. If this is a re-offer,
        each side will also have "current" local and remote
        descriptions, which reflect the result of the last offer/answer
        exchange. Sections
        <xref target="sec.pendinglocaldescription" format="counter"/>,
        <xref target="sec.pendingremotedescription" format="counter"/>,
        <xref target="sec.currentlocaldescription" format="counter"/>, and
        <xref target="sec.currentremotedescription" format="counter"/> provide more
        detail on pending and current descriptions.</t>
        <t>JSEP also allows for an answer to be treated as provisional
        by the application. Provisional answers provide a way for an
        answerer to communicate initial session parameters back to the
        offerer, in order to allow the session to begin, while allowing
        a final answer to be specified later. This concept of a final
        answer is important to the offer/answer model; when such an
        answer is received, any extra resources allocated by the caller
        can be released, now that the exact session configuration is
        known. These "resources" can include things like extra ICE
        components, Traversal Using Relays around NAT (TURN) candidates, or video decoders. Provisional
        answers, on the other hand, do no such deallocation; as a
        result, multiple dissimilar provisional answers, with their own
        codec choices, transport parameters, etc., can be received and
        applied during call setup. Note that the final answer itself
        may be different than any received provisional answers.</t>
        <t>In
        <xref target="RFC3264" format="default"/>, the constraint at the signaling
        level is that only one offer can be outstanding for a given
        session, but at the JSEP level, a new offer can be
        generated at any point. For example, when using SIP for
        signaling, if one offer is sent and is then canceled using a SIP
        CANCEL, another offer can be generated even though no answer
        was received for the first offer. To support this, the JSEP
        media layer can provide an offer via the createOffer method
        whenever the JavaScript application needs one for the
        signaling. The answerer can send back zero or more provisional
        answers and then finally end the offer/answer exchange by sending a
        final answer. The state machine for this is as follows:</t>
        <figure anchor="fig-state-machine">
          <name>JSEP State Machine</name>
          <artwork name="" type="ascii-art" align="left" alt=""><![CDATA[
                    setRemote(OFFER)               setLocal(PRANSWER)
                        /-----\                               /-----\
                        |     |                               |     |
                        v     |                               v     |
         +---------------+    |                +---------------+    |
         |               |----/                |               |----/
         |  have-        | setLocal(PRANSWER)  | have-         |
         |  remote-offer |------------------- >| local-pranswer|
         |               |                     |               |
         |               |                     |               |
         +---------------+                     +---------------+
              ^   |                                   |
              |   | setLocal(ANSWER)                  |
setRemote(OFFER)  |                                   |
              |   V                  setLocal(ANSWER) |
         +---------------+                            |
         |               |                            |
         |               |<---------------------------+
         |    stable     |
         |               |<---------------------------+
         |               |                            |
         +---------------+          setRemote(ANSWER) |
              ^   |                                   |
              |   | setLocal(OFFER)                   |
setRemote(ANSWER) |                                   |
              |   V                                   |
         +---------------+                     +---------------+
         |               |                     |               |
         |  have-        | setRemote(PRANSWER) |have-          |
         |  local-offer  |------------------- >|remote-pranswer|
         |               |                     |               |
         |               |----\                |               |----\
         +---------------+    |                +---------------+    |
                        ^     |                               ^     |
                        |     |                               |     |
                        \-----/                               \-----/
                    setLocal(OFFER)               setRemote(PRANSWER) ]]></artwork>
        </figure>
        <t>Aside from these state transitions, there is no other
        difference between the handling of provisional ("pranswer") and
        final ("answer") answers.</t>
      </section>
      <section anchor="sec.session-description-forma" numbered="true" toc="default">
        <name>Session Description Format</name>
        <t>JSEP's session descriptions use Session Description Protocol (SDP) syntax for their
        internal representation. While this format is not optimal for
        manipulation from JavaScript, it is widely accepted and is
        frequently updated with new features; any alternate encoding of
        session descriptions would have to keep pace with the changes
        to SDP, at least until the time that this new encoding eclipsed
        SDP in popularity.</t>
        <t>However, to provide for future flexibility, the SDP syntax
        is encapsulated within a SessionDescription object, which can
        be constructed from SDP and be serialized out to SDP. If
        future specifications agree on a JSON format for session
        descriptions, we could easily enable this object to generate
        and consume that JSON.</t>
        <t>As detailed below, most applications should be able to treat
        the SessionDescriptions produced and consumed by these various
        API calls as opaque blobs; that is, the application will not
        need to read or change them.</t>
      </section>
      <section anchor="sec.session-description-ctrl" numbered="true" toc="default">
        <name>Session Description Control</name>
        <t>In order to give the application control over various common
        session parameters, JSEP provides control surfaces that tell
        the JSEP implementation how to generate session descriptions.
        This avoids the need for JavaScript to modify session
        descriptions in most cases.</t>
        <t>Changes to these objects result in changes to the session
        descriptions generated by subsequent createOffer/createAnswer
        calls.</t>
        <section anchor="sec.rtptransceivers" numbered="true" toc="default">
          <name>RtpTransceivers</name>
          <t>RtpTransceivers allow the application to control the RTP
          media associated with one "m=" section. Each RtpTransceiver has
          an RtpSender and an RtpReceiver, which an application can use
          to control the sending and receiving of RTP media. The
          application may also modify the RtpTransceiver directly, for
          instance, by stopping it.</t>
          <t>RtpTransceivers generally have a 1:1 mapping with "m="
          sections, although there may be more RtpTransceivers than "m="
          sections when RtpTransceivers are created but not yet
          associated with an "m=" section, or if RtpTransceivers have been
          stopped and disassociated from "m=" sections. An RtpTransceiver
          is said to be associated with an "m=" section if its
          media identification (mid) property is non-null; otherwise, it is said to be
          disassociated. The associated "m=" section is determined using
          a mapping between transceivers and "m=" section indices, formed
          when creating an offer or applying a remote offer.</t>
          <t>An RtpTransceiver is never associated with more than one
          "m=" section, and once a session description is applied, an "m="
          section is always associated with exactly one RtpTransceiver.
          However, in certain cases where an "m=" section has been
          rejected, as discussed in
          <xref target="sec.subsequent-offers" format="default"/> below, that "m=" section
          will be "recycled" and associated with a new RtpTransceiver
          with a new MID value.</t>
          <t>RtpTransceivers can be created explicitly by the
          application or implicitly by calling setRemoteDescription
          with an offer that adds new "m=" sections.</t>
        </section>
        <section anchor="sec.rtpsenders" numbered="true" toc="default">
          <name>RtpSenders</name>
          <t>RtpSenders allow the application to control how RTP media
          is sent. An RtpSender is conceptually responsible for the
          outgoing RTP stream(s) described by an "m=" section. This
          includes encoding the attached MediaStreamTrack, sending RTP
          media packets, and generating/processing the RTP Control Protocol (RTCP) for the
          outgoing RTP streams(s).</t>
        </section>
        <section anchor="sec.rtpreceivers" numbered="true" toc="default">
          <name>RtpReceivers</name>
          <t>RtpReceivers allow the application to inspect how RTP
          media is received. An RtpReceiver is conceptually responsible
          for the incoming RTP stream(s) described by an "m=" section.
          This includes processing received RTP media packets, decoding
          the incoming stream(s) to produce a remote MediaStreamTrack,
          and generating/processing RTCP for the incoming RTP
          stream(s).</t>
        </section>
      </section>
      <section anchor="sec.ice" numbered="true" toc="default">
        <name>ICE</name>
        <section anchor="sec.ice-gather-overview" numbered="true" toc="default">
          <name>ICE Gathering Overview</name>
          <t>JSEP gathers ICE candidates as needed by the application.
          Collection of ICE candidates is referred to as a gathering
          phase, and this is triggered either by the addition of a new
          or recycled "m=" section to the local session description or by
          new ICE credentials in the description, indicating an ICE
          restart. Use of new ICE credentials can be triggered
          explicitly by the application or implicitly by the JSEP
          implementation in response to changes in the ICE
          configuration.</t>
          <t>When the ICE configuration changes in a way that requires
          a new gathering phase, a 'needs-ice-restart' bit is set. When
          this bit is set, calls to the createOffer API will generate
          new ICE credentials. This bit is cleared by a call to the
          setLocalDescription API with new ICE credentials from either
          an offer or an answer, i.e., from either a locally or
          remotely initiated ICE restart.</t>
          <t>When a new gathering phase starts, the ICE agent will
          notify the application that gathering is occurring through a state
          change event. Then, when each new ICE candidate becomes available,
          the ICE agent will supply it to the application via an
          onicecandidate event; these candidates will also automatically be
          added to the current and/or pending local session
          description. Finally, when all candidates have been gathered,
          a final onicecandidate event will be dispatched to signal that the
          gathering process is complete.</t>
          <t>Note that gathering phases only gather the candidates
          needed by new/recycled/restarting "m=" sections; other "m="
          sections continue to use their existing candidates. Also, if
          an "m=" section is bundled (either by a successful bundle
          negotiation or by being marked as bundle-only), then
          candidates will be gathered and exchanged for that "m=" section
          if and only if its MID item is a BUNDLE-tag, as described in
          <xref target="RFC8843" format="default"/>.</t>
        </section>
        <section anchor="sec.ice-candidate-trickling" numbered="true" toc="default">
          <name>ICE Candidate Trickling</name>
          <t>Candidate trickling is a technique through which a caller
          may incrementally provide candidates to the callee after the
          initial offer has been dispatched; the semantics of "Trickle
          ICE" are defined in
          <xref target="RFC8838" format="default"/>. This process
          allows the callee to begin acting upon the call and setting
          up the ICE (and perhaps DTLS) connections immediately,
          without having to wait for the caller to gather all possible
          candidates. This results in faster media setup in cases where
          gathering is not performed prior to initiating the call.</t>
          <t>JSEP supports optional candidate trickling by providing
          APIs, as described above, that provide control and feedback
          on the ICE candidate gathering process. Applications that
          support candidate trickling can send the initial offer
          immediately and send individual candidates when they get
          notified of a new candidate; applications that do not support
          this feature can simply wait for the indication that
          gathering is complete, and then create and send their offer,
          with all the candidates, at that time.</t>
          <t>Upon receipt of trickled candidates, the receiving
          application will supply them to its ICE agent. This triggers
          the ICE agent to start using the new remote candidates for
          connectivity checks.</t>
          <section anchor="sec.ice-candidate-format" numbered="true" toc="default">
            <name>ICE Candidate Format</name>
            <t>In JSEP, ICE candidates are abstracted by an
            IceCandidate object, and as with session descriptions, SDP
            syntax is used for the internal representation.</t>
            <t>The candidate details are specified in an IceCandidate
            field, using the same SDP syntax as the
            "candidate-attribute" field defined in
            <xref target="RFC8839" sectionFormat="comma" section="5.1"/>. Note that this
            field does not contain an "a=" prefix, as indicated in the
            following example:</t>

            <sourcecode name="" type="sdp"><![CDATA[
candidate:1 1 UDP 1694498815 192.0.2.33 10000 typ host ]]></sourcecode>
            <t>The IceCandidate object contains a field to indicate
            which ICE username fragment (ufrag) it is associated with, as defined in
            <xref target="RFC8839" sectionFormat="comma" section="5.4"/>. This value is used
            to determine which session description (and thereby which
            gathering phase) this IceCandidate belongs to, which helps
            resolve ambiguities during ICE restarts. If this field is
            absent in a received IceCandidate (perhaps when
            communicating with a non-JSEP endpoint), the most recently
            received session description is assumed.</t>
            <t>The IceCandidate object also contains fields to indicate
            which "m=" section it is associated with, which can be
            identified in one of two ways: either by an "m=" section
            index or by a MID. The "m=" section index is a zero-based
            index, with index N referring to the N+1th "m=" section in
            the session description referenced by this IceCandidate.
            The MID is a "media stream identification" value, as
            defined in
            <xref target="RFC5888" sectionFormat="comma" section="4"/>, which provides a
            more robust way to identify the "m=" section in the session
            description, using the MID of the associated RtpTransceiver
            object (which may have been locally generated by the
            answerer when interacting with a non-JSEP endpoint that
            does not support the MID attribute, as discussed in
            <xref target="sec.applying-a-remote-desc" format="default"/> below). If the
            MID field is present in a received IceCandidate, it <bcp14>MUST</bcp14> be
            used for identification; otherwise, the "m=" section index is
            used instead.</t>
            <t>Implementations <bcp14>MUST</bcp14>
            be prepared to receive objects with some fields missing, as
            mentioned above.</t>
          </section>
        </section>
        <section anchor="sec.ice-candidate-policy" numbered="true" toc="default">
          <name>ICE Candidate Policy</name>
          <t>Typically, when gathering ICE candidates, the JSEP
          implementation will gather all possible forms of initial
          candidates -- host, server-reflexive, and relay.
          However, in
          certain cases, applications may want to have more specific
          control over the gathering process, due to privacy or related
          concerns. For example, one may want to only use relay
          candidates, to leak as little location information as
          possible (keeping in mind that this choice comes with
          corresponding operational costs). To accomplish this, JSEP
          allows the application to restrict which ICE candidates are
          used in a session. Note that this filtering is applied on top
          of any restrictions the implementation chooses to enforce
          regarding which IP addresses are permitted for the
          application, as discussed in
          <xref target="RFC8828" format="default"/>.</t>
          <t>There may also be cases where the application wants to
          change which types of candidates are used while the session
          is active. A prime example is where a callee may initially
          want to use only relay candidates, to avoid leaking location
          information to an arbitrary caller, but then change to use
          all candidates (for lower operational cost) once the user has
          indicated that they want to take the call. For this scenario, the
          JSEP implementation <bcp14>MUST</bcp14> allow the candidate policy to be
          changed in mid-session, subject to the aforementioned
          interactions with local policy.</t>
          <t>To administer the ICE candidate policy, the JSEP
          implementation will determine the current setting at the
          start of each gathering phase. Then, during the gathering
          phase, the implementation <bcp14>MUST NOT</bcp14> expose candidates
          disallowed by the current policy to the application, use them
          as the source of connectivity checks, or indirectly expose
          them via other fields, such as the raddr/rport attributes for
          other ICE candidates. Later, if a different policy is
          specified by the application, the application can apply it by
          kicking off a new gathering phase via an ICE restart.</t>
        </section>
        <section anchor="sec.ice-candidate-pool" numbered="true" toc="default">
          <name>ICE Candidate Pool</name>
          <t>JSEP applications typically inform the JSEP implementation
          to begin ICE gathering via the information supplied to
          setLocalDescription, as the local description indicates the
          number of ICE components that will be needed and for which
          candidates must be gathered. However, to accelerate cases
          where the application knows the number of ICE components to
          use ahead of time, it may ask the implementation to gather a
          pool of potential ICE candidates to help ensure rapid media
          setup.</t>
          <t>When setLocalDescription is eventually called and the
          JSEP implementation prepares to gather the needed ICE candidates,
          it <bcp14>SHOULD</bcp14> start by checking if any candidates are available
          in the pool. If there are candidates in the pool, they <bcp14>SHOULD</bcp14>
          be handed to the application immediately via the ICE
          candidate event. If the pool becomes depleted, either because
          a larger-than-expected number of ICE components are used or
          because the pool has not had enough time to gather
          candidates, the remaining candidates are gathered as usual.
          This only occurs for the first offer/answer exchange, after
          which the candidate pool is emptied and no longer used.</t>
          <t>One example of where this concept is useful is an
          application that expects an incoming call at some point in
          the future, and wants to minimize the time it takes to
          establish connectivity, to avoid clipping of initial media.
          By pre-gathering candidates into the pool, it can exchange
          and start sending connectivity checks from these candidates
          almost immediately upon receipt of a call. Note, though, that
          by holding on to these pre-gathered candidates, which will be
          kept alive as long as they may be needed, the application
          will consume resources on the STUN/TURN servers it is
          using. ("STUN" stands for "Session Traversal Utilities for NAT".)</t>
        </section>
        <section numbered="true" toc="default">
          <name>ICE Versions</name>
          <t>While this specification formally relies on <xref target="RFC8445" format="default"/>, at the time of its publication, the
          majority of WebRTC implementations support the version
          of ICE described in <xref target="RFC5245" format="default"/>. The "ice2" attribute defined in <xref target="RFC8445" format="default"/>
          can be used to detect the version in use by a remote endpoint
          and to provide a smooth transition from the older specification
          to the newer one.  Implementations <bcp14>MUST</bcp14> be able to accept remote
          descriptions that do not have the "ice2" attribute.</t>
        </section>
      </section>
      <section anchor="sec.imageattr" numbered="true" toc="default">
        <name>Video Size Negotiation</name>
        <t>Video size negotiation is the process through which a
        receiver can use the "a=imageattr" SDP attribute
        <xref target="RFC6236" format="default"/> to indicate what video frame sizes it
        is capable of receiving. A receiver may have hard limits on
        what its video decoder can process, or it may have some maximum
        set by policy. By specifying these limits in an "a=imageattr"
        attribute, JSEP endpoints can attempt to ensure that the remote
        sender transmits video at an acceptable resolution. However,
        when communicating with a non-JSEP endpoint that does not
        understand this attribute, any signaled limits may be exceeded,
        and the JSEP implementation <bcp14>MUST</bcp14> handle this gracefully, e.g.,
        by discarding the video.</t>
        <t>Note that certain codecs support transmission of samples
        with aspect ratios other than 1.0 (i.e., non-square pixels).
        JSEP implementations will not transmit non-square pixels but
        <bcp14>SHOULD</bcp14> receive and render such video with the correct aspect
        ratio. However, sample aspect ratio has no impact on the size
        negotiation described below; all dimensions are measured in
        pixels, whether square or not.</t>
        <section anchor="sec.creating-imageattr" numbered="true" toc="default">
          <name>Creating an imageattr Attribute</name>
          <t>The receiver will first combine any known local limits
          (e.g., hardware decoder capabilities or local policy) to
          determine the absolute minimum and maximum sizes it can
          receive. If there are no known local limits, the
          "a=imageattr" attribute <bcp14>SHOULD</bcp14> be omitted. If these local
          limits preclude receiving any video, i.e., the degenerate
          case of no permitted resolutions, the "a=imageattr" attribute
          <bcp14>MUST</bcp14> be omitted, and the "m=" section <bcp14>MUST</bcp14> be marked as
          sendonly/inactive, as appropriate.</t>
          <t>Otherwise, an "a=imageattr" attribute is created with a
          "recv" direction, and the resulting resolution space formed
          from the aforementioned intersection is used to specify its
          minimum and maximum "x=" and "y=" values.</t>
          <t>The rules here express a single set of preferences, and
          therefore, the "a=imageattr" "q=" value is not important. It
          <bcp14>SHOULD</bcp14> be set to "1.0".</t>
          <t>The "a=imageattr" field is payload type specific. When all
          video codecs supported have the same capabilities, use of a
          single attribute, with the wildcard payload type (*), is
          <bcp14>RECOMMENDED</bcp14>. However, when the supported video codecs have
          different limitations, specific "a=imageattr" attributes <bcp14>MUST</bcp14>
          be inserted for each payload type.</t>
          <t>As an example, consider a system with a multiformat video
          decoder, which is capable of decoding any resolution from
          48x48 to 720p. In this case, the implementation would
          generate this attribute:</t>
          <t>a=imageattr:* recv [x=[48:1280],y=[48:720],q=1.0]</t>
          <t>This declaration indicates that the receiver is capable of
          decoding any image resolution from 48x48 up to 1280x720
          pixels.</t>
        </section>
        <section anchor="sec.interpreting-imageattr" numbered="true" toc="default">
          <name>Interpreting imageattr Attributes</name>
          <t>
          <xref target="RFC6236" format="default"/> defines "a=imageattr" to be an
          advisory field. This means that it does not absolutely
          constrain the video formats that the sender can use but
          gives an indication of the preferred values.</t>
          <t>This specification prescribes behavior that is more specific. When
          a MediaStreamTrack, which is producing video of a certain
          resolution (the "track resolution"), is attached to an
          RtpSender, which is encoding the track video at the same or
          lower resolution(s) (the "encoder resolutions"), and a remote
          description is applied that references the sender and
          contains valid "a=imageattr recv" attributes, it <bcp14>MUST</bcp14> follow
          the rules below to ensure that the sender does not transmit a
          resolution that would exceed the size criteria specified in
          the attributes. These rules <bcp14>MUST</bcp14> be followed as long as the
          attributes remain present in the remote description,
          including cases in which the track changes its resolution or
          is replaced with a different track.</t>
          <t>Depending on how the RtpSender is configured, it may be
          producing a single encoding at a certain resolution or, if
          simulcast
          (<xref target="sec.simulcast" format="default"/>) has been negotiated, multiple
          encodings, each at their own specific resolution. In
          addition, depending on the configuration, each encoding may
          have the flexibility to reduce resolution when needed or may
          be locked to a specific output resolution.</t>
          <t>For each encoding being produced by the RtpSender, the set
          of "a=imageattr recv" attributes in the corresponding "m="
          section of the remote description is processed to determine
          what should be transmitted. Only attributes that reference
          the media format selected for the encoding are considered;
          each such attribute is evaluated individually, starting with
          the attribute with the highest "q=" value. If multiple
          attributes have the same "q=" value, they are evaluated in
          the order they appear in their containing "m=" section. Note
          that while JSEP endpoints will include at most one
          "a=imageattr recv" attribute per media format, JSEP endpoints
          may receive session descriptions from non-JSEP endpoints with
          "m=" sections that contain multiple such attributes.</t>
          <t>For each "a=imageattr recv" attribute, the following rules
          are applied. If this processing is successful, the encoding
          is transmitted accordingly, and no further attributes are
          considered for that encoding. Otherwise, the next attribute
          is evaluated, in the aforementioned order. If none of the
          supplied attributes can be processed successfully, the
          encoding <bcp14>MUST NOT</bcp14> be transmitted, and an error <bcp14>SHOULD</bcp14> be
          raised to the application.
          </t>
          <ul spacing="normal">
            <li>The limits from the attribute are compared to the
            encoder resolution. Only the specific limits mentioned
            below are considered; any other values, such as picture
            aspect ratio, <bcp14>MUST</bcp14> be ignored. When considering a
            MediaStreamTrack that is producing rotated video, the
            unrotated resolution <bcp14>MUST</bcp14> be used for the checks. This is
            required regardless of whether the receiver supports
            performing receive-side rotation (e.g., through Coordination of
            Video Orientation (CVO)
            <xref target="TS26.114" format="default"/>), as it significantly simplifies
            the matching logic.</li>
            <li>If the attribute includes a "sar=" (sample aspect ratio)
            value set to something other than "1.0", indicating that the
            receiver wants to receive non-square pixels, this cannot be
            satisfied and the attribute <bcp14>MUST NOT</bcp14> be used.</li>
            <li>If the encoder resolution exceeds the maximum size
            permitted by the attribute and the encoder is allowed to
            adjust its resolution, the encoder <bcp14>SHOULD</bcp14> apply downscaling
            in order to satisfy the limits. Downscaling <bcp14>MUST NOT</bcp14> change
            the picture aspect ratio of the encoding, ignoring any
            trivial differences due to rounding. For example, if the
            encoder resolution is 1280x720 and the attribute specified
            a maximum of 640x480, the expected output resolution would
            be 640x360. If downscaling cannot be applied, the attribute
            <bcp14>MUST NOT</bcp14> be used.</li>
            <li>If the encoder resolution is less than the minimum size
            permitted by the attribute, the attribute <bcp14>MUST NOT</bcp14> be used;
            the encoder <bcp14>MUST NOT</bcp14> apply upscaling. JSEP implementations
            <bcp14>SHOULD</bcp14> avoid this situation by allowing receipt of
            arbitrarily small resolutions, perhaps via fallback to a
            software decoder.</li>
            <li>If the encoder resolution is within the maximum and
            minimum sizes, no action is needed.</li>
          </ul>
        </section>
      </section>
      <section anchor="sec.simulcast" numbered="true" toc="default">
        <name>Simulcast</name>
        <t>JSEP supports simulcast transmission of a MediaStreamTrack,
        where multiple encodings of the source media can be transmitted
        within the context of a single "m=" section. The current JSEP API
        is designed to allow applications to send simulcasted media but
        only to receive a single encoding. This allows for multi-user
        scenarios where each sending client sends multiple encodings to
        a server, which then, for each receiving client, chooses the
        appropriate encoding to forward.</t>
        <t>Applications request support for simulcast by configuring
        multiple encodings on an RtpSender. Upon generation of an offer
        or answer, these encodings are indicated via SDP markings on
        the corresponding "m=" section, as described below. Receivers
        that understand simulcast and are willing to receive it will
        also include SDP markings to indicate their support, and JSEP
        endpoints will use these markings to determine whether
        simulcast is permitted for a given RtpSender. If simulcast
        support is not negotiated, the RtpSender will only use the
        first configured encoding.</t>
        <t>Note that the exact simulcast parameters are up to the
        sending application. While the aforementioned SDP markings are
        provided to ensure that the remote side can receive and demux
        multiple simulcast encodings, the specific resolutions and
        bitrates to be used for each encoding are purely a send-side
        decision in JSEP.</t>
        <t>JSEP currently does not provide a mechanism to configure
        receipt of simulcast. This means that if simulcast is offered
        by the remote endpoint, the answer generated by a JSEP endpoint
        will not indicate support for receipt of simulcast, and as such
        the remote endpoint will only send a single encoding per "m="
        section.</t>
        <t>In addition, JSEP does not provide a mechanism to handle an
        incoming offer requesting simulcast from the JSEP endpoint.
        This means that setting up simulcast in the case where the JSEP
        endpoint receives the initial offer requires out-of-band
        signaling or SDP inspection. However, in the case where the
        JSEP endpoint sets up simulcast in its initial offer, any
        established simulcast streams will continue to work upon
        receipt of an incoming re-offer. Future versions of this
        specification may add additional APIs to handle the incoming
        initial offer scenario.</t>
        <t>When using JSEP to transmit multiple encodings from an
        RtpSender, the techniques from
        <xref target="RFC8853" format="default"/> and
        <xref target="RFC8851" format="default"/> are used. Specifically,
        when multiple encodings have been configured for an RtpSender,
        the "m=" section for the RtpSender will include an "a=simulcast"
        attribute, as defined in
        <xref target="RFC8853" sectionFormat="comma" section="5.1"/>,
        with a "send" simulcast stream description that lists each
        desired encoding, and no "recv" simulcast stream description.
        The "m=" section will also include an "a=rid" attribute for each
        encoding, as specified in
        <xref target="RFC8851" sectionFormat="comma" section="4"/>; the use of
        Restriction Identifiers (RIDs, also called rid-ids or RtpStreamIds)
        allows the individual encodings to be
        disambiguated even though they are all part of the same "m="
        section.</t>
      </section>
      <section anchor="sec.interactions-with-forking" numbered="true" toc="default">
        <name>Interactions with Forking</name>
        <t>Some call signaling systems allow various types of forking
        where an SDP Offer may be provided to more than one device. For
        example, SIP
        <xref target="RFC3261" format="default"/> defines both a "parallel search"
        and "sequential search". Although these are primarily signaling-level issues that are outside the scope of JSEP, they do have
        some impact on the configuration of the media plane that is
        relevant. When forking happens at the signaling layer, the
        JavaScript application responsible for the signaling needs to
        make the decisions about what media should be sent or received
        at any point in time, as well as which remote endpoint it
        should communicate with; JSEP is used to make sure the media
        engine can make the RTP and media perform as required by the
        application. The basic operations that the applications can
        have the media engine do are as follows:
        </t>
        <ul spacing="normal">
          <li>Start exchanging media with a given remote peer, but keep
          all the resources reserved in the offer.</li>
          <li>Start exchanging media with a given remote peer, and free
          any resources in the offer that are not being used.</li>
        </ul>
        <section anchor="sec.sequential-forking" numbered="true" toc="default">
          <name>Sequential Forking</name>
          <t>Sequential forking involves a call being dispatched to
          multiple remote callees, where each callee can accept the
          call, but only one active session ever exists at a time; no
          mixing of received media is performed.</t>
          <t>JSEP handles sequential forking well, allowing the
          application to easily control the policy for selecting the
          desired remote endpoint. When an answer arrives from one of
          the callees, the application can choose to apply it as either
          (1)&nbsp;a provisional answer, leaving open the possibility of using a
          different answer in the future or (2)&nbsp;a final
          answer, ending the setup flow.</t>
          <t>In a "first-one-wins" situation, the first answer will be
          applied as a final answer, and the application will reject
          any subsequent answers. In SIP parlance, this would be ACK +
          BYE.</t>
          <t>In a "last-one-wins" situation, all answers would be
          applied as provisional answers, and any previous call leg
          will be terminated. At some point, the application will end
          the setup process, perhaps with a timer; at this point, the
          application could reapply the pending remote description as a
          final answer.</t>
        </section>
        <section anchor="sec.parallel-forking" numbered="true" toc="default">
          <name>Parallel Forking</name>
          <t>Parallel forking involves a call being dispatched to
          multiple remote callees, where each callee can accept the
          call and multiple simultaneous active signaling sessions can
          be established as a result. If multiple callees send media at
          the same time, the possibilities for handling this are
          described in
          <xref target="RFC3960" sectionFormat="comma" section="3.1"/>. Most SIP devices
          today only support exchanging media with a single device at a
          time and do not try to mix multiple early media audio
          sources, as that could result in a confusing situation. For
          example, consider having a European ringback tone mixed
          together with the North American ringback tone -- the
          resulting sound would not be like either tone and would
          confuse the user. If the signaling application wishes to only
          exchange media with one of the remote endpoints at a time,
          then from a media engine point of view, this is exactly like
          the sequential forking case.</t>
          <t>In the parallel forking case where the JavaScript
          application wishes to simultaneously exchange media with
          multiple peers, the flow is slightly more complex, but the
          JavaScript application can follow the strategy that
          <xref target="RFC3960" format="default"/> describes, using UPDATE. The
          UPDATE approach allows the signaling to set up a separate
          media flow for each peer that it wishes to exchange media
          with. In JSEP, this offer used in the UPDATE would be formed
          by simply creating a new PeerConnection (see
          <xref target="sec.peerconnection" format="default"/>) and making sure that
          the same local media streams have been added into this new
          PeerConnection. Then the new PeerConnection object would
          produce an SDP offer that could be used by the signaling to
          perform the UPDATE strategy discussed in
          <xref target="RFC3960" format="default"/>.</t>
          <t>As a result of sharing the media streams, the application
          will end up with N parallel PeerConnection sessions, each
          with a local and remote description and their own local and
          remote addresses. The media flow from these sessions can be
          managed using setDirection (see
          <xref target="sec.transceiver-set-direction" format="default"/>), or the
          application can choose to play out the media from all
          sessions mixed together. Of course, if the application wants
          to only keep a single session, it can simply terminate the
          sessions that it no longer needs.</t>
        </section>
      </section>
    </section>
    <section anchor="sec.interface" numbered="true" toc="default">
      <name>Interface</name>
      <t>This section details the basic operations that must be present
      to implement JSEP functionality. The actual API exposed in the
      W3C API may have somewhat different syntax but should map easily
      to these concepts.
      </t>
      <section anchor="sec.peerconnection" numbered="true" toc="default">
        <name>PeerConnection</name>
        <section anchor="sec.pc-constructor" numbered="true" toc="default">
          <name>Constructor</name>
          <t>The PeerConnection constructor allows the application to
          specify global parameters for the media session, such as the
          STUN/TURN servers and credentials to use when gathering
          candidates, as well as the initial ICE candidate policy and
          pool size, and also the bundle policy to use.</t>
          <t>If an ICE candidate policy is specified, it functions as
          described in
          <xref target="sec.ice-candidate-policy" format="default"/>, causing the JSEP
          implementation to only surface the permitted candidates
          (including any implementation-internal filtering) to the
          application and only use those candidates for connectivity
          checks. The set of available policies is as follows:
          </t>
          <dl newline="false" spacing="normal">
            <dt>all:</dt>
            <dd>All candidates permitted by
            implementation policy will be gathered and used.</dd>
            <dt>relay:</dt>
            <dd>All candidates except relay candidates
            will be filtered out. This obfuscates the location
            information that might be ascertained by the remote peer
            from the received candidates. Depending on how the
            application deploys and chooses relay servers, this could
            obfuscate location to a metro or possibly even global
            level.</dd>
          </dl>
          <t>The default ICE candidate policy <bcp14>MUST</bcp14> be set to "all", as
          this is generally the desired policy and also typically
          reduces the use of application TURN server resources
          significantly.</t>
          <t>If a size is specified for the ICE candidate pool, this
          indicates the number of ICE components to pre-gather
          candidates for. Because pre&nbhy;gathering results in utilizing
          STUN/TURN server resources for potentially long periods of
          time, this <bcp14>MUST</bcp14> only occur upon application request, and
          therefore the default candidate pool size <bcp14>MUST</bcp14> be zero.</t>
          <t>The application can specify its preferred policy regarding
          the use of BUNDLE, the multiplexing mechanism defined in
          <xref target="RFC8843" format="default">
            </xref>. Regardless of policy, the application will always
          try to negotiate bundle onto a single transport and will
          offer a single bundle group across all "m=" sections; use of
          this single transport is contingent upon the answerer
          accepting bundle. However, by specifying a policy from the
          list below, the application can control exactly how
          aggressively it will try to bundle media streams together,
          which affects how it will interoperate with a
          non-bundle-aware endpoint. When negotiating with a
          non-bundle-aware endpoint, only the streams not marked as
          bundle-only streams will be established.</t>
          <t>The set of available policies is as follows:
          </t>
          <dl newline="false" spacing="normal">
            <dt>balanced:</dt>
            <dd>The first "m=" section of each type
            (audio, video, or application) will contain transport
            parameters, which will allow an answerer to unbundle that
            section. The second and any subsequent "m=" sections of each
            type will be marked as bundle-only. The result is that if
            there are N distinct media types, then candidates will be
            gathered for N media streams. This policy balances the
            desire to multiplex with the need to ensure that basic audio and
            video can still be negotiated in legacy cases. When acting
            as answerer, if there is no bundle group in the offer, the
            implementation will reject all but the first "m=" section of
            each type.</dd>
            <dt>max-compat:</dt>
            <dd>All "m=" sections will contain
            transport parameters; none will be marked as bundle-only.
            This policy makes no assumptions about the remote endpoint and
            as such will allow all streams to be received by
            non-bundle-aware endpoints, but as a result requires separate
            candidates to be gathered for each media stream.</dd>
            <dt>must-bundle:</dt>
            <dd>Only the first "m=" section will
            contain transport parameters; all streams other than the
            first will be marked as bundle-only. This policy presumes
            the remote endpoint supports multiplexing and accordingly aims to
            minimize candidate gathering, at
            the cost of less compatibility with legacy endpoints. When
            acting as answerer, the implementation will reject any "m="
            sections other than the first "m=" section, unless they are
            in the same bundle group as that "m=" section.</dd>
          </dl>         
          <t>As it provides the best trade-off between performance and
          compatibility with legacy endpoints, the default bundle
          policy <bcp14>MUST</bcp14> be set to "balanced".</t>
          <t><xref target="RFC8829" format="default"/> defined a policy
          known as "max-bundle", which, while defined identically to the
          "must-bundle" policy described above, was implemented
          by some implementations according to an earlier, pre-standard definition 
          (in which, for example, no "m=" sections were marked as bundle-only).
          As a result, "max-bundle" is considered deprecated, and new
          applications should use the "must-bundle" policy instead.
          </t>
          <t>The application can specify its preferred policy regarding
          use of RTP/RTCP multiplexing
          <xref target="RFC5761" format="default"/> using one of the following
          policies:
          </t>
          <dl newline="false" spacing="normal">
            <dt>negotiate:</dt>
            <dd>The JSEP implementation will
            gather both RTP and RTCP candidates but also will offer
            "a=rtcp-mux", thus allowing for compatibility with either
            multiplexing or non-multiplexing endpoints.</dd>
            <dt>require:</dt>
            <dd>The JSEP implementation will only
            gather RTP candidates and will insert an "a=rtcp-mux-only"
            indication into any new "m=" sections in offers it generates.
            This halves the number of candidates that the offerer needs
            to gather. Applying a description with an "m=" section that
            does not contain an "a=rtcp-mux" attribute will cause an
            error to be returned.</dd>
          </dl>
          <t>The default multiplexing policy <bcp14>MUST</bcp14> be set to "require".
          Implementations <bcp14>MAY</bcp14> choose to reject attempts by the
          application to set the multiplexing policy to
          "negotiate".</t>
        </section>
        <section anchor="sec.addTrack" numbered="true" toc="default">
          <name>addTrack</name>
          <t>The addTrack method adds a MediaStreamTrack to the
          PeerConnection, using the MediaStream argument to associate
          the track with other tracks in the same MediaStream, so that
          they can be added to the same "LS" (Lip Synchronization) group when creating an
          offer or answer. Adding tracks to the same "LS" group
          indicates that the playback of these tracks should be
          synchronized for proper lip sync, as described in
          <xref target="RFC5888" sectionFormat="comma" section="7"/>. &nbsp;addTrack attempts
          to minimize the number of transceivers as follows: if the
          PeerConnection is in the "have&nbhy;remote-offer" state, the track
          will be attached to the first compatible transceiver that was
          created by the most recent call to setRemoteDescription and
          does not have a local track. Otherwise, a new transceiver
          will be created, as described in
          <xref target="sec.addTransceiver" format="default"/>.</t>
        </section>
        <section anchor="sec.removeTrack" numbered="true" toc="default">
          <name>removeTrack</name>
          <t>The removeTrack method removes a MediaStreamTrack from the
          PeerConnection, using the RtpSender argument to indicate
          which sender should have its track removed. The sender's
          track is cleared, and the sender stops sending. Future calls
          to createOffer will mark the "m=" section associated with the
          sender as recvonly (if transceiver.direction is sendrecv) or
          as inactive (if transceiver.direction is sendonly).</t>
        </section>
        <section anchor="sec.addTransceiver" numbered="true" toc="default">
          <name>addTransceiver</name>
          <t>The addTransceiver method adds a new RtpTransceiver to the
          PeerConnection. If a MediaStreamTrack argument is provided,
          then the transceiver will be configured with that media type
          and the track will be attached to the transceiver. Otherwise,
          the application <bcp14>MUST</bcp14> explicitly specify the type; this mode
          is useful for creating recvonly transceivers as well as for
          creating transceivers to which a track can be attached at
          some later point.</t>
          <t>At the time of creation, the application can also specify
          a transceiver direction attribute, a set of MediaStreams
          that the transceiver is associated with (allowing "LS" group
          assignments), and a set of encodings for the media (used for
          simulcast as described in
          <xref target="sec.simulcast" format="default"/>).</t>
        </section>
        <section anchor="sec.onaddtrack" numbered="true" toc="default">
          <name>onaddtrack Event</name>
          <t>The onaddtrack event is dispatched to the application when a new
          remote track has been signaled as a result of a setRemoteDescription
          call. The new track is supplied as a MediaStreamTrack object in the
          event, along with the MediaStream(s) the track is part of.
          </t>
        </section>
        <section anchor="sec.createDataChannel" numbered="true" toc="default">
          <name>createDataChannel</name>
          <t>The createDataChannel method creates a new data channel
          and attaches it to the PeerConnection. If no data channel
          currently exists for this PeerConnection, then a new
          offer/answer exchange is required. All data channels on a
          given PeerConnection share the same SCTP/DTLS association ("SCTP" stands
          for "Stream Control Transmission Protocol") and
          therefore the same "m=" section, so subsequent creation of data
          channels does not have any impact on the JSEP state.</t>
          <t>The createDataChannel method also includes a number of
          arguments that are used by the PeerConnection (e.g.,
          maxPacketLifetime) but are not reflected in the SDP and do
          not affect the JSEP state.</t>
        </section>
        <section anchor="sec.ondatachannel" numbered="true" toc="default">
          <name>ondatachannel Event</name>
          <t>The ondatachannel event is dispatched to the application when a
          new data channel has been negotiated by the remote side, which can
          occur at any time after the underlying SCTP/DTLS association has been
          established. The new data channel object is supplied in the event.
          </t>
        </section>
        <section anchor="sec.createoffer" numbered="true" toc="default">
          <name>createOffer</name>
          <t>The createOffer method generates a blob of SDP that
          contains an offer per <xref target="RFC3264" format="default"/> with the supported
          configurations for the session, including descriptions of the
          media added to this PeerConnection, the codec, RTP, and RTCP
          options supported by this implementation, and any candidates
          that have been gathered by the ICE agent. An options
          parameter may be supplied to provide additional control over
          the generated offer. This options parameter allows an
          application to trigger an ICE restart, for the purpose of
          reestablishing connectivity.</t>
          <t>In the initial offer, the generated SDP will contain all
          desired functionality for the session (functionality that is
          supported but not desired by default may be omitted); for
          each SDP line, the generation of the SDP will follow the
          process defined for generating an initial offer from the
          specification that defines the given SDP line. The exact
          handling of initial offer generation is detailed in
          <xref target="sec.initial-offers" format="default"/> below.</t>
          <t>In the event createOffer is called after the session is
          established, createOffer will generate an offer to modify the
          current session based on any changes that have been made to
          the session, e.g., adding or stopping RtpTransceivers, or
          requesting an ICE restart. For each existing stream, the
          generation of each SDP line <bcp14>MUST</bcp14> follow the process defined
          for generating an updated offer from the RFC that specifies
          the given SDP line. For each new stream, the generation of
          the SDP <bcp14>MUST</bcp14> follow the process of generating an initial
          offer, as mentioned above. If no changes have been made, or
          for SDP lines that are unaffected by the requested changes,
          the offer will only contain the parameters negotiated by the
          last offer/answer exchange. The exact handling of subsequent
          offer generation is detailed in
          <xref target="sec.subsequent-offers" format="default"/> below.</t>
          <t>Session descriptions generated by createOffer <bcp14>MUST</bcp14> be
          immediately usable by setLocalDescription; if a system has
          limited resources (e.g., a finite number of decoders),
          createOffer <bcp14>SHOULD</bcp14> return an offer that reflects the current
          state of the system, so that setLocalDescription will succeed
          when it attempts to acquire those resources.</t>
          <t>Calling this method may do things such as generating new
          ICE credentials, but it does not change the PeerConnection
          state, trigger candidate gathering, or cause media to start
          or stop flowing. Specifically, the offer is not applied, and
          does not become the pending local description, until
          setLocalDescription is called.</t>
        </section>
        <section anchor="sec.createanswer" numbered="true" toc="default">
          <name>createAnswer</name>
          <t>The createAnswer method generates a blob of SDP that
          contains an SDP answer per <xref target="RFC3264" format="default"/> with the supported
          configuration for the session that is compatible with the
          parameters supplied in the most recent call to
          setRemoteDescription; setRemoteDescription <bcp14>MUST</bcp14> have been called prior to
          calling createAnswer. Like createOffer, the returned blob
          contains descriptions of the media added to this
          PeerConnection, the codec/RTP/RTCP options negotiated for
          this session, and any candidates that have been gathered by
          the ICE agent. An options parameter may be supplied to
          provide additional control over the generated answer.</t>
          <t>As an answer, the generated SDP will contain a specific
          configuration that specifies how the media plane should be
          established; for each SDP line, the generation of the SDP
          <bcp14>MUST</bcp14> follow the process defined for generating an answer from
          the specification that defines the given SDP line. The exact
          handling of answer generation is detailed in
          <xref target="sec.generating-an-answer" format="default"/> below.</t>
          <t>Session descriptions generated by createAnswer <bcp14>MUST</bcp14> be
          immediately usable by setLocalDescription; like createOffer,
          the returned description <bcp14>SHOULD</bcp14> reflect the current state of
          the system.</t>
          <t>Calling this method may do things such as generating new
          ICE credentials, but it does not change the PeerConnection
          state, trigger candidate gathering, or cause a media state
          change. Specifically, the answer is not applied, and does not
          become the current local description, until
          setLocalDescription is called.</t>
        </section>
        <section anchor="sec.sessiondescriptiontype" numbered="true" toc="default">
          <name>SessionDescriptionType</name>
          <t>Session description objects (RTCSessionDescription) may be
          of type "offer", "pranswer", "answer", or "rollback". These
          types provide information as to how the description parameter
          should be parsed and how the media state should be
          changed.</t>
          <t>"offer" indicates that a description <bcp14>MUST</bcp14> be parsed as
          an offer; said description may include many possible media
          configurations. A description used as an "offer" may be
          applied any time the PeerConnection is in a "stable" state or
          applied as an update to a previously supplied but unanswered
          "offer".</t>
          <t>"pranswer" indicates that a description <bcp14>MUST</bcp14> be parsed
          as an answer, but not a final answer, and so <bcp14>MUST NOT</bcp14>
          result in the freeing of allocated resources. It may result
          in the start of media transmission, if the answer does not
          specify an inactive media direction. A description used as a
          "pranswer" may be applied as a response to an "offer" or as an
          update to a previously sent "pranswer".</t>
          <t>"answer" indicates that a description <bcp14>MUST</bcp14> be parsed as
          an answer, the offer/answer exchange <bcp14>MUST</bcp14> be considered
          complete, and any resources (decoders, candidates) that are
          no longer needed <bcp14>SHOULD</bcp14> be released. A description used as an
          "answer" may be applied as a response to an "offer" or as an
          update to a previously sent "pranswer".</t>
          <t>The only difference between a provisional and final answer
          is that the final answer results in the freeing of any unused
          resources that were allocated as a result of the offer. As
          such, the application can use some discretion on whether an
          answer should be applied as provisional or final and can
          change the type of the session description as needed. For
          example, in a serial forking scenario, an application may
          receive multiple "final" answers, one from each remote
          endpoint. The application could choose to accept the initial
          answers as provisional answers and only apply an answer as
          final when it receives one that meets its criteria (e.g., a
          live user instead of voicemail).</t>
          <t>"rollback" is a special session description type indicating
          that the state machine <bcp14>MUST</bcp14> be rolled back to the previous
          "stable" state, as described in
          <xref target="sec.rollback" format="default"/>. The contents <bcp14>MUST</bcp14> be
          empty.</t>
          <section anchor="sec.use-of-provisional-answer" numbered="true" toc="default">
            <name>Use of Provisional Answers</name>
            <t>Most applications will not need to create answers using
            the "pranswer" type. While it is good practice to send an
            immediate response to an offer, in order to warm up the
            session transport and prevent media clipping, the preferred
            handling for a JSEP application is to create and send a
            "sendonly" final answer with a null MediaStreamTrack
            immediately after receiving the offer, which will prevent
            media from being sent by the caller and allow media to be
            sent immediately upon answer by the callee. Later, when the
            callee actually accepts the call, the application can plug
            in the real MediaStreamTrack and create a new "sendrecv"
            offer to update the previous offer/answer pair and start
            bidirectional media flow.  While this could also be done
            with a "sendonly" pranswer followed by a "sendrecv"
            answer, the initial pranswer leaves the offer/answer
            exchange open, which means that the caller cannot send an
            updated offer during this time.  </t>
            <t>As an example, consider a typical JSEP application that
            wants to set up audio and video as quickly as possible.
            When the callee receives an offer with audio and video
            MediaStreamTracks, it will send an immediate answer
            accepting these tracks as sendonly (meaning that the caller
            will not send the callee any media yet, and because the
            callee has not yet added its own MediaStreamTracks, the
            callee will not send any media either). It will then ask
            the user to accept the call and acquire the needed local
            tracks. Upon acceptance by the user, the application will
            plug in the tracks it has acquired, which, because ICE handshaking
            and DTLS handshaking have likely completed by this point, can
            start transmitting immediately. The application will also
            send a new offer to the remote side indicating call
            acceptance and moving the audio and video to be two-way
            media. A detailed example flow along these lines is shown
            in
            <xref target="sec.warmup-example" format="default"/>.</t>
            <t>Of course, some applications may not be able to perform
            this double offer/answer exchange, particularly ones that
            are attempting to gateway to legacy signaling protocols. In
            these cases, pranswer can still provide the application
            with a mechanism to warm up the transport.</t>
          </section>
          <section anchor="sec.rollback" numbered="true" toc="default">
            <name>Rollback</name>
            <t>In certain situations, it may be desirable to "undo" a
            change made to setLocalDescription or setRemoteDescription.
            Consider a case where a call is ongoing and one side wants
            to change some of the session parameters; that side
            generates an updated offer and then calls
            setLocalDescription. However, the remote side, either
            before or after setRemoteDescription, decides it does not
            want to accept the new parameters and sends a reject
            message back to the offerer. Now, the offerer, and possibly
            the answerer as well, needs to return to a "stable" state and
            the previous local/remote description. To support this, we
            introduce the concept of "rollback", which discards any
            proposed changes to the session, returning the state
            machine to the "stable" state. A rollback is performed by
            supplying a session description of type "rollback" with
            empty contents to either setLocalDescription or
            setRemoteDescription.</t>
          </section>
        </section>
        <section anchor="sec.setlocaldescription" numbered="true" toc="default">
          <name>setLocalDescription</name>
          <t>The setLocalDescription method instructs the
          PeerConnection to apply the supplied session description as
          its local configuration. The type field indicates whether the
          description should be processed as an offer, provisional
          answer, final answer, or rollback; offers and answers are
          checked differently, using the various rules that exist for
          each SDP line.</t>
          <t>This API changes the local media state; among other
          things, it sets up local resources for receiving and decoding
          media. In order to successfully handle scenarios where the
          application wants to offer to change from one media format to
          a different, incompatible format, the PeerConnection <bcp14>MUST</bcp14> be
          able to simultaneously support use of both the current and
          pending local descriptions (e.g., support the codecs that
          exist in either description). This dual processing begins
          when the PeerConnection enters the "have-local-offer" state,
          and it continues until setRemoteDescription is called with
          either (1)&nbsp;a final answer, at which point the PeerConnection can
          fully adopt the pending local description or (2)&nbsp;a rollback,
          which results in a revert to the current local
          description.</t>
          <t>This API indirectly controls the candidate gathering
          process. When a local description is supplied and the number
          of transports currently in use does not match the number of
          transports needed by the local description, the
          PeerConnection will create transports as needed and begin
          gathering candidates for each transport, using ones from the
          candidate pool if available.</t>
          <t>If (1) setRemoteDescription was previously called with an
          offer, (2) setLocalDescription is called with an answer
          (provisional or final), (3) the media directions are
          compatible, and (4) media is available to send, this will result
          in the starting of media transmission.
        </t>
        </section>
        <section anchor="sec.setremotedescription" numbered="true" toc="default">
          <name>setRemoteDescription</name>
          <t>The setRemoteDescription method instructs the
          PeerConnection to apply the supplied session description as
          the desired remote configuration. As in setLocalDescription,
          the type field of the description indicates how it should be
          processed.</t>
          <t>This API changes the local media state; among other
          things, it sets up local resources for sending and encoding
          media. </t>
          <t>If (1) setLocalDescription was previously called with an
          offer, (2) setRemoteDescription is called with an answer
          (provisional or final), (3) the media directions are
          compatible, and (4) media is available to send, this will result
          in the starting of media transmission.</t>
        </section>
        <section anchor="sec.currentlocaldescription" numbered="true" toc="default">
          <name>currentLocalDescription</name>
          <t>The currentLocalDescription method returns the current
          negotiated local description -- i.e., the local description
          from the last successful offer/answer exchange -- in addition
          to any local candidates that have been generated by the ICE
          agent since the local description was set.</t>
          <t>A null object will be returned if an offer/answer exchange
          has not yet been completed.</t>
        </section>
        <section anchor="sec.pendinglocaldescription" numbered="true" toc="default">
          <name>pendingLocalDescription</name>
          <t>The pendingLocalDescription method returns a copy of the
          local description currently in negotiation -- i.e., a local
          offer set without any corresponding remote answer -- in
          addition to any local candidates that have been generated by
          the ICE agent since the local description was set.</t>
          <t>A null object will be returned if the state of the
          PeerConnection is "stable" or "have-remote-offer".</t>
        </section>
        <section anchor="sec.currentremotedescription" numbered="true" toc="default">
          <name>currentRemoteDescription</name>
          <t>The currentRemoteDescription method returns a copy of the
          current negotiated remote description -- i.e., the remote
          description from the last successful offer/answer exchange --
          in addition to any remote candidates that have been supplied
          via processIceMessage since the remote description was
          set.</t>
          <t>A null object will be returned if an offer/answer exchange
          has not yet been completed.</t>
        </section>
        <section anchor="sec.pendingremotedescription" numbered="true" toc="default">
          <name>pendingRemoteDescription</name>
          <t>The pendingRemoteDescription method returns a copy of the
          remote description currently in negotiation -- i.e., a remote
          offer set without any corresponding local answer -- in
          addition to any remote candidates that have been supplied via
          processIceMessage since the remote description was set.</t>
          <t>A null object will be returned if the state of the
          PeerConnection is "stable" or "have-local-offer".</t>
        </section>
        <section anchor="sec.cantrickle" numbered="true" toc="default">
          <name>canTrickleIceCandidates</name>
          <t>The canTrickleIceCandidates property indicates whether the
          remote side supports receiving trickled candidates. There are
          three potential values:
          </t>
          <dl newline="false" spacing="normal">
            <dt>null:</dt>
            <dd>No SDP has been received from the other
            side, so it is not known if it can handle trickle. This is
            the initial value before setRemoteDescription is
            called.</dd>
            <dt>true:</dt>
            <dd>SDP has been received from the other
            side indicating that it can support trickle.</dd>
            <dt>false:</dt>
            <dd>SDP has been received from the other
            side indicating that it cannot support trickle.</dd>
          </dl>
          <t>As described in
          <xref target="sec.ice-candidate-trickling" format="default"/>, JSEP
          implementations always provide candidates to the application
          individually, consistent with what is needed for Trickle ICE.
          However, applications can use the canTrickleIceCandidates
          property to determine whether their peer can actually do
          Trickle ICE, i.e., whether it is safe to send an initial
          offer or answer followed later by candidates as they are
          gathered. As "true" is the only value that definitively
          indicates remote Trickle ICE support, an application that
          compares canTrickleIceCandidates against "true" will by
          default attempt Half Trickle on initial offers and Full
          Trickle on subsequent interactions with a Trickle
          ICE-compatible agent.</t>
        </section>
        <section anchor="sec.setconfiguration" numbered="true" toc="default">
          <name>setConfiguration</name>
          <t>The setConfiguration method allows the global
          configuration of the PeerConnection, which was initially set
          by constructor parameters, to be changed during the session.
          The effects of calling this method depend on when it is invoked,
          and they will differ, depending on which specific parameters are
          changed: </t>
          <ul spacing="normal">
            <li>Any changes to the STUN/TURN servers to use affect the
              next gathering phase. If an ICE gathering phase has
              already started or completed, the 'needs-ice-restart' bit
              mentioned in
              <xref target="sec.ice-gather-overview" format="default"/> will be set.
              This will cause the next call to createOffer to generate
              new ICE credentials, for the purpose of forcing an ICE
              restart and kicking off a new gathering phase, in which
              the new servers will be used. If the ICE candidate pool
              has a nonzero size and a local description has not yet
              been applied, any existing candidates will be discarded,
              and new candidates will be gathered from the new
              servers.</li>
            <li>Any change to the ICE candidate policy affects the
              next gathering phase. If an ICE gathering phase has
              already started or completed, the 'needs-ice-restart' bit
              will be set. Either way, changes to the policy have no
              effect on the candidate pool, because pooled candidates
              are not made available to the application until a
              gathering phase occurs, and so any necessary filtering
              can still be done on any pooled candidates.</li>
            <li>The ICE candidate pool size <bcp14>MUST NOT</bcp14> be changed after
              applying a local description. If a local description has
              not yet been applied, any changes to the ICE candidate
              pool size take effect immediately; if increased,
              additional candidates are pre-gathered; if decreased, the
              now-superfluous candidates are discarded.</li>
            <li>The bundle and RTCP-multiplexing policies <bcp14>MUST NOT</bcp14> be
              changed after the construction of the PeerConnection.</li>
          </ul>
          <t>Calling this method may result in a change to the state of the ICE
          agent.</t>
        </section>
        <section anchor="sec.addicecandidate" numbered="true" toc="default">
          <name>addIceCandidate</name>
          <t>The addIceCandidate method provides an update to the ICE
          agent via an IceCandidate object
          (<xref target="sec.ice-candidate-format" format="default"/>). If the
          IceCandidate's candidate field is non-null, the IceCandidate
          is treated as a new remote ICE candidate, which will be added
          to the current and/or pending remote description according to
          the rules defined for Trickle ICE. Otherwise, the
          IceCandidate is treated as an end-of-candidates indication,
          as defined in
          <xref target="RFC8838" sectionFormat="comma" section="14"/>.</t>
          <t>In either case, the "m=" section index, MID, and ufrag
          fields from the supplied IceCandidate are used to determine
          which "m=" section and ICE candidate generation the
          IceCandidate belongs to, as described in
          <xref target="sec.ice-candidate-format" format="default"/> above. In the case
          of an end-of-candidates indication, null values for the
          "m=" section index and MID fields are interpreted to mean that
          the indication applies to all "m=" sections in the specified
          ICE candidate generation. However, if both fields are null
          for a new remote candidate, this <bcp14>MUST</bcp14> be treated as an
          invalid condition, as specified below.</t>
          <t>If any IceCandidate fields contain invalid values or an
          error occurs during the processing of the IceCandidate
          object, the supplied IceCandidate <bcp14>MUST</bcp14> be ignored and an
          error <bcp14>MUST</bcp14> be returned.</t>
          <t>Otherwise, the new remote candidate or end-of-candidates
          indication is supplied to the ICE agent. In the case of a new
          remote candidate, connectivity checks will be sent to the new
          candidate, assuming setLocalDescription has already been
          called to initialize the ICE gathering process.</t>
        </section>
        <section anchor="sec.onicecandidate" numbered="true" toc="default">
          <name>onicecandidate Event</name>
          <t>The onicecandidate event is dispatched to the application in two
          situations: (1) when the ICE agent has discovered a new allowed local
          ICE candidate during ICE gathering, as outlined in
          <xref target="sec.ice-gather-overview" format="default"></xref> and
          subject to the restrictions discussed in
          <xref target="sec.ice-candidate-policy" format="default"></xref>, or
          (2) when an ICE gathering phase completes. The event contains a single
          IceCandidate object, as defined in
          <xref target="sec.ice-candidate-format" format="default"/>.</t>
          <t>In the first case, the newly discovered candidate is reflected
          in the IceCandidate object, and all of its fields <bcp14>MUST</bcp14> be non-null.
          This candidate will also be added to the current and/or pending local
          description according to the rules defined for Trickle ICE.</t>
          <t>In the second case, the event's IceCandidate object
          <bcp14>MUST</bcp14> have its candidate field set to null to indicate
          that the current gathering phase is complete, i.e., there will be no
          further onicecandidate events in this phase. However, the
          IceCandidate's ufrag field <bcp14>MUST</bcp14> be specified to
          indicate which ICE candidate generation is ending. The IceCandidate's
          "m=" section index and MID fields <bcp14>MAY</bcp14> be specified to indicate that
          the event applies to a specific "m=" section, or set to null to
          indicate it applies to all "m=" sections in the current ICE candidate
          generation. This event can be used by the application to generate an
          end-of-candidates indication, as defined in
          <xref target="RFC8838" sectionFormat="comma" section="13"/>.</t>
        </section>
      </section>
      <section anchor="sec.transceiver" numbered="true" toc="default">
        <name>RtpTransceiver</name>
        <section anchor="sec.transceiver-stop" numbered="true" toc="default">
          <name>stop</name>
          <t>The stop method stops an RtpTransceiver. This will cause
          future calls to createOffer to generate a zero port for the
          associated "m=" section. See below for more details.</t>
        </section>
        <section anchor="sec.transceiver-stopped" numbered="true" toc="default">
          <name>stopped</name>
          <t>The stopped property indicates whether the transceiver has
          been stopped, either by a call to stop or by
          applying an answer that rejects the associated "m=" section. In
          either of these cases, it is set to "true" and otherwise
          will be set to "false".</t>
          <t>A stopped RtpTransceiver does not send any outgoing RTP or
          RTCP or process any incoming RTP or RTCP. It cannot be
          restarted.</t>
        </section>
        <section anchor="sec.transceiver-set-direction" numbered="true" toc="default">
          <name>setDirection</name>
          <t>The setDirection method sets the direction of a
          transceiver, which affects the direction property of the
          associated "m=" section on future calls to createOffer and
          createAnswer. The permitted values for direction are
          "recvonly", "sendrecv", "sendonly", and "inactive", mirroring
          the identically named direction attributes defined in
          <xref target="RFC4566" sectionFormat="comma" section="6"/>.</t>
          <t>When creating offers, the transceiver direction is
          directly reflected in the output, even for re-offers. When
          creating answers, the transceiver direction is intersected
          with the offered direction, as explained in
          <xref target="sec.generating-an-answer" format="default"/> below.</t>
          <t>Note that while setDirection sets the direction property
          of the transceiver immediately (<xref target="sec.transceiver-direction" format="default"/>), this property
          does not immediately affect whether the transceiver's
          RtpSender will send or its RtpReceiver will receive. The
          direction in effect is represented by the currentDirection
          property, which is only updated when an answer is
          applied.</t>
        </section>
        <section anchor="sec.transceiver-direction" numbered="true" toc="default">
          <name>direction</name>
          <t>The direction property indicates the last value passed
          into setDirection. If setDirection has never been called, it
          is set to the direction the transceiver was initialized
          with.</t>
        </section>
        <section anchor="sec.transceiver-current-direction" numbered="true" toc="default">
          <name>currentDirection</name>
          <t>The currentDirection property indicates the last
          negotiated direction for the transceiver's associated "m="
          section. More specifically, it indicates the
          direction attribute <xref target="RFC3264" format="default"/> of the
          associated "m=" section in the last applied answer (including
          provisional answers), with "send" and "recv" directions
          reversed if it was a remote answer.  For example, if the
          direction attribute for the associated "m=" section in a
          remote answer is "recvonly", currentDirection is set to
          "sendonly".</t>
          <t>If an answer that references this transceiver has not yet
          been applied or if the transceiver is stopped,
          currentDirection is set to "null".</t>
        </section>
        <section anchor="sec.transceiver-set-codec-preferences" numbered="true" toc="default">
          <name>setCodecPreferences</name>
          <t>The setCodecPreferences method sets the codec preferences
          of a transceiver, which in turn affect the presence and order
          of codecs of the associated "m=" section on future calls to
          createOffer and createAnswer. Note that setCodecPreferences
          does not directly affect which codec the implementation
          decides to send. It only affects which codecs the
          implementation indicates that it prefers to receive, via the
          offer or answer. Even when a codec is excluded by
          setCodecPreferences, it still may be used to send until the
          next offer/answer exchange discards it.</t>
          <t>The codec preferences of an RtpTransceiver can cause
          codecs to be excluded by subsequent calls to createOffer and
          createAnswer, in which case the corresponding media formats
          in the associated "m=" section will be excluded. The codec
          preferences cannot add media formats that would otherwise not
          be present.</t>
          <t>The codec preferences of an RtpTransceiver can also
          determine the order of codecs in subsequent calls to
          createOffer and createAnswer, in which case the order of the
          media formats in the associated "m=" section will follow the
          specified preferences.</t>
        </section>
      </section>
    </section>
    <section anchor="sec.sdp-interaction-procedure" numbered="true" toc="default">
      <name>SDP Interaction Procedures</name>
      <t>This section describes the specific procedures to be followed
      when creating and parsing SDP objects.</t>
      <section anchor="sec.requirements-overview" numbered="true" toc="default">
        <name>Requirements Overview</name>
        <t>JSEP implementations <bcp14>MUST</bcp14> comply with the specifications
        listed below that govern the creation and processing of offers
        and answers.</t>
        <section anchor="sec.usage-requirements" numbered="true" toc="default">
          <name>Usage Requirements</name>
          <t>All session descriptions handled by JSEP implementations,
          both local and remote, <bcp14>MUST</bcp14> indicate support for the
          following specifications. If any of these are absent, this
          omission <bcp14>MUST</bcp14> be treated as an error.
          </t>
          <ul spacing="normal">
            <li>ICE, as specified in
            <xref target="RFC8445" format="default"/>, <bcp14>MUST</bcp14> be used. Note that the
            remote endpoint may use a lite implementation;
            implementations <bcp14>MUST</bcp14> properly handle remote endpoints that
            use ICE-lite. The remote endpoint may also use
an older version of ICE; implementations <bcp14>MUST</bcp14> properly handle remote endpoints that use ICE
as specified in <xref target="RFC5245" format="default"/>.</li>
            <li>DTLS
            <xref target="RFC6347" format="default"/> or DTLS-SRTP
            <xref target="RFC5763" format="default"/> <bcp14>MUST</bcp14> be used, as
            appropriate for the media type, as specified in
            <xref target="RFC8827" format="default"/>.</li>
          </ul>
          <t>The SDP security descriptions mechanism for SRTP keying
          <xref target="RFC4568" format="default"/> <bcp14>MUST NOT</bcp14> be used, as discussed in
          <xref target="RFC8827" format="default"/>.</t>
        </section>
        <section anchor="sec.profile-names" numbered="true" toc="default">
          <name>Profile Names and Interoperability</name>
          <t>For media "m=" sections, JSEP implementations <bcp14>MUST</bcp14> support
          the "UDP/TLS/RTP/SAVPF" profile specified in
          <xref target="RFC5764" format="default"/> as well as the "TCP/DTLS/RTP/SAVPF"
          profile specified in <xref target="RFC7850" format="default"/> and <bcp14>MUST</bcp14> indicate
          one of these profiles for each media "m=" line they produce in an offer.
          For data "m=" sections, implementations <bcp14>MUST</bcp14> support the
          "UDP/DTLS/SCTP" profile as well as the "TCP/DTLS/SCTP" profile and
          <bcp14>MUST</bcp14> indicate one of these profiles for each data "m=" line they produce
          in an offer. The exact profile to use is determined by the protocol
          associated with the current default or selected ICE candidate, as
          described in
          <xref target="RFC8839" sectionFormat="comma" section="4.2.1.2"/>.</t>
          <t>Unfortunately, in an attempt at compatibility, some
          endpoints generate other profile strings even when they mean
          to support one of these profiles. For instance, an endpoint
          might generate "RTP/AVP" but supply "a=fingerprint" and
          "a=rtcp-fb" attributes, indicating its willingness to support
          "UDP/TLS/RTP/SAVPF" or "TCP/DTLS/RTP/SAVPF". In order to
          simplify compatibility with such endpoints, JSEP
          implementations <bcp14>MUST</bcp14> follow the following rules when
          processing the media "m=" sections in a received offer:</t>
          <ul spacing="normal">
            <li>
              <t>Any profile in the offer matching one of the following
              <bcp14>MUST</bcp14> be accepted:
              </t>
              <ul spacing="normal">
                <li>"RTP/AVP" (defined in
                <xref target="RFC4566" sectionFormat="comma" section="8.2.2"/>)</li>
                <li>"RTP/AVPF" (defined in
                <xref target="RFC4585" sectionFormat="comma" section="9"/>)</li>
                <li>"RTP/SAVP" (defined in
                <xref target="RFC3711" sectionFormat="comma" section="12"/>)</li>
                <li>"RTP/SAVPF" (defined in
                <xref target="RFC5124" sectionFormat="comma" section="6"/>)</li>
                <li>"TCP/DTLS/RTP/SAVP" (defined in
                <xref target="RFC7850" sectionFormat="comma" section="3.4"/>)</li>
                <li>"TCP/DTLS/RTP/SAVPF" (defined in
                <xref target="RFC7850" sectionFormat="comma" section="3.5"/>)</li>
                <li>"UDP/TLS/RTP/SAVP" (defined in
                <xref target="RFC5764" sectionFormat="comma" section="9"/>)</li>
                <li>"UDP/TLS/RTP/SAVPF" (defined in
                <xref target="RFC5764" sectionFormat="comma" section="9"/>)</li>
              </ul>
            </li>
            <li>The profile in any "m=" line in any generated answer
              <bcp14>MUST</bcp14> exactly match the profile provided in the offer.</li>
            <li>Because DTLS-SRTP is <bcp14>REQUIRED</bcp14>, the choice of SAVP or
              AVP has no effect; support for DTLS-SRTP is determined by
              the presence of one or more "a=fingerprint" attributes.
              Note that lack of an "a=fingerprint" attribute will lead
              to negotiation failure.</li>
            <li>The use of AVPF or AVP simply controls the timing
              rules used for RTCP feedback. If AVPF is provided or an
              "a=rtcp-fb" attribute is present, assume AVPF timing,
              i.e., a default value of "trr-int=0". Otherwise, assume
              that AVPF is being used in an AVP-compatible mode and use
              a value of "trr-int=4000".</li>
            <li>For data "m=" sections, implementations <bcp14>MUST</bcp14> support
              receiving the "UDP/DTLS/SCTP", "TCP/DTLS/SCTP", or
              "DTLS/SCTP" (for backwards compatibility) profiles.</li>
          </ul>
          <t>Note that re-offers by JSEP implementations <bcp14>MUST</bcp14> use the
          correct profile strings even if the initial offer/answer
          exchange used an (incorrect) older profile string. This
          simplifies JSEP behavior, with minimal downside, as any
          remote endpoint that fails to handle such a re-offer will
          also fail to handle a JSEP endpoint's initial offer.</t>
        </section>
      </section>
      <section anchor="sec-create-offer" numbered="true" toc="default">
        <name>Constructing an Offer</name>
        <t>When createOffer is called, a new SDP description <bcp14>MUST</bcp14> be
        created that includes the functionality specified in
        <xref target="RFC8834" format="default"/>. The exact
        details of this process are explained below.</t>
        <section anchor="sec.initial-offers" numbered="true" toc="default">
          <name>Initial Offers</name>
          <t>When createOffer is called for the first time, the result
          is known as the initial offer.</t>
          <t>The first step in generating an initial offer is to
          generate session-level attributes, as specified in
          <xref target="RFC4566" sectionFormat="comma" section="5"/>. Specifically:
          </t>
          <ul spacing="normal">
            <li>The first SDP line <bcp14>MUST</bcp14> be "v=0" as defined in
            <xref target="RFC4566" sectionFormat="comma" section="5.1"/>.</li>
            <li>The second SDP line <bcp14>MUST</bcp14> be an "o=" line as defined
            in
            <xref target="RFC4566" sectionFormat="comma" section="5.2"/>.
 The value of
            the &lt;username&gt; field <bcp14>SHOULD</bcp14> be "-". The &lt;sess-id&gt; <bcp14>MUST</bcp14>
            be representable by a 64-bit signed integer, and the
           value <bcp14>MUST</bcp14> be less than
	    2<sup>63</sup>-1.
            It is <bcp14>RECOMMENDED</bcp14> that the
            &lt;sess-id&gt; be constructed by generating a 64-bit quantity with
            the highest bit set to zero and the remaining 63
            bits being cryptographically random. The value of the
            &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt;
            tuple <bcp14>SHOULD</bcp14> be set to a non-meaningful address, such as IN
            IP4 0.0.0.0, to prevent leaking a local IP address in this
            field; this problem is discussed in
            <xref target="RFC8828" format="default"/>. As mentioned in
            <xref target="RFC4566" format="default"/>, the entire "o=" line needs to
            be unique, but selecting a random number for
            &lt;sess-id&gt; is sufficient to accomplish this.</li>
            <li>The third SDP line <bcp14>MUST</bcp14> be a "s=" line as defined in
            <xref target="RFC4566" sectionFormat="comma" section="5.3"/>; to match the
            "o=" line, a single dash <bcp14>SHOULD</bcp14> be used as the session
            name, e.g., "s=-". Note that this differs from the advice in

            <xref target="RFC4566" format="default"/>, which proposes a single space, but
            as both "o=" and "s=" are meaningless in JSEP, having the
            same meaningless value seems clearer.</li>
            <li>Session Information ("i="), URI ("u="), Email Address
            ("e="), Phone Number ("p="), Repeat Times ("r="), and Time
            Zones ("z=") lines are not useful in this context and
            <bcp14>SHOULD NOT</bcp14> be included.</li>
            <li>Encryption Keys ("k=") lines do not provide sufficient
            security and <bcp14>MUST NOT</bcp14> be included.</li>
            <li>A "t=" line <bcp14>MUST</bcp14> be added, as specified in
            <xref target="RFC4566" sectionFormat="comma" section="5.9"/>; both
            &lt;start-time&gt; and &lt;stop-time&gt; <bcp14>SHOULD</bcp14> be set to
            zero, e.g., "t=0 0".</li>
            <li>An "a=ice-options" line with the "trickle" and "ice2"
            options <bcp14>MUST</bcp14> be added, as specified in <xref
            target="RFC8840" sectionFormat="comma" section="4.1.1"/> and
            <xref target="RFC8445" sectionFormat="comma" section="10"/>.
</li>
            <li>If WebRTC identity is being used, an "a=identity" line
            <bcp14>MUST</bcp14> be added, as described in
            <xref target="RFC8827" sectionFormat="comma" section="5"/>.</li>
          </ul>
          <t>The next step is to generate "m=" sections, as specified in
          <xref target="RFC4566" sectionFormat="comma" section="5.14"/>. An "m=" section is
          generated for each RtpTransceiver that has been added to the
          PeerConnection, excluding any stopped RtpTransceivers; this
          is done in the order the RtpTransceivers were added to the
          PeerConnection. If there are no such RtpTransceivers, no "m="
          sections are generated; more can be added later, as discussed
          in
          <xref target="RFC3264" sectionFormat="comma" section="5"/>.</t>
          <t>For each "m=" section generated for an RtpTransceiver,
          establish a mapping between the transceiver and the index of
          the generated "m=" section.</t>
          <t>Each "m=" section, provided it is not marked as bundle-only,
          <bcp14>MUST</bcp14> contain a unique set of ICE credentials and
          a unique set of ICE candidates. Bundle-only "m=" sections
          <bcp14>MUST NOT</bcp14> contain any ICE credentials and <bcp14>MUST NOT</bcp14> gather any
          candidates.</t>
          <t>For DTLS, all "m=" sections <bcp14>MUST</bcp14> use any and all certificates
          that have been specified for the PeerConnection; as a result,
          they <bcp14>MUST</bcp14> all have the same fingerprint value or values
          <xref target="RFC8122" format="default"/>, or these
          values <bcp14>MUST</bcp14> be session-level attributes.</t>
          <t>Each "m=" section <bcp14>MUST</bcp14> be generated as specified in
          <xref target="RFC4566" sectionFormat="comma" section="5.14"/>. For the "m=" line
          itself, the following rules <bcp14>MUST</bcp14> be followed:
          </t>
          <ul spacing="normal">
            <li>If the "m=" section is marked as bundle-only, then the
            &lt;port&gt; value <bcp14>MUST</bcp14> be set to zero. Otherwise, the &lt;port&gt; value is
            set to the port of the default ICE candidate for this "m="
            section, but given that no candidates are available yet,
            the default port value of 9 (Discard) <bcp14>MUST</bcp14> be used, as
            indicated in
            <xref target="RFC8840" sectionFormat="comma" section="4.1.1"/>.</li>
            <li>To properly indicate use of DTLS, the &lt;proto&gt;
            field <bcp14>MUST</bcp14> be set to "UDP/TLS/RTP/SAVPF", as specified in
            <xref target="RFC5764" sectionFormat="comma" section="8"/>.</li>
            <li>If codec preferences have been set for the associated
            transceiver, media formats <bcp14>MUST</bcp14> be generated in the
            corresponding order and <bcp14>MUST</bcp14> exclude any codecs not
            present in the codec preferences.</li>
            <li>Unless excluded by the above restrictions, the media
            formats <bcp14>MUST</bcp14> include the mandatory audio/video codecs as
            specified in
            <xref target="RFC7874" sectionFormat="comma" section="3"/> and
            <xref target="RFC7742" sectionFormat="comma" section="5"/>.</li>
          </ul>

          <t>The "m=" line <bcp14>MUST</bcp14> be followed immediately by a "c=" line,
          as specified in
          <xref target="RFC4566" sectionFormat="comma" section="5.7"/>. Again, as no
          candidates are available yet, the "c=" line <bcp14>MUST</bcp14> contain the
          default value "IN IP4 0.0.0.0", as defined in
          <xref target="RFC8840" sectionFormat="comma" section="4.1.1"/>.</t>
          <t>
          <xref target="RFC8859" format="default"/> groups
          SDP attributes into different categories. To avoid
          unnecessary duplication when bundling, attributes of category
          IDENTICAL or TRANSPORT <bcp14>MUST NOT</bcp14> be repeated in bundled "m="
          sections, repeating the guidance from
          <xref target="RFC8843"
          sectionFormat="comma" section="7.1.3"/>.
          This includes "m=" sections for which bundling has
          been negotiated and is still desired, as well as "m=" sections
          marked as bundle-only.</t>
          <t>The following attributes, which are of a category other
          than IDENTICAL or TRANSPORT, <bcp14>MUST</bcp14> be included in each "m="
          section:</t>
          <ul spacing="normal">
            <li>An "a=mid" line, as specified in
              <xref target="RFC5888" sectionFormat="comma" section="4"/>. All MID values
              <bcp14>MUST</bcp14> be generated in a fashion that does not leak user
              information, e.g., randomly or using a per-PeerConnection
              counter, and <bcp14>SHOULD</bcp14> be 3 bytes or less, to allow them to
              efficiently fit into the RTP header extension defined in
              <xref target="RFC8843" sectionFormat="comma" section="15.2"/>.
              Note that this does not set the
              RtpTransceiver mid property, as that only occurs when the
              description is applied. The generated MID value can be
              considered a "proposed" MID at this point.</li>
            <li>A direction attribute that is the same as that of the
              associated transceiver.</li>
            <li>For each media format on the "m=" line, "a=rtpmap" and "a=fmtp" lines, as specified in
              <xref target="RFC4566" sectionFormat="comma" section="6"/> and
              <xref target="RFC3264" sectionFormat="comma" section="5.1"/>.</li>
            <li>For each primary codec where RTP retransmission should
              be used, a corresponding "a=rtpmap" line indicating "rtx"
              with the clock rate of the primary codec and an "a=fmtp"
              line that references the payload type of the primary
              codec, as specified in
              <xref target="RFC4588" sectionFormat="comma" section="8.1"/>.</li>
            <li>For each supported Forward Error Correction (FEC) mechanism, "a=rtpmap" and
              "a=fmtp" lines, as specified in
              <xref target="RFC4566" sectionFormat="comma" section="6"/>. The FEC
              mechanisms that <bcp14>MUST</bcp14> be supported are specified in
              <xref target="RFC8854" sectionFormat="comma" section="7"/>,
              and specific usage for each media type is outlined in
              Sections <xref target="sec.interface" format="counter"/> and <xref target="sec.sdp-interaction-procedure"
	      format="counter"/>.</li>
            <li>If this "m=" section is for media with configurable
              durations of media per packet, e.g., audio, an
              "a=maxptime" line, indicating the maximum amount of
              media, specified in milliseconds, that can be
              encapsulated in each packet, as specified in
              <xref target="RFC4566" sectionFormat="comma" section="6"/>. This value is
              set to the smallest of the maximum duration values across
              all the codecs included in the "m=" section.</li>
            <li>If this "m=" section is for video media and there are
              known limitations on the size of images that can be
              decoded, an "a=imageattr" line, as specified in
              <xref target="sec.imageattr" format="default"/>.</li>
            <li>For each supported RTP header extension, an "a=extmap"
              line, as specified in
              <xref target="RFC5285" sectionFormat="comma" section="5"/>.
              The list of
              header extensions that <bcp14>SHOULD</bcp14>/<bcp14>MUST</bcp14> be supported is
              specified in
              <xref target="RFC8834" sectionFormat="comma" section="5.2"/>. Any header extensions that require encryption <bcp14>MUST</bcp14>
              be specified as indicated in
              <xref target="RFC6904" sectionFormat="comma" section="4"/>.</li>
            <li>For each supported RTCP feedback mechanism, an
              "a=rtcp-fb" line, as specified in
              <xref target="RFC4585" sectionFormat="comma" section="4.2"/>. The list of
              RTCP feedback mechanisms that <bcp14>SHOULD</bcp14>/<bcp14>MUST</bcp14> be supported is
              specified in
              <xref target="RFC8834" sectionFormat="comma" section="5.1"/>.</li>
            <li>
              <t>If the RtpTransceiver has a sendrecv or sendonly
              direction:
              </t>
              <ul spacing="normal">
                <li>For each MediaStream that was associated with the
                transceiver when it was created via addTrack or
                addTransceiver, an "a=msid" line, as specified in
                <xref target="RFC8830" sectionFormat="comma" section="2"/>,
                but omitting the "appdata" field.</li>
              </ul>
            </li>
            <li>If the RtpTransceiver has a sendrecv or sendonly
              direction, and the application has specified a rid-id for an encoding,
              or has specified more than one encoding in the
              RtpSenders's parameters, an "a=rid" line for each
              encoding specified. The "a=rid" line is specified in
              <xref target="RFC8851" format="default"/>, and its
              direction <bcp14>MUST</bcp14> be "send". If the application has chosen a
              rid-id, it <bcp14>MUST</bcp14> be used;
              otherwise, a rid-id <bcp14>MUST</bcp14> be generated by the
              implementation. rid-ids <bcp14>MUST</bcp14> be generated in a fashion
              that does not leak user information, e.g., randomly or
              using a per-PeerConnection counter (see guidance at the end
              of <xref target="RFC8852" sectionFormat="comma" section="3.3"/>), and <bcp14>SHOULD</bcp14> be 3 bytes
              or less, to allow them to efficiently fit into the RTP
              header extensions defined in
              <xref target="RFC8852" sectionFormat="comma" section="3.3"/>.
              If no encodings have been specified, or only one encoding is
              specified but without a rid-id, then no "a=rid" lines
              are generated.</li>
            <li>If the RtpTransceiver has a sendrecv or sendonly
              direction and more than one "a=rid" line has been
              generated, an "a=simulcast" line, with direction "send",
              as defined in
              <xref target="RFC8853" sectionFormat="comma"
              section="5.1"/>. The associated set of rid-ids <bcp14>MUST</bcp14>
              include all of the rid-ids used in the "a=rid" lines for this "m="
              section.</li>
            <li>If (1) the bundle policy for this PeerConnection is set to
              "must-bundle" and this is not the first "m=" section or (2)
              the bundle policy is set to "balanced" and this is not
              the first "m=" section for this media type, an
              "a=bundle-only" line.</li>
          </ul>
          <t>The following attributes, which are of category IDENTICAL
          or TRANSPORT, <bcp14>MUST</bcp14> appear only in "m=" sections that either
          have a unique address or are associated with the
          BUNDLE-tag. (In initial offers, this means those "m="
          sections that do not contain an "a=bundle-only"
          attribute.)</t>
          <ul spacing="normal">
            <li>"a=ice-ufrag" and "a=ice-pwd" lines, as specified in
              <xref target="RFC8839" sectionFormat="comma" section="5.4"/>.</li>
            <li>For each desired digest algorithm, one or more
              "a=fingerprint" lines for each of the endpoint's
              certificates, as specified in
              <xref target="RFC8122" sectionFormat="comma" section="5"/>.</li>
            <li>An "a=setup" line, as specified in
              <xref target="RFC4145" sectionFormat="comma" section="4"/> and clarified
              for use in DTLS-SRTP scenarios in
              <xref target="RFC5763" sectionFormat="comma" section="5"/>. The role value
              in the offer <bcp14>MUST</bcp14> be "actpass".</li>
            <li>An "a=tls-id" line, as specified in
              <xref target="RFC8842" sectionFormat="comma" section="5.2"/>.</li>
            <li>An "a=rtcp" line, as specified in
              <xref target="RFC3605" sectionFormat="comma" section="2.1"/>, containing
              the default value "9 IN IP4 0.0.0.0", because no candidates
              have yet been gathered.</li>
            <li>An "a=rtcp-mux" line, as specified in
              <xref target="RFC5761" sectionFormat="comma" section="5.1.3"/>.</li>
            <li>If the RTP/RTCP multiplexing policy is "require", an
              "a=rtcp-mux-only" line, as specified in
              <xref target="RFC8858" sectionFormat="comma" section="4"/>.</li>
            <li>An "a=rtcp-rsize" line, as specified in
              <xref target="RFC5506" sectionFormat="comma" section="5"/>.</li>
          </ul>
          <t>Lastly, if a data channel has been created, an "m=" section
          <bcp14>MUST</bcp14> be generated for data. The &lt;media&gt; field <bcp14>MUST</bcp14> be
          set to "application", and the &lt;proto&gt; field <bcp14>MUST</bcp14> be set
          to "UDP/DTLS/SCTP"
          <xref target="RFC8841" format="default"/>. The &lt;fmt&gt;
          value <bcp14>MUST</bcp14> be set to "webrtc-datachannel" as specified in
          <xref target="RFC8841" sectionFormat="comma" section="4.2.2"/>.
</t>
          <t>Within the data "m=" section, an "a=mid" line <bcp14>MUST</bcp14> be
          generated and included as described above, along with an
          "a=sctp-port" line referencing the SCTP port number, as
          defined in
          <xref target="RFC8841" sectionFormat="comma" section="5.1"/>;
          and, if appropriate, an "a=max-message-size" line, as defined
          in
          <xref target="RFC8841" sectionFormat="comma" section="6.1"/>.</t>
          <t>As discussed above, the following attributes of category
          IDENTICAL or TRANSPORT are included only if the data "m="
          section either has a unique address or is associated with the
          BUNDLE-tag (e.g., if it is the only "m=" section):
          </t>
          <ul spacing="normal">
            <li>"a=ice-ufrag"</li>
            <li>"a=ice-pwd"</li>
            <li>"a=fingerprint"</li>
            <li>"a=setup"</li>
            <li>"a=tls-id"</li>
          </ul>
          <t>Once all "m=" sections have been generated, a session-level
          "a=group" attribute <bcp14>MUST</bcp14> be added as specified in
          <xref target="RFC5888" format="default"/>. This attribute <bcp14>MUST</bcp14> have
          semantics "BUNDLE" and <bcp14>MUST</bcp14> include the mid identifiers of
          each "m=" section. The effect of this is that the JSEP
          implementation offers all "m=" sections as one bundle group.
          However, whether the "m=" sections are bundle-only or not
          depends on the bundle policy.</t>
          <t>The next step is to generate session-level lip sync groups
          as defined in
          <xref target="RFC5888" sectionFormat="comma" section="7"/>. For each MediaStream
          referenced by more than one RtpTransceiver (by passing those
          MediaStreams as arguments to the addTrack and addTransceiver
          methods), a group of type "LS" <bcp14>MUST</bcp14> be added that contains
          the MID values for each RtpTransceiver.</t>
          <t>Attributes that SDP permits to be at either the session
          level or the media level <bcp14>SHOULD</bcp14> generally be at the media
          level even if they are identical. This assists development
          and debugging by making it easier to understand individual
          media sections, especially if one of a set of initially
          identical attributes is subsequently changed. However,
          implementations <bcp14>MAY</bcp14> choose to aggregate attributes at the
          session level, and JSEP implementations <bcp14>MUST</bcp14> be prepared to
          receive attributes in either location.</t>
          <t>Attributes other than the ones specified above <bcp14>MAY</bcp14> be
          included, except for the following attributes, which are
          specifically incompatible with the requirements of
          <xref target="RFC8834" format="default"/> and <bcp14>MUST
          NOT</bcp14> be included:
          </t>
          <ul spacing="normal">
            <li>"a=crypto"</li>
            <li>"a=key-mgmt"</li>
            <li>"a=ice-lite"</li>
          </ul>
          <t>Note that when bundle is used, any additional attributes
          that are added <bcp14>MUST</bcp14> follow the advice in
          <xref target="RFC8859" format="default"/> on
          how those attributes interact with bundle.</t>
          <t>Note that these requirements are in some cases stricter
          than those of SDP. Implementations <bcp14>MUST</bcp14> be prepared to accept
          compliant SDP even if it would not conform to the
          requirements for generating SDP in this specification.</t>
        </section>
        <section anchor="sec.subsequent-offers" numbered="true" toc="default">
          <name>Subsequent Offers</name>
          <t>When createOffer is called a second (or later) time or is
          called after a local description has already been installed,
          the processing is somewhat different than for an initial
          offer.</t>
          <t>If the previous offer was not applied using
          setLocalDescription, meaning the PeerConnection is still in
          the "stable" state, the steps for generating an initial offer
          <bcp14>MUST</bcp14> be followed, subject to the following restriction:
          </t>
          <ul spacing="normal">
            <li>The fields of the "o=" line <bcp14>MUST</bcp14> stay the same except
            for the &lt;session-version&gt; field, which <bcp14>MUST</bcp14> increment
            by one on each call to createOffer if the offer might
            differ from the output of the previous call to createOffer;
            implementations <bcp14>MAY</bcp14> opt to increment
            &lt;session-version&gt; on every call. The value of the
            generated &lt;session-version&gt; is independent of the
            &lt;session-version&gt; of the current local description;
            in particular, in the case where the current version is N,
            an offer is created and applied with version N+1, and then
            that offer is rolled back so that the current version is
            again N, the next generated offer will still have version
            N+2.</li>
          </ul>
          <t>Note that if the application creates an offer by reading
          currentLocalDescription instead of calling createOffer, the
          returned SDP may be different than when setLocalDescription
          was originally called, due to the addition of gathered ICE
          candidates, but the &lt;session-version&gt; will not have
          changed. There are no known scenarios in which this causes
          problems, but if this is a concern, the solution is simply to
          use createOffer to ensure a unique
          &lt;session-version&gt;.</t>
          <t>If the previous offer was applied using
          setLocalDescription, but a corresponding answer from the
          remote side has not yet been applied, meaning the
          PeerConnection is still in the "have-local-offer" state, an
          offer is generated by following the steps in the "stable"
          state above, along with these exceptions:
          </t>
          <ul spacing="normal">
            <li>The "s=" and "t=" lines <bcp14>MUST</bcp14> stay the same.</li>
            <li>If any RtpTransceiver has been added and there exists
            an "m=" section with a zero port in the current local
            description or the current remote description, that "m="
            section <bcp14>MUST</bcp14> be recycled by generating an "m=" section for
            the added RtpTransceiver as if the "m=" section were being
            added to the session description (including a new MID
            value) and placing it at the same index as the "m=" section
            with a zero port.</li>
            <li>If an RtpTransceiver is stopped and is not associated
            with an "m=" section, an "m=" section <bcp14>MUST NOT</bcp14> be generated for
            it. This prevents adding back RtpTransceivers whose "m="
            sections were recycled and used for a new RtpTransceiver in
            a previous offer/ answer exchange, as described above.</li>
            <li>If an RtpTransceiver has been stopped and is associated
            with an "m=" section, and the "m=" section is not being
            recycled as described above, an "m=" section <bcp14>MUST</bcp14> be
            generated for it with the port set to zero and all "a=msid"
            lines removed.</li>
            <li>For RtpTransceivers that are not stopped, the "a=msid"
            line or lines <bcp14>MUST</bcp14> stay the same if they are present in the
            current description, regardless of changes to the
            transceiver's direction or track. If no "a=msid" line is
            present in the current description, "a=msid" line(s) <bcp14>MUST</bcp14>
            be generated according to the same rules as for an initial
            offer.</li>
            <li>Each "m=" and "c=" line <bcp14>MUST</bcp14> be filled in with the port,
            relevant RTP profile, and address of the default candidate for the
            "m=" section, as described in
            <xref target="RFC8839" sectionFormat="comma" section="4.2.1.2"/> and clarified in
            <xref target="sec.profile-names" format="default"/>.
            If no RTP candidates have yet been gathered, default
            values <bcp14>MUST</bcp14> still be used, as described above.</li>
            <li>Each "a=mid" line <bcp14>MUST</bcp14> stay the same.</li>
            <li>Each "a=ice-ufrag" and "a=ice-pwd" line <bcp14>MUST</bcp14> stay the
            same, unless the ICE configuration has changed (e.g., changes to
            either the supported STUN/TURN servers or the ICE
            candidate policy) or the IceRestart option
            (<xref target="sec.icerestart" format="default"/>) was specified.
            If the "m="
            section is bundled into another "m=" section, it still <bcp14>MUST
            NOT</bcp14> contain any ICE credentials.</li>
            <li>If the "m=" section is not bundled into another "m="
            section, its "a=rtcp" attribute line <bcp14>MUST</bcp14> be filled in with
            the port and address of the default RTCP candidate, as
            indicated in
            <xref target="RFC5761" sectionFormat="comma" section="5.1.3"/>. If no RTCP
            candidates have yet been gathered, default values <bcp14>MUST</bcp14> be
            used, as described in <xref target="sec.initial-offers"/> above.</li>

            <li>If the "m=" section is not bundled into another "m="
            section, for each candidate that has been gathered during
            the most recent gathering phase (see
            <xref target="sec.ice-gather-overview" format="default"/>), an
            "a=candidate" line <bcp14>MUST</bcp14> be added, as defined in
            <xref target="RFC8839" sectionFormat="comma" section="5.1"/>.
            If candidate gathering for the section has completed, an
            "a=end-of-candidates" attribute <bcp14>MUST</bcp14> be added, as described
            in
            <xref target="RFC8840" sectionFormat="comma" section="8.2"/>.
            If the "m=" section is bundled into another "m=" section, both
            "a=candidate" and "a=end-of-candidates" <bcp14>MUST</bcp14> be
            omitted.
</li>
            <li>For RtpTransceivers that are still present, the "a=rid"
            lines <bcp14>MUST</bcp14> stay the same.</li>
            <li>For RtpTransceivers that are still present, any
            "a=simulcast" line <bcp14>MUST</bcp14> stay the same.</li>
          </ul>
          <t>If the previous offer was applied using
          setLocalDescription, and a corresponding answer from the
          remote side has been applied using setRemoteDescription,
          meaning the PeerConnection is in the "have-remote-pranswer"
          state or the "stable" state, an offer is generated based on the
          negotiated session descriptions by following the steps
          mentioned for the "have-local-offer" state above.</t>
          <t>In addition, for each existing, non-recycled, non-rejected
          "m=" section in the new offer, the following adjustments are
          made based on the contents of the corresponding "m=" section in
          the current local or remote description, as appropriate:
          </t>
          <ul spacing="normal">
            <li>The "m=" line and corresponding "a=rtpmap" and "a=fmtp"
            lines <bcp14>MUST</bcp14> only include media formats that have not been
            excluded by the codec preferences of the associated
            transceiver and also <bcp14>MUST</bcp14> include all currently available
            formats. Media formats that were previously offered but are
            no longer available (e.g., a shared hardware codec) <bcp14>MAY</bcp14> be
            excluded.</li>
            <li>Unless codec preferences have been set for the
            associated transceiver, the media formats on the "m=" line
            <bcp14>MUST</bcp14> be generated in the same order as in the most recent
            answer. Any media formats that were not present in the most
            recent answer <bcp14>MUST</bcp14> be added after all existing formats.</li>
            <li>The RTP header extensions <bcp14>MUST</bcp14> only include those that
            are present in the most recent answer.</li>
            <li>The RTCP feedback mechanisms <bcp14>MUST</bcp14> only include those
            that are present in the most recent answer, except for the
            case of format-specific mechanisms that are referencing a
            newly added media format.</li>
            <li>The "a=rtcp" line <bcp14>MUST NOT</bcp14> be added if the most recent
            answer included an "a=rtcp-mux" line.</li>
            <li>The "a=rtcp-mux" line <bcp14>MUST</bcp14> be the same as that in the
            most recent answer.</li>
            <li>The "a=rtcp-mux-only" line <bcp14>MUST NOT</bcp14> be added.</li>
            <li>The "a=rtcp-rsize" line <bcp14>MUST NOT</bcp14> be added unless present
            in the most recent answer.</li>
            <li>An "a=bundle-only" line, as defined in
            <xref target="RFC8843" sectionFormat="comma" section="6"/>,
            <bcp14>MUST NOT</bcp14> be added.
            Instead, JSEP implementations <bcp14>MUST</bcp14> simply omit
            parameters in the IDENTICAL and TRANSPORT categories for
            bundled "m=" sections, as described in
            <xref target="RFC8843" sectionFormat="comma" section="7.1.3"/>.</li>
            <li>Note that if media "m=" sections are bundled into a data
            "m=" section, then certain TRANSPORT and IDENTICAL attributes
            may appear in the data "m=" section even if they would
            otherwise only be appropriate for a media "m=" section (e.g.,
            "a=rtcp-mux"). This cannot happen in initial offers because
            in the initial offer JSEP implementations always list media
            "m=" sections (if any) before the data "m=" section (if any),
            and at least one of those media "m=" sections will not have
            the "a=bundle-only" attribute. Therefore, in initial
            offers, any "a=bundle-only" "m=" sections will be bundled
            into a preceding non-bundle-only media "m=" section.</li>
          </ul>
          <t>The "a=group:BUNDLE" attribute <bcp14>MUST</bcp14> include the MID
          identifiers specified in the bundle group in the most recent
          answer, minus any "m=" sections that have been marked as
          rejected, plus any newly added or re-enabled "m=" sections. In
          other words, the bundle attribute <bcp14>MUST</bcp14> contain all "m="
          sections that were previously bundled, as long as they are
          still alive, as well as any new "m=" sections.</t>
          <t>Note that if bundling has been negotiated, unbundling is no longer
          possible, and media sections will not be marked as bundle-only. This is
          by design, but could cause issues in the rare case of sending a 
          subsequent offer as an initial offer to a non-bundle-aware endpoint
          via Third Party Call Control (3PCC).</t>
          <t>"a=group:LS" attributes are generated in the same way as
          for initial offers, with the additional stipulation that any
          lip sync groups that were present in the most recent answer
          <bcp14>MUST</bcp14> continue to exist and <bcp14>MUST</bcp14> contain any previously
          existing MID identifiers, as long as the identified "m="
          sections still exist and are not rejected, and the group
          still contains at least two MID identifiers. This ensures
          that any synchronized "recvonly" "m=" sections continue to be
          synchronized in the new offer.</t>
        </section>
        <section anchor="sec.options-handling1" numbered="true" toc="default">
          <name>Options Handling</name>
          <t>The createOffer method takes as a parameter an
          RTCOfferOptions object. Special processing is performed when
          generating an SDP description if the following options are
          present.</t>
          <section anchor="sec.icerestart" numbered="true" toc="default">
            <name>IceRestart</name>
            <t>If the IceRestart option is specified, with a value of
            "true", the offer <bcp14>MUST</bcp14> indicate an ICE restart by
            generating new ICE ufrag and pwd attributes, as specified
            in
            <xref target="RFC8839" sectionFormat="comma" section="4.4.3.1.1"/>. If this
            option is specified on an initial offer, it has no effect
            (since a new ICE ufrag and pwd are already generated).
            Similarly, if the ICE configuration has changed, this
            option has no effect, since new ufrag and pwd attributes
            will be generated automatically. This option is primarily
            useful for reestablishing connectivity in cases where
            failures are detected by the application.</t>
          </section>
          <section anchor="sec.voiceactivitydetection1" numbered="true" toc="default">
            <name>VoiceActivityDetection</name>
            <t>Silence suppression, also known as discontinuous
            transmission ("DTX"), can reduce the bandwidth used for
            audio by switching to a special encoding when voice
            activity is not detected, at the cost of some fidelity.</t>
            <t>If the "VoiceActivityDetection" option is specified,
            with a value of "true", the offer <bcp14>MUST</bcp14> indicate support for
            silence suppression in the audio it receives by including
            comfort noise ("CN") codecs for each offered audio codec,
            as specified in
            <xref target="RFC3389" sectionFormat="comma" section="5.1"/>, except for
            codecs that have their own internal silence suppression
            support. For codecs that have their own internal silence
            suppression support, the appropriate fmtp parameters for
            that codec <bcp14>MUST</bcp14> be specified to indicate that silence
            suppression for received audio is desired. For example,
            when using the Opus codec
            <xref target="RFC6716" format="default"/>, the "usedtx=1" parameter,
            specified in
            <xref target="RFC7587" format="default"/>, would be used in the offer.</t>
            <t>If the "VoiceActivityDetection" option is specified,
            with a value of "false", the JSEP implementation <bcp14>MUST NOT</bcp14>
            emit "CN" codecs. For codecs that have their own internal
            silence suppression support, the appropriate fmtp
            parameters for that codec <bcp14>MUST</bcp14> be specified to indicate
            that silence suppression for received audio is not desired.
            For example, when using the Opus codec, the "usedtx=0"
            parameter would be specified in the offer. In addition, the
            implementation <bcp14>MUST NOT</bcp14> use silence suppression for media
            it generates, regardless of whether the "CN" codecs or
            related fmtp parameters appear in the peer's description.
            The impact of these rules is that silence suppression in
            JSEP depends on mutual agreement of both sides, which
            ensures consistent handling regardless of which codec is
            used.</t>
            <t>The "VoiceActivityDetection" option does not have any
            impact on the setting of the "vad" value in the signaling
            of the client-to-mixer audio level header extension
            described in
            <xref target="RFC6464" sectionFormat="comma" section="4"/>.</t>
          </section>
        </section>
      </section>
      <section anchor="sec.generating-an-answer" numbered="true" toc="default">
        <name>Generating an Answer</name>
        <t>When createAnswer is called, a new SDP description <bcp14>MUST</bcp14> be
        created that is compatible with the supplied remote description
        as well as the requirements specified in
        <xref target="RFC8834" format="default"/>. The exact
        details of this process are explained below.</t>
        <section anchor="sec.initial-answers" numbered="true" toc="default">
          <name>Initial Answers</name>
          <t>When createAnswer is called for the first time after a
          remote description has been provided, the result is known as
          the initial answer. If no remote description has been
          installed, an answer cannot be generated, and an error <bcp14>MUST</bcp14>
          be returned.</t>
          <t>Note that the remote description SDP may not have been
          created by a JSEP endpoint and may not conform to all the
          requirements listed in
          <xref target="sec-create-offer" format="default"/>. For many cases, this
          is not a problem. However, if any mandatory SDP attributes
          are missing or functionality listed as mandatory-to-use
          above is not present, this <bcp14>MUST</bcp14> be treated as an error and
          <bcp14>MUST</bcp14> cause the affected "m=" sections to be marked as
          rejected.</t>

          <t>The first step in generating an initial answer is to
          generate session-level attributes. The process here is
          identical to that indicated in <xref target="sec.initial-offers"/> above, except that the "a=ice-options" line, with the
          "trickle" option as specified in
          <xref target="RFC8840" sectionFormat="comma" section="4.1.3"/>
          and the "ice2" option as specified in
          <xref target="RFC8445" sectionFormat="comma" section="10"/>, is
          only included if such an option was present in the offer.</t>
          <t>The next step is to generate session-level lip sync
          groups, as defined in
          <xref target="RFC5888" sectionFormat="comma" section="7"/>. For each group of type
          "LS" present in the offer, select the local RtpTransceivers
          that are referenced by the MID values in the specified group,
          and determine which of them either reference a common local
          MediaStream (specified in the calls to
          addTrack/addTransceiver used to create them) or have no
          MediaStream to reference because they were not created by
          addTrack/addTransceiver. If at least two such RtpTransceivers
          exist, a group of type "LS" with the MID values of these
          RtpTransceivers <bcp14>MUST</bcp14> be added. Otherwise, the offered "LS"
          group <bcp14>MUST</bcp14> be ignored and no corresponding group generated in
          the answer.</t>
          <t>As a simple example, consider the following offer of a
          single audio and single video track contained in the same
          MediaStream. SDP lines not relevant to this example have been
          removed for clarity. As explained in
          <xref target="sec-create-offer" format="default"/>, a group of type "LS" has
          been added that references each track's RtpTransceiver.</t>
          <sourcecode name="" type="sdp"><![CDATA[
          a=group:LS a1 v1
          m=audio 10000 UDP/TLS/RTP/SAVPF 0
          a=mid:a1
          a=msid:ms1
          m=video 10001 UDP/TLS/RTP/SAVPF 96
          a=mid:v1
          a=msid:ms1 ]]></sourcecode>
          <t>If the answerer uses a single MediaStream when it adds its
          tracks, both of its transceivers will reference this stream,
          and so the subsequent answer will contain a "LS" group
          identical to that in the offer, as shown below:</t>
          <sourcecode name="" type="sdp"><![CDATA[
          a=group:LS a1 v1
          m=audio 20000 UDP/TLS/RTP/SAVPF 0
          a=mid:a1
          a=msid:ms2
          m=video 20001 UDP/TLS/RTP/SAVPF 96
          a=mid:v1
          a=msid:ms2 ]]></sourcecode>
          <t>However, if the answerer groups its tracks into separate
          MediaStreams, its transceivers will reference different
          streams, and so the subsequent answer will not contain a "LS"
          group.</t>
          <sourcecode name="" type="sdp"><![CDATA[
          m=audio 20000 UDP/TLS/RTP/SAVPF 0
          a=mid:a1
          a=msid:ms2a
          m=video 20001 UDP/TLS/RTP/SAVPF 96
          a=mid:v1
          a=msid:ms2b ]]></sourcecode>
          <t>Finally, if the answerer does not add any tracks, its
          transceivers will not reference any MediaStreams, causing the
          preferences of the offerer to be maintained, and so the
          subsequent answer will contain an identical "LS" group.</t>
          <sourcecode name="" type="sdp"><![CDATA[
          a=group:LS a1 v1
          m=audio 20000 UDP/TLS/RTP/SAVPF 0
          a=mid:a1
          a=recvonly
          m=video 20001 UDP/TLS/RTP/SAVPF 96
          a=mid:v1
          a=recvonly ]]></sourcecode>
          <t>The example in <xref target="sec.detailed-example" format="default"/> shows a more involved case of "LS" group
          generation.</t>
          <t>The next step is to generate a "m=" section for each "m="
          section that is present in the remote offer, as specified in
          <xref target="RFC3264" sectionFormat="comma" section="6"/>. For the purposes
          of this discussion, any session-level attributes in the offer
          that are also valid as media-level attributes are considered
          to be present in each "m=" section. Each offered "m=" section
          will have an associated RtpTransceiver, as described in
          <xref target="sec.applying-a-remote-desc" format="default"/>. If there are
          more RtpTransceivers than there are "m=" sections, the
          unmatched RtpTransceivers will need to be associated in a
          subsequent offer.</t>
          <t>For each offered "m=" section, if any of the following
          conditions are true, the corresponding "m=" section in the
          answer <bcp14>MUST</bcp14> be marked as rejected by setting the &lt;port&gt; in the
          "m=" line to zero, as indicated in
          <xref target="RFC3264" sectionFormat="comma" section="6"/>, and further
          processing for this "m=" section can be skipped:
          </t>
          <ul spacing="normal">
            <li>The associated RtpTransceiver has been stopped.</li>
            <li>There is no offered media format that is both supported
            and, if applicable, allowed by codec preferences.</li>
            <li>The bundle policy is "must-bundle", and this is not the
            first "m=" section or in the same bundle group as the first
            "m=" section.</li>
            <li>The bundle policy is "balanced", and this is not the
            first "m=" section for this media type or in the same bundle
            group as the first "m=" section for this media type.</li>
            <li>This "m=" section is in a bundle group, and the group's
            offerer tagged "m=" section is being rejected due to one of
            the above reasons. This requires all "m=" sections in the
            bundle group to be rejected, as specified in
            <xref target="RFC8843" sectionFormat="comma" section="7.3.3"/>.</li>
          </ul>
          <t>Otherwise, each "m=" section in the answer <bcp14>MUST</bcp14> then be
          generated as specified in
          <xref target="RFC3264" sectionFormat="comma" section="6.1"/>. For the "m=" line
          itself, the following rules <bcp14>MUST</bcp14> be followed:</t>
          <ul spacing="normal">
            <li>The &lt;port&gt; value would normally be set to the port of the
            default ICE candidate for this "m=" section, but given that
            no candidates are available yet, the default &lt;port&gt; value of
            9 (Discard) <bcp14>MUST</bcp14> be used, as indicated in
            <xref target="RFC8840" sectionFormat="comma" section="4.1.1"/>.</li>
            <li>The &lt;proto&gt; field <bcp14>MUST</bcp14> be set to exactly match the
            &lt;proto&gt; field for the corresponding "m=" line in the
            offer.</li>
            <li>If codec preferences have been set for the associated
            transceiver, media formats <bcp14>MUST</bcp14> be generated in the
            corresponding order, regardless of what was offered, and
            <bcp14>MUST</bcp14> exclude any codecs not present in the codec
            preferences.</li>
            <li>Otherwise, the media formats on the "m=" line <bcp14>MUST</bcp14> be
            generated in the same order as those offered in the current
            remote description, excluding any currently unsupported
            formats. Any currently available media formats that are not
            present in the current remote description <bcp14>MUST</bcp14> be added
            after all existing formats.</li>
            <li>In either case, the media formats in the answer <bcp14>MUST</bcp14>
            include at least one format that is present in the offer
            but <bcp14>MAY</bcp14> include formats that are locally supported but not
            present in the offer, as mentioned in
            <xref target="RFC3264" sectionFormat="comma" section="6.1"/>. If no common format
            exists, the "m=" section is rejected as described above.</li>
          </ul>

          <t>The "m=" line <bcp14>MUST</bcp14> be followed immediately by a "c=" line,
          as specified in
          <xref target="RFC4566" sectionFormat="comma" section="5.7"/>. Again, as no
          candidates are available yet, the "c=" line <bcp14>MUST</bcp14> contain the
          default value "IN IP4 0.0.0.0", as defined in
          <xref target="RFC8840" sectionFormat="comma" section="4.1.3"/>.</t>
          <t>If the offer supports bundle, all "m=" sections to be
          bundled <bcp14>MUST</bcp14> use the same ICE credentials and candidates; all
          "m=" sections not being bundled <bcp14>MUST</bcp14> use unique ICE credentials
          and candidates. Each "m=" section <bcp14>MUST</bcp14> contain the following
          attributes (which are of attribute types other than IDENTICAL
          or TRANSPORT):
          </t>
          <ul spacing="normal">
            <li>If and only if present in the offer, an "a=mid" line, as
            specified in
            <xref target="RFC5888" sectionFormat="comma" section="9.1"/>. The MID
            value <bcp14>MUST</bcp14> match that specified in the offer.</li>
            <li>A direction attribute, determined by applying the rules
            regarding the offered direction specified in
            <xref target="RFC3264" sectionFormat="comma" section="6.1"/>, and then
            intersecting with the direction of the associated
            RtpTransceiver. For example, in the case where an "m="
            section is offered as "sendonly" and the local transceiver
            is set to "sendrecv", the result in the answer is a
            "recvonly" direction.</li>
            <li>For each media format on the "m=" line, "a=rtpmap" and "a=fmtp" lines, as specified in
            <xref target="RFC4566" sectionFormat="comma" section="6"/> and
            <xref target="RFC3264" sectionFormat="comma" section="6.1"/>.</li>
            <li>If "rtx" is present in the offer, for each primary codec
            where RTP retransmission should be used, a corresponding
            "a=rtpmap" line indicating "rtx" with the clock rate of the
            primary codec and an "a=fmtp" line that references the
            payload type of the primary codec, as specified in
            <xref target="RFC4588" sectionFormat="comma" section="8.1"/>.</li>
            <li>For each supported FEC mechanism, "a=rtpmap" and
            "a=fmtp" lines, as specified in
            <xref target="RFC4566" sectionFormat="comma" section="6"/>. The FEC
            mechanisms that <bcp14>MUST</bcp14> be supported are specified in
            <xref target="RFC8854" sectionFormat="comma" section="7"/>, and
            specific usage for each media type is outlined in Sections
            <xref target="sec.interface" format="counter"/> and <xref
            target="sec.sdp-interaction-procedure" format="counter"/>.</li>
            <li>If this "m=" section is for media with configurable
            durations of media per packet, e.g., audio, an "a=maxptime"
            line, as described in
            <xref target="sec-create-offer" format="default"/>.</li>
            <li>If this "m=" section is for video media and there are
            known limitations on the size of images that can be
            decoded, an "a=imageattr" line, as specified in
            <xref target="sec.imageattr" format="default"/>.</li>
            <li>For each supported RTP header extension that is present
            in the offer, an "a=extmap" line, as specified in
            <xref target="RFC5285" sectionFormat="comma" section="5"/>. The list of
            header extensions that <bcp14>SHOULD</bcp14>/<bcp14>MUST</bcp14> be supported is
            specified in
            <xref target="RFC8834" sectionFormat="comma" section="5.2"/>. Any header extensions that require encryption <bcp14>MUST</bcp14> be
            specified as indicated in
            <xref target="RFC6904" sectionFormat="comma" section="4"/>.</li>
            <li>For each supported RTCP feedback mechanism that is
            present in the offer, an "a=rtcp-fb" line, as specified in
            <xref target="RFC4585" sectionFormat="comma" section="4.2"/>. The list of
            RTCP feedback mechanisms that <bcp14>SHOULD</bcp14>/<bcp14>MUST</bcp14> be supported is
            specified in
            <xref target="RFC8834" sectionFormat="comma" section="5.1"/>.</li>
            <li>
              <t>If the RtpTransceiver has a sendrecv or sendonly
            direction:
              </t>
              <ul spacing="normal">
                <li>For each MediaStream that was associated with the
              transceiver when it was created via addTrack or
              addTransceiver, an "a=msid" line, as specified in
              <xref target="RFC8830" sectionFormat="comma" section="2"/>,
              but omitting the "appdata" field.</li>
              </ul>
            </li>
          </ul>
          <t>Each "m=" section that is not bundled into another "m="
          section <bcp14>MUST</bcp14> contain the following attributes (which are of
          category IDENTICAL or TRANSPORT):</t>
          <ul spacing="normal">
            <li>"a=ice-ufrag" and "a=ice-pwd" lines, as specified in
              <xref target="RFC8839" sectionFormat="comma" section="5.4"/>.</li>
            <li>For each desired digest algorithm, one or more
              "a=fingerprint" lines for each of the endpoint's
              certificates, as specified in
              <xref target="RFC8122" sectionFormat="comma" section="5"/>.</li>
            <li>An "a=setup" line, as specified in
              <xref target="RFC4145" sectionFormat="comma" section="4"/> and clarified
              for use in DTLS-SRTP scenarios in
              <xref target="RFC5763" sectionFormat="comma" section="5"/>. The role value
              in the answer <bcp14>MUST</bcp14> be "active" or "passive". When the
              offer contains the "actpass" value, as will always be the
              case with JSEP endpoints, the answerer <bcp14>SHOULD</bcp14> use the
              "active" role. Offers from non-JSEP endpoints <bcp14>MAY</bcp14> send
              other values for "a=setup", in which case the answer <bcp14>MUST</bcp14>
              use a value consistent with the value in the offer.</li>
            <li>An "a=tls-id" line, as specified in
              <xref target="RFC8842" sectionFormat="comma" section="5.3"/>.</li>
            <li>If present in the offer, an "a=rtcp-mux" line, as
              specified in
              <xref target="RFC5761" sectionFormat="comma" section="5.1.3"/>. Otherwise,
              an "a=rtcp" line, as specified in
              <xref target="RFC3605" sectionFormat="comma" section="2.1"/>, containing
              the default value "9 IN IP4 0.0.0.0" (because no candidates
              have yet been gathered).</li>
            <li>If present in the offer, an "a=rtcp-rsize" line, as
              specified in
              <xref target="RFC5506" sectionFormat="comma" section="5"/>.</li>
          </ul>
          <t>If a data channel "m=" section has been offered, an "m="
          section <bcp14>MUST</bcp14> also be generated for data. The &lt;media&gt;
          field <bcp14>MUST</bcp14> be set to "application", and the &lt;proto&gt; and
          &lt;fmt&gt; fields <bcp14>MUST</bcp14> be set to exactly match the fields in
          the offer.</t>
          <t>Within the data "m=" section, an "a=mid" line <bcp14>MUST</bcp14> be
          generated and included as described above, along with an
          "a=sctp-port" line referencing the SCTP port number, as
          defined in
          <xref target="RFC8841" sectionFormat="comma" section="5.1"/>;
          and, if appropriate, an "a=max-message-size" line, as defined
          in
          <xref target="RFC8841" sectionFormat="comma" section="6.1"/>.</t>
          <t>As discussed above, the following attributes of category
          IDENTICAL or TRANSPORT are included only if the data "m="
          section is not bundled into another "m=" section:
          </t>
          <ul spacing="normal">
            <li>"a=ice-ufrag"</li>
            <li>"a=ice-pwd"</li>
            <li>"a=fingerprint"</li>
            <li>"a=setup"</li>
            <li>"a=tls-id"</li>
          </ul>
          <t>Note that if media "m=" sections are bundled into a data "m="
          section, then certain TRANSPORT and IDENTICAL attributes may
          also appear in the data "m=" section even if they would
          otherwise only be appropriate for a media "m=" section (e.g.,
          "a=rtcp-mux").</t>
          <t>If "a=group" attributes with semantics of "BUNDLE" are
          offered, corresponding session-level "a=group" attributes
          <bcp14>MUST</bcp14> be added as specified in
          <xref target="RFC5888" format="default"/>. These attributes <bcp14>MUST</bcp14> have
          semantics "BUNDLE" and <bcp14>MUST</bcp14> include all mid identifiers
          from the offered bundle groups that have not been rejected.
          Note that regardless of the presence of "a=bundle-only" in
          the offer, all "m=" sections in the answer <bcp14>MUST NOT</bcp14> have an
          "a=bundle-only" line.</t>
          <t>Attributes that are common between all "m=" sections <bcp14>MAY</bcp14> be
          moved to the session level if explicitly defined to be valid at
          the session level.</t>
          <t>The attributes prohibited in the creation of offers are
          also prohibited in the creation of answers.</t>
        </section>
        <section anchor="sec.subsequent-answers" numbered="true" toc="default">
          <name>Subsequent Answers</name>
          <t>When createAnswer is called a second (or later) time or
          is called after a local description has already been
          installed, the processing is somewhat different than for an
          initial answer.</t>
          <t>If the previous answer was not applied using
          setLocalDescription, meaning the PeerConnection is still in
          the "have-remote-offer" state, the steps for generating an
          initial answer <bcp14>MUST</bcp14> be followed, subject to the following
          restriction:
          </t>
          <ul spacing="normal">
            <li>The fields of the "o=" line <bcp14>MUST</bcp14> stay the same except
            for the &lt;session-version&gt; field, which <bcp14>MUST</bcp14> increment
            if the session description changes in any way from the
            previously generated answer.</li>
          </ul>
          <t>If any session description was previously supplied to
          setLocalDescription, an answer is generated by following the
          steps in the "have-remote-offer" state above, along with
          these exceptions:
          </t>
          <ul spacing="normal">
            <li>The "s=" and "t=" lines <bcp14>MUST</bcp14> stay the same.</li>
            <li>Each "m=" and "c=" line <bcp14>MUST</bcp14> be filled in with the port
            and address of the default candidate for the "m=" section, as
            described in
            <xref target="RFC8839" sectionFormat="comma" section="4.2.1.2"/>. Note that in certain cases, the "m=" line protocol
            may not match that of the default candidate, because the "m=" line
            protocol value <bcp14>MUST</bcp14> match what was supplied in the offer, as
            described above.</li>
            <li>Each "a=ice-ufrag" and "a=ice-pwd" line <bcp14>MUST</bcp14> stay the
            same, unless the "m=" section is restarting, in which case
            new ICE credentials <bcp14>MUST</bcp14> be created as specified in
            <xref target="RFC8839" sectionFormat="comma" section="4.4.1.1.1"/>. If the "m="
            section is bundled into another "m=" section, it still <bcp14>MUST
            NOT</bcp14> contain any ICE credentials.</li>
            <li>Each "a=tls-id" line <bcp14>MUST</bcp14> stay the same, unless the
            offerer's "a=tls-id" line changed, in which case a new
            tls-id value <bcp14>MUST</bcp14> be created, as described in
            <xref target="RFC8842" sectionFormat="comma" section="5.2"/>.</li>
            <li>Each "a=setup" line <bcp14>MUST</bcp14> use an "active" or "passive"
            role value consistent with the existing DTLS association,
            if the association is being continued by the offerer.</li>
            <li>RTCP multiplexing <bcp14>MUST</bcp14> be used, and an "a=rtcp-mux" line
            inserted if and only if the "m=" section previously used RTCP
            multiplexing.</li>
            <li>If the "m=" section is not bundled into another "m=" section
            and RTCP multiplexing is not active, an "a=rtcp" attribute
            line <bcp14>MUST</bcp14> be filled in with the port and address of the
            default RTCP candidate. If no RTCP candidates have yet been
            gathered, default values <bcp14>MUST</bcp14> be used, as described in
            <xref target="sec.initial-answers"/> above.</li>

            <li>If the "m=" section is not bundled into another "m="
            section, for each candidate that has been gathered during
            the most recent gathering phase (see
            <xref target="sec.ice-gather-overview" format="default"/>), an
            "a=candidate" line <bcp14>MUST</bcp14> be added, as defined in
            <xref target="RFC8839" sectionFormat="comma" section="5.1"/>.
            If candidate gathering for the section has completed, an
            "a=end-of-candidates" attribute <bcp14>MUST</bcp14> be added, as described
            in
            <xref target="RFC8840" sectionFormat="comma" section="8.2"/>.
            If the "m=" section is bundled into another "m=" section, both
            "a=candidate" and "a=end-of-candidates" <bcp14>MUST</bcp14> be
            omitted.
</li>
            <li>For RtpTransceivers that are not stopped, the "a=msid"
            line(s) <bcp14>MUST</bcp14> stay the same, regardless of changes to the
            transceiver's direction or track. If no "a=msid" line is
            present in the current description, "a=msid" line(s) <bcp14>MUST</bcp14>
            be generated according to the same rules as for an initial
            answer.</li>
          </ul>
        </section>
        <section anchor="sec.options-handling2" numbered="true" toc="default">
          <name>Options Handling</name>
          <t>The createAnswer method takes as a parameter an
          RTCAnswerOptions object. The set of parameters for
          RTCAnswerOptions is different than those supported in
          RTCOfferOptions; the IceRestart option is unnecessary, as ICE
          credentials will automatically be changed for all "m=" sections
          where the offerer chose to perform ICE restart.</t>
          <t>The following options are supported in
          RTCAnswerOptions.</t>
          <section anchor="sec.voiceactivitydetection2" numbered="true" toc="default">
            <name>VoiceActivityDetection</name>
            <t>Silence suppression in the answer is handled as
            described in
            <xref target="sec.voiceactivitydetection1" format="default"/>, with
            one exception: if support for silence suppression was not
            indicated in the offer, the VoiceActivityDetection
            parameter has no effect, and the answer <bcp14>MUST</bcp14> be generated
            as if VoiceActivityDetection was set to "false". This is done
            on a per-codec basis (e.g., if the offerer somehow offered
            support for CN but set "usedtx=0" for Opus, setting
            VoiceActivityDetection to "true" would result in an answer
            with CN codecs and "usedtx=0"). The impact of this rule is
            that an answerer will not try to use silence suppression
            with any endpoint that does not offer it, making silence
            suppression support bilateral even with non-JSEP
            endpoints.</t>
          </section>
        </section>
      </section>
      <section anchor="sec.modifying-sdp" numbered="true" toc="default">
        <name>Modifying an Offer or Answer</name>
        <t>The SDP returned from createOffer or createAnswer <bcp14>MUST NOT</bcp14>
        be changed before passing it to setLocalDescription. If precise
        control over the SDP is needed, the aforementioned
        createOffer/createAnswer options or RtpTransceiver APIs <bcp14>MUST</bcp14> be
        used.</t>
        <t>After calling setLocalDescription with an offer or answer,
        the application <bcp14>MAY</bcp14> modify the SDP to reduce its capabilities
        before sending it to the far side, as long as it follows the
        rules above that define a valid JSEP offer or answer. Likewise,
        an application that has received an offer or answer from a peer
        <bcp14>MAY</bcp14> modify the received SDP, subject to the same constraints,
        before calling setRemoteDescription.</t>
        <t>As always, the application is solely responsible for what it
        sends to the other party, and all incoming SDP will be
        processed by the JSEP implementation to the extent of its
        capabilities. It is an error to assume that all SDP is
        well formed; however, one should be able to assume that any
        implementation of this specification will be able to process,
        as a remote offer or answer, unmodified SDP coming from any
        other implementation of this specification.</t>
      </section>
      <section anchor="sec.processing-a-local-desc" numbered="true" toc="default">
        <name>Processing a Local Description</name>
        <t>When a SessionDescription is supplied to
        setLocalDescription, the following steps <bcp14>MUST</bcp14> be performed:
        </t>
        <ul spacing="normal">
          <li>If the description is of type "rollback", follow the
          processing defined in
          <xref target="sec.processing-a-rollback" format="default"/> and skip the
          processing described in the rest of this section.</li>
          <li>
            <t>Otherwise, the type of the SessionDescription is checked
          against the current state of the PeerConnection:
            </t>
            <ul spacing="normal">
              <li>If the type is "offer", the PeerConnection state <bcp14>MUST</bcp14> be
            either "stable" or "have-local-offer".</li>
              <li>If the type is "pranswer" or "answer", the
            PeerConnection state <bcp14>MUST</bcp14> be either "have-remote-offer" or
            "have-local-pranswer".</li>
            </ul>
          </li>
          <li>If the type is not correct for the current state,
          processing <bcp14>MUST</bcp14> stop and an error <bcp14>MUST</bcp14> be returned.</li>
          <li>The SessionDescription is then checked to ensure that its
          contents are identical to those generated in the last call to
          createOffer/createAnswer, and thus have not been altered, as
          discussed in
          <xref target="sec.modifying-sdp" format="default"/>; otherwise, processing
          <bcp14>MUST</bcp14> stop and an error <bcp14>MUST</bcp14> be returned.</li>
          <li>Next, the SessionDescription is parsed into a data
          structure, as described in
          <xref target="sec.parsing-a-desc" format="default"/> below.</li>
          <li>Finally, the parsed SessionDescription is applied as
          described in
          <xref target="sec.applying-a-local-desc" format="default"/> below.</li>
        </ul>
      </section>
      <section anchor="sec.processing-a-remote-desc" numbered="true" toc="default">
        <name>Processing a Remote Description</name>
        <t>When a SessionDescription is supplied to
        setRemoteDescription, the following steps <bcp14>MUST</bcp14> be performed:
        </t>
        <ul spacing="normal">
          <li>If the description is of type "rollback", follow the
          processing defined in
          <xref target="sec.processing-a-rollback" format="default"/> and skip the
          processing described in the rest of this section.</li>
          <li>
            <t>Otherwise, the type of the SessionDescription is checked
          against the current state of the PeerConnection:
            </t>
            <ul spacing="normal">
              <li>If the type is "offer", the PeerConnection state <bcp14>MUST</bcp14> be
            either "stable" or "have-remote-offer".</li>
              <li>If the type is "pranswer" or "answer", the
            PeerConnection state <bcp14>MUST</bcp14> be either "have-local-offer" or
            "have-remote-pranswer".</li>
            </ul>
          </li>
          <li>If the type is not correct for the current state,
          processing <bcp14>MUST</bcp14> stop and an error <bcp14>MUST</bcp14> be returned.</li>
          <li>Next, the SessionDescription is parsed into a data
          structure, as described in
          <xref target="sec.parsing-a-desc" format="default"/> below. If parsing fails
          for any reason, processing <bcp14>MUST</bcp14> stop and an error <bcp14>MUST</bcp14> be
          returned.</li>
          <li>Finally, the parsed SessionDescription is applied as
          described in
          <xref target="sec.applying-a-remote-desc" format="default"/> below.</li>
        </ul>
      </section>
      <section anchor="sec.processing-a-rollback" numbered="true" toc="default">
        <name>Processing a Rollback</name>
        <t>A rollback may be performed if the PeerConnection is in any
        state except for "stable". This means that both offers and
        provisional answers can be rolled back. Rollback can only be
        used to cancel proposed changes; there is no support for
        rolling back from a "stable" state to a previous "stable" state. If
        a rollback is attempted in the "stable" state, processing <bcp14>MUST</bcp14>
        stop and an error <bcp14>MUST</bcp14> be returned. Note that this implies that
        once the answerer has performed setLocalDescription with its
        answer, this cannot be rolled back.</t>
        <t>The effect of rollback <bcp14>MUST</bcp14> be the same regardless of
        whether setLocalDescription or setRemoteDescription is
        called.</t>
        <t>In order to process rollback, a JSEP implementation abandons
        the current offer/answer transaction, sets the signaling state
        to "stable", and sets the pending local and/or remote
        description (see Sections
        <xref target="sec.pendinglocaldescription" format="counter"/> and
        <xref target="sec.pendingremotedescription" format="counter"/>) to "null". Any
        resources or candidates that were allocated by the abandoned
        local description are discarded; any media that is received is
        processed according to the previous local and remote
        descriptions.</t>
        <t>A rollback disassociates any RtpTransceivers that were
        associated with "m=" sections by the application of the
        rolled-back session description (see Sections
        <xref target="sec.applying-a-remote-desc" format="counter"/> and
        <xref target="sec.applying-a-local-desc" format="counter"/>).
        This means that
        some RtpTransceivers that were previously associated will no
        longer be associated with any "m=" section; in such cases, the
        value of the RtpTransceiver's mid property <bcp14>MUST</bcp14> be set to "null",
        and the mapping between the transceiver and its "m=" section
        index <bcp14>MUST</bcp14> be discarded. RtpTransceivers that were created by
        applying a remote offer that was subsequently rolled back <bcp14>MUST</bcp14>
        be stopped and removed from the PeerConnection. However, an
        RtpTransceiver <bcp14>MUST NOT</bcp14> be removed if a track was attached to
        the RtpTransceiver via the addTrack method. This is so that an
        application may call addTrack, then call setRemoteDescription
        with an offer, then roll back that offer, then call createOffer
        and have an "m=" section for the added track appear in the
        generated offer.</t>
      </section>
      <section anchor="sec.parsing-a-desc" numbered="true" toc="default">
        <name>Parsing a Session Description</name>
        <t>The SDP contained in the session description object consists
        of a sequence of text lines, each containing a key-value
        expression, as described in
        <xref target="RFC4566" sectionFormat="comma" section="5"/>. The SDP is read,
        line by line, and converted to a data structure that contains
        the deserialized information. However, SDP allows many types of
        lines, not all of which are relevant to JSEP applications. For
        each line, the implementation will first ensure that it is
        syntactically correct according to its defining ABNF, check
        that it conforms to the semantics used in
        <xref target="RFC4566" format="default"/> and
        <xref target="RFC3264" format="default"/>, and then either parse and
        store or discard the provided value, as described below.</t>
        <t>If any line is not well formed or cannot be parsed as
        described, the parser <bcp14>MUST</bcp14> stop with an error and reject the
        session description, even if the value is to be discarded. This
        ensures that implementations do not accidentally misinterpret
        ambiguous SDP.</t>
        <section anchor="sec.session-level-parse" numbered="true" toc="default">
          <name>Session-Level Parsing</name>
          <t>First, the session-level lines are checked and parsed.
          These lines <bcp14>MUST</bcp14> occur in a specific order, and with a
          specific syntax, as defined in
          <xref target="RFC4566" sectionFormat="comma" section="5"/>. Note that while the
          specific line types (e.g., "v=", "c=") <bcp14>MUST</bcp14> occur in the
          defined order, lines of the same type (typically "a=") can
          occur in any order.</t>
          <t>The following non-attribute lines are not meaningful in
          the JSEP context and <bcp14>MAY</bcp14> be discarded once they have been
          checked.
          </t>
          <ul spacing="normal">
            <li>The "c=" line <bcp14>MUST</bcp14> be checked for syntax, but its value
            is only used for ICE mismatch detection, as defined in
            <xref target="RFC8445" sectionFormat="comma" section="5.4"/>. Note that JSEP
            implementations should never encounter this condition
            because ICE is required for WebRTC.</li>
            <li>The "i=", "u=", "e=", "p=", "t=", "r=", "z=", and "k="
            lines <bcp14>MUST</bcp14> be
            checked for syntax, but their values are not otherwise used. </li>
          </ul>
          <t>The remaining non-attribute lines are processed as
          follows:
          </t>
          <ul spacing="normal">
            <li>The "v=" line <bcp14>MUST</bcp14> have a version of 0, as specified in
            <xref target="RFC4566" sectionFormat="comma" section="5.1"/>.</li>
            <li>The "o=" line <bcp14>MUST</bcp14> be parsed as specified in
            <xref target="RFC4566" sectionFormat="comma" section="5.2"/>.</li>
            <li>The "b=" line, if present, <bcp14>MUST</bcp14> be parsed as specified
            in
            <xref target="RFC4566" sectionFormat="comma" section="5.8"/>, and the bwtype and
            bandwidth values stored.</li>
          </ul>
          <t>Finally, the attribute lines are processed. Specific
          processing <bcp14>MUST</bcp14> be applied for the following session-level
          attribute ("a=") lines:
          </t>
          <ul spacing="normal">
            <li>Any "a=group" lines are parsed as specified in
            <xref target="RFC5888" sectionFormat="comma" section="5"/>, and the group's
            semantics and mids are stored.</li>
            <li>If present, a single "a=ice-lite" line is parsed as
            specified in
            <xref target="RFC8839" sectionFormat="comma" section="5.3"/>, and a value
            indicating the presence of ice-lite is stored.</li>
            <li>If present, a single "a=ice-ufrag" line is parsed as
            specified in
            <xref target="RFC8839" sectionFormat="comma" section="5.4"/>, and the ufrag value is stored.</li>
            <li>If present, a single "a=ice-pwd" line is parsed as
            specified in
            <xref target="RFC8839" sectionFormat="comma" section="5.4"/>, and the password value is stored.</li>
            <li>If present, a single "a=ice-options" line is parsed as
            specified in
            <xref target="RFC8839" sectionFormat="comma" section="5.6"/>, and the set of specified options is stored.</li>
            <li>Any "a=fingerprint" lines are parsed as specified in
            <xref target="RFC8122" sectionFormat="comma" section="5"/>, and the set of
            fingerprint and algorithm values is stored.</li>
            <li>If present, a single "a=setup" line is parsed as
            specified in
            <xref target="RFC4145" sectionFormat="comma" section="4"/>, and the setup value
            is stored.</li>
            <li>If present, a single "a=tls-id" line is parsed as
            specified in <xref target="RFC8842" sectionFormat="comma" section="5"/>, and
            the attribute value is stored.</li>
            <li>Any "a=identity" lines are parsed and the identity
            values stored for subsequent verification, as specified in
            <xref target="RFC8827" sectionFormat="comma" section="5"/>.</li>
            <li>Any "a=extmap" lines are parsed as specified in
            <xref target="RFC5285" sectionFormat="comma" section="5"/>, and their values are
            stored.</li>
          </ul>
          <t>Other attributes that are not relevant to JSEP may also be
          present, and implementations <bcp14>SHOULD</bcp14> process any that they
          recognize. As required by
          <xref target="RFC4566" sectionFormat="comma" section="5.13"/>, unknown
          attribute lines <bcp14>MUST</bcp14> be ignored.</t>
          <t>Once all the session-level lines have been parsed,
          processing continues with the lines in "m=" sections.</t>
        </section>
        <section anchor="sec.media-level-parse" numbered="true" toc="default">
          <name>Media Section Parsing</name>
          <t>Like the session-level lines, the media section lines <bcp14>MUST</bcp14>
          occur in the specific order and with the specific syntax
          defined in
          <xref target="RFC4566" sectionFormat="comma" section="5"/>.</t>
          <t>The "m=" line itself <bcp14>MUST</bcp14> be parsed as described in
          <xref target="RFC4566" sectionFormat="comma" section="5.14"/>, and the &lt;media&gt;, &lt;port&gt;,
          &lt;proto&gt;, and &lt;fmt&gt; values stored.</t>
          <t>Following the "m=" line, specific processing <bcp14>MUST</bcp14> be
          applied for the following non-attribute lines:
          </t>
          <ul spacing="normal">
            <li>As with the "c=" line at the session level, the "c="
            line <bcp14>MUST</bcp14> be parsed according to
            <xref target="RFC4566" sectionFormat="comma" section="5.7"/>, but its value is
            not used.</li>
            <li>The "b=" line, if present, <bcp14>MUST</bcp14> be parsed as specified
            in
            <xref target="RFC4566" sectionFormat="comma" section="5.8"/>, and the bwtype and
            bandwidth values stored.</li>
          </ul>
          <t>Specific processing <bcp14>MUST</bcp14> also be applied for the following
          attribute lines:
          </t>
          <ul spacing="normal">
            <li>If present, a single "a=ice-ufrag" line is parsed as
            specified in
            <xref target="RFC8839" sectionFormat="comma" section="5.4"/>, and the ufrag value is stored.</li>
            <li>If present, a single "a=ice-pwd" line is parsed as
            specified in
            <xref target="RFC8839" sectionFormat="comma" section="5.4"/>, and the password value is stored.</li>
            <li>If present, a single "a=ice-options" line is parsed as
            specified in
            <xref target="RFC8839" sectionFormat="comma" section="5.6"/>,
            and the set of specified options is stored.</li>
            <li>Any "a=candidate" attributes <bcp14>MUST</bcp14> be parsed as specified
            in
            <xref target="RFC8839" sectionFormat="comma" section="5.1"/>, and their values stored.</li>
            <li>Any "a=remote-candidates" attributes <bcp14>MUST</bcp14> be parsed as
            specified in
            <xref target="RFC8839" sectionFormat="comma" section="5.2"/>, but their values are ignored.</li>


            <li>If present, a single "a=end-of-candidates" attribute
            <bcp14>MUST</bcp14> be parsed as specified in
            <xref target="RFC8840" sectionFormat="comma" section="8.1"/>, and
            its presence or absence flagged and stored.</li>
            <li>Any "a=fingerprint" lines are parsed as specified in
            <xref target="RFC8122" sectionFormat="comma" section="5"/>, and the set of
            fingerprint and algorithm values is stored.</li>
          </ul>
          <t>If the "m=" &lt;proto&gt; value indicates use of RTP, as described
          in
          <xref target="sec.profile-names" format="default"/> above, the following
          attribute lines <bcp14>MUST</bcp14> be processed:
          </t>
          <ul spacing="normal">
            <li>The "m=" &lt;fmt&gt; value <bcp14>MUST</bcp14> be parsed as specified in
            <xref target="RFC4566" sectionFormat="comma" section="5.14"/>, and the individual
            values stored.</li>
            <li>Any "a=rtpmap" or "a=fmtp" lines <bcp14>MUST</bcp14> be parsed as
            specified in
            <xref target="RFC4566" sectionFormat="comma" section="6"/>, and their values
            stored.</li>
            <li>If present, a single "a=ptime" line <bcp14>MUST</bcp14> be parsed as
            described in
            <xref target="RFC4566" sectionFormat="comma" section="6"/>, and its value
            stored.</li>
            <li>If present, a single "a=maxptime" line <bcp14>MUST</bcp14> be parsed as
            described in
            <xref target="RFC4566" sectionFormat="comma" section="6"/>, and its value
            stored.</li>
            <li>If present, a single direction attribute line (e.g.,
            "a=sendrecv") <bcp14>MUST</bcp14> be parsed as described in
            <xref target="RFC4566" sectionFormat="comma" section="6"/>, and its value
            stored.</li>
            <li>Any "a=ssrc" attributes <bcp14>MUST</bcp14> be parsed as specified in
            <xref target="RFC5576" sectionFormat="comma" section="4.1"/>, and their values
            stored.</li>
            <li>Any "a=extmap" attributes <bcp14>MUST</bcp14> be parsed as specified in

            <xref target="RFC5285" sectionFormat="comma" section="5"/>, and their values
            stored.</li>
            <li>Any "a=rtcp-fb" attributes <bcp14>MUST</bcp14> be parsed as specified
            in
            <xref target="RFC4585" sectionFormat="comma" section="4.2"/>, and their values
            stored.</li>
            <li>If present, a single "a=rtcp-mux" attribute <bcp14>MUST</bcp14> be
            parsed as specified in
            <xref target="RFC5761" sectionFormat="comma" section="5.1.3"/>, and its
            presence or absence flagged and stored.</li>
            <li>If present, a single "a=rtcp-mux-only" attribute <bcp14>MUST</bcp14> be
            parsed as specified in
            <xref target="RFC8858" sectionFormat="comma" section="3"/>,
            and its presence or absence flagged and stored.</li>
            <li>If present, a single "a=rtcp-rsize" attribute <bcp14>MUST</bcp14> be
            parsed as specified in
            <xref target="RFC5506" sectionFormat="comma" section="5"/>, and its presence or
            absence flagged and stored.</li>
            <li>If present, a single "a=rtcp" attribute <bcp14>MUST</bcp14> be parsed
            as specified in
            <xref target="RFC3605" sectionFormat="comma" section="2.1"/>, but its value is
            ignored, as this information is superfluous when using
            ICE.</li>
            <li>If present, "a=msid" attributes <bcp14>MUST</bcp14> be parsed as
            specified in
            <xref target="RFC8830" sectionFormat="comma" section="3.2"/>, and
            their values stored, ignoring any "appdata" field. If no "a=msid"
            attributes are present, a random msid-id value is generated for a
            "default" MediaStream for the session, if not already present, and
            this value is stored.</li>
            <li>Any "a=imageattr" attributes <bcp14>MUST</bcp14> be parsed as specified
            in
            <xref target="RFC6236" sectionFormat="comma" section="3"/>, and their values
            stored.</li>
            <li>Any "a=rid" lines <bcp14>MUST</bcp14> be parsed as specified in
            <xref target="RFC8851" sectionFormat="comma" section="10"/>, and
            their values stored.</li>
            <li>If present, a single "a=simulcast" line <bcp14>MUST</bcp14> be parsed
            as specified in
            <xref target="RFC8853" format="default"/>, and
            its values stored.</li>
          </ul>
          <t>Otherwise, if the "m=" &lt;proto&gt; value indicates use of SCTP,
          the following attribute lines <bcp14>MUST</bcp14> be processed:
          </t>
          <ul spacing="normal">
            <li>The "m="  &lt;fmt&gt; value <bcp14>MUST</bcp14> be parsed as specified in
            <xref target="RFC8841" sectionFormat="comma" section="4.3"/>,
            and the application protocol value stored.</li>
            <li>An "a=sctp-port" attribute <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14>
            be parsed as specified in
            <xref target="RFC8841" sectionFormat="comma" section="5.2"/>,
            and the value stored.</li>
            <li>If present, a single "a=max-message-size" attribute <bcp14>MUST</bcp14>
            be parsed as specified in
            <xref target="RFC8841" sectionFormat="comma" section="6"/>, and
            the value stored. Otherwise, use the specified default.</li>
          </ul>
          <t>Other attributes that are not relevant to JSEP may also be
          present, and implementations <bcp14>SHOULD</bcp14> process any that they
          recognize. As required by
          <xref target="RFC4566" sectionFormat="comma" section="5.13"/>, unknown
          attribute lines <bcp14>MUST</bcp14> be ignored.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Semantics Verification</name>
          <t>Assuming that parsing completes successfully, the parsed
          description is then evaluated to ensure internal consistency
          as well as proper support for mandatory features.
          Specifically, the following checks are performed:
          </t>
          <ul spacing="normal">
            <li>
              <t>For each "m=" section, valid values for each of the
            mandatory-to-use features enumerated in
            <xref target="sec.usage-requirements" format="default"/> <bcp14>MUST</bcp14> be present.
            These values <bcp14>MAY</bcp14> be either present at the media level or
            inherited from the session level.
              </t>
              <ul spacing="normal">
                <li>ICE ufrag and password values, which <bcp14>MUST</bcp14> comply with
              the size limits specified in
              <xref target="RFC8839" sectionFormat="comma" section="5.4"/>.</li>
                <li>A tls-id value, which <bcp14>MUST</bcp14> be set according to
              <xref target="RFC8842" sectionFormat="comma" section="5"/>. If
	       this is a re-offer or a response to a re-offer and the
	       tls-id value is different from that presently in use, the
	       DTLS connection is not being continued and the remote
	       description <bcp14>MUST</bcp14> be part of an ICE restart, together with
	       new ufrag and password values.</li>
		 <li>A DTLS setup value, which <bcp14>MUST</bcp14> be set according to the
	       rules specified in
	       <xref target="RFC5763" sectionFormat="comma" section="5"/> and <bcp14>MUST</bcp14> be
	       consistent with the selected role of the current DTLS
	       connection, if one exists and is being continued.</li>
		 <li>DTLS fingerprint values, where at least one
	       fingerprint <bcp14>MUST</bcp14> be present.</li>
	       </ul>
	     </li>
	     <li>All rid-ids referenced in an "a=simulcast" line <bcp14>MUST</bcp14>
	     exist as "a=rid" lines.</li>
	     <li>Each "m=" section is also checked to ensure that prohibited
	     features are not used.</li>
	     <li>If the RTP/RTCP multiplexing policy is "require", each
	     "m=" section <bcp14>MUST</bcp14> contain an "a=rtcp-mux" attribute. If an "m="
	     section contains an "a=rtcp-mux-only" attribute, that
	     section <bcp14>MUST</bcp14> also contain an "a=rtcp-mux" attribute.</li>
	     <li>If an "m=" section was present in the previous answer, the
	     state of RTP/RTCP multiplexing <bcp14>MUST</bcp14> match what was
	     previously negotiated.</li>
	   </ul>
	   <t>If this session description is of type "pranswer" or
	   "answer", the following additional checks are applied:
	   </t>
	   <ul spacing="normal">
	     <li>The session description <bcp14>MUST</bcp14> follow the rules defined in
	     <xref target="RFC3264" sectionFormat="comma" section="6"/>, including the
	     requirement that the number of "m=" sections <bcp14>MUST</bcp14> exactly
	     match the number of "m=" sections in the associated
	     offer.</li>
	     <li>For each "m=" section, the media type and protocol values
	     <bcp14>MUST</bcp14> exactly match the media type and protocol values in
	     the corresponding "m=" section in the associated offer.</li>
	   </ul>
	   <t>If any of the preceding checks failed, processing <bcp14>MUST</bcp14>
	   stop and an error <bcp14>MUST</bcp14> be returned.</t>
	 </section>
       </section>
       <section anchor="sec.applying-a-local-desc" numbered="true" toc="default">
	 <name>Applying a Local Description</name>
	 <t>The following steps are performed at the media engine level
	 to apply a local description. If an error is returned, the
	 session <bcp14>MUST</bcp14> be restored to the state it was in before
	 performing these steps.</t>
	 <t>First, "m=" sections are processed. For each "m=" section, the
	 following steps <bcp14>MUST</bcp14> be performed; if any parameters are out of
	 bounds or cannot be applied, processing <bcp14>MUST</bcp14> stop and an error
	 <bcp14>MUST</bcp14> be returned.
	 </t>
	 <ul spacing="normal">
	   <li>If this "m=" section is new, begin gathering candidates for
	   it, as defined in
	   <xref target="RFC8445" sectionFormat="comma" section="5.1.1"/>, unless it is
	   definitively being bundled (either (1) this is an offer and the
	   "m=" section is marked as bundle-only or (2)&nbsp;it is an answer and the
	   "m=" section is bundled into another "m=" section).</li>
	   <li>Or, if the ICE ufrag and password values have changed,
	   trigger the ICE agent to start an ICE restart as described in
	   <xref target="RFC8445" sectionFormat="comma" section="9"/>, and begin
	   gathering new candidates for the "m=" section. If this
	   description is an answer, also start checks on that media
	   section.</li>
	   <li>
	     <t>If the "m=" section &lt;proto&gt; value indicates use of RTP:
	     </t>
	     <ul spacing="normal">
	       <li>
		 <t>If there is no RtpTransceiver associated with this "m="
	     section, find one and associate it with this "m=" section
	     according to the following steps. Note that this situation
	     will only occur when applying an offer.
		 </t>
		 <ul spacing="normal">
		   <li>Find the RtpTransceiver that corresponds to this "m="
	       section, using the mapping between transceivers and "m="
	       section indices established when creating the offer.</li>
		   <li>Set the value of this RtpTransceiver's mid property to
	       the MID of the "m=" section.</li>
		 </ul>
	       </li>
	       <li>If RTCP mux is indicated, prepare to demux RTP and RTCP
	     from the RTP ICE component, as specified in
	     <xref target="RFC5761" sectionFormat="comma" section="5.1.3"/>.</li>
	       <li>For each specified RTP header extension, establish a
	     mapping between the extension ID and URI, as described in
	     <xref target="RFC5285" sectionFormat="comma" section="6"/>.</li>
	       <li>If the MID header extension is supported, prepare to
	     demux RTP streams intended for this "m=" section based on the
	     MID header extension, as described in
	     <xref target="RFC8843" sectionFormat="comma" section="15"/>.</li>
	       <li>For each specified media format, establish a mapping
	     between the payload type and the actual media format, as
	     described in
	     <xref target="RFC3264" sectionFormat="comma" section="6.1"/>. In addition,
	     prepare to demux RTP streams intended for this "m=" section
	     based on the media formats supported by this "m=" section, as
	     described in
	     <xref target="RFC8843" sectionFormat="comma" section="9.2"/>.
 </li>
	       <li>For each specified "rtx" media format, establish a
	     mapping between the RTX payload type and its associated
	     primary payload type, as described in
	     Sections <xref target="RFC4588" section="8.6"
	     sectionFormat="bare"/> and <xref target="RFC4588" section="8.7"
	     sectionFormat="bare"/> of <xref target="RFC4588"/>.

 </li>
	       <li>If the direction attribute is of type "sendrecv" or
	     "recvonly", enable receipt and decoding of media.</li>
	     </ul>
	   </li>
	 </ul>
	 <t>Finally, if this description is of type "pranswer" or
	 "answer", follow the processing defined in
	 <xref target="sec.applying-an-answer" format="default"/> below.</t>
       </section>
       <section anchor="sec.applying-a-remote-desc" numbered="true" toc="default">
	 <name>Applying a Remote Description</name>
	 <t>The following steps are performed to apply a remote
	 description. If an error is returned, the session <bcp14>MUST</bcp14> be
	 restored to the state it was in before performing these
	 steps.</t>
	 <t>If the answer contains any "a=ice-options" attributes where
	 "trickle" is listed as an attribute, update the PeerConnection
	 canTrickleIceCandidates property to be "true". Otherwise, set this property to
	 "false".</t>
	 <t>The following steps <bcp14>MUST</bcp14> be performed for attributes at the
	 session level; if any parameters are out of bounds or cannot
	 be applied, processing <bcp14>MUST</bcp14> stop and an error <bcp14>MUST</bcp14> be returned.

	 </t>
	 <ul spacing="normal">
	   <li>For any specified "CT" bandwidth value, set this value as the
	   limit for the maximum total bitrate for all "m=" sections, as
	   specified in
	   <xref target="RFC4566" sectionFormat="comma" section="5.8"/>. Within this
	   overall limit, the implementation can dynamically decide how
	   to best allocate the available bandwidth between "m=" sections,
	   respecting any specific limits that have been specified for
	   individual "m=" sections.</li>
	   <li>For any specified "RR" or "RS" bandwidth values, handle as
	   specified in
	   <xref target="RFC3556" sectionFormat="comma" section="2"/>.</li>
	   <li>Any "AS" bandwidth value (<xref target="RFC4566" sectionFormat="comma" section="5.8"/>)
           <bcp14>MUST</bcp14> be ignored, as the meaning
	   of this construct at the session level is not well
	   defined. </li>
	 </ul>
	 <t>For each "m=" section, the following steps <bcp14>MUST</bcp14> be performed;
	 if any parameters are out of bounds or cannot be applied,
	 processing <bcp14>MUST</bcp14> stop and an error <bcp14>MUST</bcp14> be returned.
	 </t>
	 <ul spacing="normal">
	   <li>
	     <t>If the ICE ufrag or password changed from the previous
	   remote description:
	     </t>
	     <ul spacing="normal">
	       <li>If the description is of type "offer", the
	     implementation <bcp14>MUST</bcp14> note that an ICE restart is needed, as
	     described in
	     <xref target="RFC8839" sectionFormat="comma" section="4.4.1.1.1"/>.</li>
	       <li>If the description is of type "answer" or "pranswer",
	     then check to see if the current local description is an
	     ICE restart, and if not, generate an error. If the
	     PeerConnection state is "have-remote-pranswer" and the ICE
	     ufrag or password changed from the previous provisional
	     answer, then signal the ICE agent to discard any previous
	     ICE checklist state for the "m=" section. Finally, signal
	     the ICE agent to begin checks.
</li>
	     </ul>
	   </li>
	   <li>If the current local description indicates an ICE restart
	   but neither the ICE ufrag nor the password has changed from the
	   previous remote description (as prescribed by
	   <xref target="RFC8445" sectionFormat="comma" section="9"/>), generate an
	   error.</li>
	   <li>Configure the ICE components associated with this media
	   section to use the supplied ICE remote ufrag and password for
	   their connectivity checks.</li>
	   <li>Pair any supplied ICE candidates with any gathered local
	   candidates, as described in
	   <xref target="RFC8445" sectionFormat="comma" section="6.1.2"/>, and start
	   connectivity checks with the appropriate credentials.</li>

	   <li>If an "a=end-of-candidates" attribute is present, process
	   the end-of-candidates indication as described in
	   <xref target="RFC8838" sectionFormat="comma" section="14"/>.</li>
	    <li>
	      <t>If the "m=" section &lt;proto&gt; value indicates use of RTP:
	      </t>
	      <ul spacing="normal">
		<li>If the "m=" section is being recycled (see
	      <xref target="sec.subsequent-offers" format="default"/>), disassociate
	      the currently associated RtpTransceiver by setting its mid
	      property to "null", and discard the mapping between the
	      transceiver and its "m=" section index.</li>
		<li>
		  <t>If the "m=" section is not associated with any
	      RtpTransceiver (possibly because it was disassociated in the
	      previous step), either find an RtpTransceiver or create one
	      according to the following steps:
		  </t>
		  <ul spacing="normal">
		    <li>If the "m=" section is sendrecv or recvonly, and there
		are RtpTransceivers of the same type that were added to
		the PeerConnection by addTrack and are not associated
		with any "m=" section and are not stopped, find the first
		(according to the canonical order described in
		<xref target="sec.initial-offers" format="default"/>) such
		RtpTransceiver.</li>
		    <li>If no RtpTransceiver was found in the previous step,
		create one with a recvonly direction.</li>
		    <li>Associate the found or created RtpTransceiver with the
		"m=" section by setting the value of the RtpTransceiver's
		mid property to the MID of the "m=" section, and establish
		a mapping between the transceiver and the index of the "m="
		section. If the "m=" section does not include a MID (i.e.,
		the remote endpoint does not support the MID extension),
		generate a value for the RtpTransceiver mid property,
		following the guidance for "a=mid" mentioned in
		<xref target="sec.initial-offers" format="default"/>.</li>
		  </ul>
		</li>
		<li>For each specified media format that is also supported
	      by the local implementation, establish a mapping between
	      the specified payload type and the media format, as
	      described in
	      <xref target="RFC3264" sectionFormat="comma" section="6.1"/>. Specifically, this
	      means that the implementation records the payload type to
	      be used in outgoing RTP packets when sending each specified
	      media format, as well as the relative preference for each
	      format that is indicated in their ordering. If any
	      indicated media format is not supported by the local
	      implementation, it <bcp14>MUST</bcp14> be ignored.</li>
		<li>For each specified "rtx" media format, establish a
	      mapping between the RTX payload type and its associated
	      primary payload type, as described in
	      <xref target="RFC4588" sectionFormat="comma" section="4"/>. If any referenced
	      primary payload types are not present, this <bcp14>MUST</bcp14> result in
	      an error. Note that RTX payload types may refer to primary
	      payload types that are not supported by the local media
	      implementation, in which case the RTX payload type <bcp14>MUST</bcp14>
	      also be ignored.</li>
		<li>For each specified fmtp parameter that is supported by
	      the local implementation, enable them on the associated
	      media formats.</li>
		<li>For each specified Synchronization Source (SSRC) that is signaled in the "m="
	      section, prepare to demux RTP streams intended for this "m="
	      section using that SSRC, as described in
	      <xref target="RFC8843" sectionFormat="comma" section="9.2"/>.</li>
		<li>For each specified RTP header extension that is also
	      supported by the local implementation, establish a mapping
	      between the extension ID and URI, as described in
	      <xref target="RFC5285" sectionFormat="comma" section="5"/>. Specifically, this
	      means that the implementation records the extension ID to
	      be used in outgoing RTP packets when sending each specified
	      header extension. If any indicated RTP header extension is
	      not supported by the local implementation, it <bcp14>MUST</bcp14> be
	      ignored.</li>
		<li>For each specified RTCP feedback mechanism that is
	      supported by the local implementation, enable them on the
	      associated media formats.</li>
		<li>
		  <t>For any specified "TIAS" ("Transport
     Independent Application Specific Maximum") bandwidth value, set this value
	      as a constraint on the maximum RTP bitrate to be used when
	      sending media, as specified in
	      <xref target="RFC3890" format="default"/>. If a "TIAS" value is not
	      present but an "AS" value is specified, generate a "TIAS"
	      value using this formula:
		  </t>
		  <ul empty="true">
		    <li>TIAS = AS * 1000 * 0.95 - (50 * 40 * 8)</li>
		  </ul>
		  <t>
              The 1000 changes the unit from kbps to bps (as required
              by TIAS), and the 0.95 is to allocate 5% to RTCP.
              An estimate of header overhead is then subtracted out, in which
              the 50 is based on 50 packets per second, the 40 is based on
              typical header size (in bytes), and the 8 converts bytes to bits.
              Note that "TIAS" is preferred over
	      "AS" because it provides more accurate
	      control of bandwidth.</t>
		</li>
		<li>For any "RR" or "RS" bandwidth values, handle as
	      specified in
	      <xref target="RFC3556" sectionFormat="comma" section="2"/>.</li>
		<li>Any specified "CT" bandwidth value <bcp14>MUST</bcp14> be ignored, as
	      the meaning of this construct at the media level is not
	      well defined.</li>
		<li>
		  <t>If the "m=" section is of type "audio":
		  </t>
		  <ul spacing="normal">
		    <li>For each specified "CN" media format, configure
		silence suppression for all supported media formats with
		the same clock rate, as described in
		<xref target="RFC3389" sectionFormat="comma" section="5"/>, except for formats
		that have their own internal silence suppression
		mechanisms. Silence suppression for such formats (e.g.,
		Opus) is controlled via fmtp parameters, as discussed in
		<xref target="sec.voiceactivitydetection1" format="default"/>.</li>
		    <li>For each specified "telephone-event" media format,
		enable dual-tone multifrequency (DTMF) transmission for all supported media formats
		with the same clock rate, as described in
		<xref target="RFC4733" sectionFormat="comma" section="2.5.1.2"/>. If there are
		any supported media formats that do not have a
		corresponding telephone-event format, disable DTMF
		transmission for those formats.</li>
		    <li>For any specified "ptime" value, configure the
		available media formats to use the specified packet size
		when sending. If the specified size is not supported for
		a media format, use the next closest value instead.</li>
		  </ul>
		</li>
	      </ul>
	    </li>
	  </ul>
	  <t>Finally, if this description is of type "pranswer" or
	  "answer", follow the processing defined in
	  <xref target="sec.applying-an-answer" format="default"/> below.</t>
	</section>
	<section anchor="sec.applying-an-answer" numbered="true" toc="default">
	  <name>Applying an Answer</name>
	  <t>In addition to the steps mentioned above for processing a
	  local or remote description, the following steps are performed
	  when processing a description of type "pranswer" or
	  "answer".</t>
	  <t>For each "m=" section, the following steps <bcp14>MUST</bcp14> be performed:
	  </t>
	  <ul spacing="normal">
	    <li>If the "m=" section has been rejected (i.e., the &lt;port&gt; value is set to
	    zero in the answer), stop any reception or transmission of
	    media for this section, and, unless a non-rejected "m=" section
	    is bundled with this "m=" section, discard any associated ICE
	    components, as described in
	    <xref target="RFC8839" sectionFormat="comma" section="4.4.3.1"/>.</li>
	     <li>If the remote DTLS fingerprint has been changed or the
	     value of the "a=tls-id" attribute has changed, tear down the DTLS connection. This
	     includes the case when the PeerConnection state is
	     "have-remote-pranswer". If a DTLS connection needs to be torn
	     down but the answer does not indicate an ICE restart or, in
	     the case of "have-remote-pranswer", new ICE credentials, an
	     error <bcp14>MUST</bcp14> be generated. If an ICE restart is performed
	     without a change in the tls-id value or fingerprint, then the same DTLS
	     connection is continued over the new ICE channel. Note that
	     although JSEP requires that answerers change the tls-id value
	     if and only if the offerer does, non-JSEP answerers are
	     permitted to change the tls-id value as long as the offer contained
	     an ICE restart. Thus, JSEP implementations that process DTLS
	     data prior to receiving an answer <bcp14>MUST</bcp14> be prepared to receive
	     either a ClientHello or data from the previous DTLS
	     connection.</li>
	     <li>If no valid DTLS connection exists, prepare to start a
	     DTLS connection, using the specified roles and fingerprints,
	     on any underlying ICE components, once they are active.</li>
	     <li>
	       <t>If the "m=" section &lt;proto&gt; value indicates use of RTP:
	       </t>
	       <ul spacing="normal">
		 <li>If the "m=" section references RTCP feedback mechanisms
	       that were not present in the corresponding "m=" section in
	       the offer, this indicates a negotiation problem and <bcp14>MUST</bcp14>
	       result in an error. However, new media formats and new RTP
	       header extension values are permitted in the answer, as
	       described in
	       <xref target="RFC3264" sectionFormat="comma" section="7"/> and
	       <xref target="RFC5285" sectionFormat="comma" section="6"/>.</li>
		 <li>If the "m=" section has RTCP mux enabled, discard the RTCP
	       ICE component, if one exists, and begin or continue muxing
	       RTCP over the RTP ICE component, as specified in
	       <xref target="RFC5761" sectionFormat="comma" section="5.1.3"/>. Otherwise,
	       prepare to transmit RTCP over the RTCP ICE component; if no
	       RTCP ICE component exists because RTCP mux was previously
	       enabled, this <bcp14>MUST</bcp14> result in an error.</li>
		 <li>If the "m=" section has Reduced-Size RTCP enabled,
	       configure the RTCP transmission for this "m=" section to use
	       Reduced-Size RTCP, as specified in
	       <xref target="RFC5506" format="default"/>.</li>
		 <li>If the direction attribute in the answer indicates
	       that the JSEP implementation should be sending media
	       ("sendonly" for local answers, "recvonly" for remote
	       answers, or "sendrecv" for either type of answer), choose
	       the media format to send as the most preferred media format
	       from the remote description that is also locally supported,
	       as discussed in Sections <xref target="RFC3264" section="6.1"
   sectionFormat="bare"/> and <xref target="RFC3264" section="7" sectionFormat="bare"/> of <xref target="RFC3264"/>, and start
	       transmitting RTP media using that format once the
	       underlying transport layers have been established. If an
	       SSRC has not already been chosen for this outgoing RTP
	       stream, choose a unique random one. If media is already being
	       transmitted, the same SSRC <bcp14>SHOULD</bcp14> be used unless the
	       clock rate of the new codec is different, in which case a
	       new SSRC <bcp14>MUST</bcp14> be chosen, as specified in
	       <xref target="RFC7160" sectionFormat="comma" section="4.1"/>.</li>
		 <li>The payload type mapping from the remote description is
	       used to determine payload types for the outgoing RTP
	       streams, including the payload type for the send media
	       format chosen above. Any RTP header extensions that were
	       negotiated should be included in the outgoing RTP streams,
	       using the extension mapping from the remote description. If the MID
         header extension has been negotiated, include it in the outgoing RTP
         streams, as indicated in
         <xref target="RFC8843" sectionFormat="comma" section="15"/>.
	       If the RtpStreamId or RepairedRtpStreamId header extensions have been
         negotiated and rid-ids have been established, include these header
         extensions in the outgoing RTP streams, as indicated in
	       <xref target="RFC8851" sectionFormat="comma" section="4"/>.</li>
		 <li>If the "m=" section is of type "audio", and silence
	       suppression was (1) configured for the send media format as a
	       result of processing the remote description and (2) also
	       enabled for that format in the local description, use
	       silence suppression for outgoing media, in accordance with
	       the guidance in
	       <xref target="sec.voiceactivitydetection1" format="default"/>.
               If these
	       conditions are not met, silence suppression <bcp14>MUST NOT</bcp14> be
	       used for outgoing media.</li>
		 <li>If simulcast has been negotiated, send the appropriate number of
	       Source RTP Streams as specified in
	       <xref target="RFC8853" sectionFormat="comma" section="5.3.3"/>.</li>
		 <li>If the send media format chosen above has a
	       corresponding "rtx" media format or a FEC mechanism has
	       been negotiated, establish a redundancy RTP stream with a
	       unique random SSRC for each Source RTP Stream, and start or
	       continue transmitting RTX/FEC packets as needed.</li>
		 <li>If the send media format chosen above has a
	       corresponding "red" media format of the same clock rate,
	       allow redundant encoding using the specified format for
	       resiliency purposes, as discussed in
	       <xref target="RFC8854" sectionFormat="comma" section="3.2"/>. Note
	       that unlike RTX or FEC media formats, the "red" format is
	       transmitted on the Source RTP Stream, not the redundancy
	       RTP stream.</li>
		 <li>Enable the RTCP feedback mechanisms referenced in the
	       media section for all Source RTP Streams using the
	       specified media formats. Specifically, begin or continue
	       sending the requested feedback types and reacting to
	       received feedback, as specified in
	       <xref target="RFC4585" sectionFormat="comma" section="4.2"/>. When sending RTCP
	       feedback, follow the rules and recommendations from
   <xref target="RFC8108" sectionFormat="comma" section="5.4.1"/> to select
	       which SSRC to use.</li>
		 <li>If the direction attribute in the answer indicates
	       that the JSEP implementation should not be sending media
	       ("recvonly" for local answers, "sendonly" for remote
	       answers, or "inactive" for either type of answer), stop
	       transmitting all RTP media, but continue sending RTCP, as
	       described in
	       <xref target="RFC3264" sectionFormat="comma" section="5.1"/>.</li>
	       </ul>
	     </li>
	     <li>
	       <t>If the "m=" section &lt;proto&gt; value indicates use of SCTP:
	       </t>
	       <ul spacing="normal">
		 <li>If an SCTP association exists and the remote SCTP port
	       has changed, discard the existing SCTP association. This
	       includes the case when the PeerConnection state is
	       "have-remote-pranswer".</li>
		 <li>If no valid SCTP association exists, prepare to initiate
	       an SCTP association over the associated ICE component and
	       DTLS connection, using the local SCTP port value from the
	       local description and the remote SCTP port value from the
	       remote description, as described in
	       <xref target="RFC8841" sectionFormat="comma" section="10.2"/>.</li>
	       </ul>
	     </li>
	   </ul>
	   <t>If the answer contains valid bundle groups, discard any ICE
	   components for the "m=" sections that will be bundled onto the
	   primary ICE components in each bundle, and begin muxing these
	   "m=" sections accordingly, as described in
	   <xref target="RFC8843" sectionFormat="comma" section="7.4"/>.</t>
	   <t>If the description is of type "answer" and there are still
	   remaining candidates in the ICE candidate pool, discard
	   them.</t>
	 </section>
       </section>
       <section anchor="sec.rtp.demux" numbered="true" toc="default">
	 <name>Processing RTP/RTCP</name>
	 <t>When bundling, associating incoming RTP/RTCP with the proper
	 "m=" section is defined in
	 <xref target="RFC8843" sectionFormat="comma" section="9.2"/>. When not bundling, the proper "m=" section is clear from the
	 ICE component over which the RTP/RTCP is received.</t>
	 <t>Once the proper "m=" section or sections are known, RTP/RTCP is delivered
	 to the RtpTransceiver(s) associated with the "m=" section(s) and
	 further processing of the RTP/RTCP is done at the RtpTransceiver
	 level. This includes using the RID mechanism
	 <xref target="RFC8851" format="default"/> and its associated RtpStreamId and
   RepairedRtpStreamId identifiers to distinguish between
	 multiple encoded streams and determine which Source RTP
	 stream should be repaired by a given redundancy RTP stream.</t>
       </section>
       <section anchor="sec.examples" numbered="true" toc="default">
	 <name>Examples</name>
	 <t>Note that this example section shows several SDP fragments. To
	 accommodate RFC line-length restrictions, some of the SDP lines have been split
	 into multiple lines, where leading whitespace indicates that a
	 line is a continuation of the previous line. In addition, some
	 blank lines have been added to improve readability but are not
	 valid in SDP.</t>
	 <t>More examples of SDP for WebRTC call flows, including examples
	 with IPv6 addresses, can be found in
	 <xref target="I-D.ietf-rtcweb-sdp" format="default"/>.</t>
	 <section anchor="sec.simple-examples" numbered="true" toc="default">
	   <name>Simple Example</name>
	   <t>This section shows a very simple example that sets up a
	   minimal audio/video call between two JSEP endpoints without
	   using Trickle ICE. The example in the following section
	   provides a more detailed example of what could happen in a JSEP
	   session.</t>
	   <t>The code flow below shows Alice's endpoint initiating the
	   session to Bob's endpoint. The messages from the JavaScript
	   application in Alice's browser to the JavaScript in Bob's
	   browser, abbreviated as "AliceJS" and "BobJS", respectively, are
	   assumed to flow over some signaling protocol via a web server.
	   The JavaScript on both Alice's side and Bob's side waits for
	   all candidates before sending the offer or answer, so the
	   offers and answers are complete; Trickle ICE is not used. The
	   user agents (JSEP implementations) in Alice's and Bob's browsers,
	   abbreviated as "AliceUA" and "BobUA", respectively, are both using the
	   default bundle policy of "balanced" and the default RTCP mux
	   policy of "require".</t>
	   <artwork name="" type="ascii-art" align="left" alt=""><![CDATA[
//                  set up local media state
AliceJS->AliceUA:   create new PeerConnection
AliceJS->AliceUA:   addTrack with two tracks: audio and video
AliceJS->AliceUA:   createOffer to get offer
AliceJS->AliceUA:   setLocalDescription with offer
AliceUA->AliceJS:   multiple onicecandidate events with candidates

//                  wait for ICE gathering to complete
AliceUA->AliceJS:   onicecandidate event with null candidate
AliceJS->AliceUA:   get |offer-A1| from pendingLocalDescription

//                  |offer-A1| is sent over signaling protocol to Bob
AliceJS->WebServer: signaling with |offer-A1|
WebServer->BobJS:   signaling with |offer-A1|

//                  |offer-A1| arrives at Bob
BobJS->BobUA:       create a PeerConnection
BobJS->BobUA:       setRemoteDescription with |offer-A1|
BobUA->BobJS:       ontrack events for audio and video tracks

//                  Bob accepts call
BobJS->BobUA:       addTrack with local tracks
BobJS->BobUA:       createAnswer
BobJS->BobUA:       setLocalDescription with answer
BobUA->BobJS:       multiple onicecandidate events with candidates

//                  wait for ICE gathering to complete
BobUA->BobJS:       onicecandidate event with null candidate
BobJS->BobUA:       get |answer-A1| from currentLocalDescription

//                  |answer-A1| is sent over signaling protocol
//                  to Alice
BobJS->WebServer:   signaling with |answer-A1|
WebServer->AliceJS: signaling with |answer-A1|

//                  |answer-A1| arrives at Alice
AliceJS->AliceUA:   setRemoteDescription with |answer-A1|
AliceUA->AliceJS:   ontrack events for audio and video tracks

//                  media flows
BobUA->AliceUA:     media sent from Bob to Alice
AliceUA->BobUA:     media sent from Alice to Bob ]]></artwork>

	   <t>The SDP for |offer-A1| looks like:</t>
	   <sourcecode name="offer-A1" type="sdp"><![CDATA[
v=0
o=- 4962303333179871722 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 10100 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 203.0.113.100
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:47017fee-b6c1-4162-929c-a25110252400
a=ice-ufrag:ETEn
a=ice-pwd:OtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:
              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=tls-id:91bbf309c0990a6bec11e38ba2933cee
a=rtcp:10101 IN IP4 203.0.113.100
a=rtcp-mux
a=rtcp-rsize
a=candidate:1 1 udp 2113929471 203.0.113.100 10100 typ host
a=candidate:1 2 udp 2113929470 203.0.113.100 10101 typ host
a=end-of-candidates

m=video 10102 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 203.0.113.100
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
a=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:47017fee-b6c1-4162-929c-a25110252400
a=ice-ufrag:BGKk
a=ice-pwd:mqyWsAjvtKwTGnvhPztQ9mIf
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:
              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=tls-id:91bbf309c0990a6bec11e38ba2933cee
a=rtcp:10103 IN IP4 203.0.113.100
a=rtcp-mux
a=rtcp-rsize
a=candidate:1 1 udp 2113929471 203.0.113.100 10102 typ host
a=candidate:1 2 udp 2113929470 203.0.113.100 10103 typ host
a=end-of-candidates ]]></sourcecode>

	   <t>The SDP for |answer-A1| looks like:</t>
	   <sourcecode name="answer-A1" type="sdp"><![CDATA[
v=0
o=- 6729291447651054566 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 10200 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 203.0.113.200
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:61317484-2ed4-49d7-9eb7-1414322a7aae
a=ice-ufrag:6sFv
a=ice-pwd:cOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256
              6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35:
              DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:active
a=tls-id:eec3392ab83e11ceb6a0990c903fbb19
a=rtcp-mux
a=rtcp-rsize
a=candidate:1 1 udp 2113929471 203.0.113.200 10200 typ host
a=end-of-candidates

m=video 10200 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 203.0.113.200
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
a=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:61317484-2ed4-49d7-9eb7-1414322a7aae ]]></sourcecode>
	 </section>
	 <section anchor="sec.detailed-example" numbered="true" toc="default">
	   <name>Detailed Example</name>
	   <t>This section shows a more involved example of a session
	   between two JSEP endpoints. Trickle ICE is used in full trickle
	   mode, with a bundle policy of "must-bundle", an RTCP mux policy
	   of "require", and a single TURN server. Initially, both Alice
	   and Bob establish an audio channel and a data channel. Later,
	   Bob adds two video flows -- one for his video feed and one for
	   screen sharing, both supporting FEC -- with the video feed
	   configured for simulcast. Alice accepts these video flows but
	   does not add video flows of her own, so they are handled as
	   recvonly. Alice also specifies a maximum video decoder
	   resolution.</t>

	   <artwork name="" type="ascii-art" align="left" alt=""><![CDATA[
//                  set up local media state
AliceJS->AliceUA:   create new PeerConnection
AliceJS->AliceUA:   addTrack with an audio track
AliceJS->AliceUA:   createDataChannel to get data channel
AliceJS->AliceUA:   createOffer to get |offer-B1|
AliceJS->AliceUA:   setLocalDescription with |offer-B1|

//                  |offer-B1| is sent over signaling protocol to Bob
AliceJS->WebServer: signaling with |offer-B1|
WebServer->BobJS:   signaling with |offer-B1|

//                  |offer-B1| arrives at Bob
BobJS->BobUA:       create a PeerConnection
BobJS->BobUA:       setRemoteDescription with |offer-B1|
BobUA->BobJS:       ontrack event with audio track from Alice

//                  candidates are sent to Bob
AliceUA->AliceJS:   onicecandidate (host) |offer-B1-candidate-1|
AliceJS->WebServer: signaling with |offer-B1-candidate-1|
AliceUA->AliceJS:   onicecandidate (srflx) |offer-B1-candidate-2|
AliceJS->WebServer: signaling with |offer-B1-candidate-2|
AliceUA->AliceJS:   onicecandidate (relay) |offer-B1-candidate-3|
AliceJS->WebServer: signaling with |offer-B1-candidate-3|

WebServer->BobJS:   signaling with |offer-B1-candidate-1|
BobJS->BobUA:       addIceCandidate with |offer-B1-candidate-1|
WebServer->BobJS:   signaling with |offer-B1-candidate-2|
BobJS->BobUA:       addIceCandidate with |offer-B1-candidate-2|
WebServer->BobJS:   signaling with |offer-B1-candidate-3|
BobJS->BobUA:       addIceCandidate with |offer-B1-candidate-3|

//                  Bob accepts call
BobJS->BobUA:       addTrack with local audio
BobJS->BobUA:       createDataChannel to get data channel
BobJS->BobUA:       createAnswer to get |answer-B1|
BobJS->BobUA:       setLocalDescription with |answer-B1|

//                  |answer-B1| is sent to Alice
BobJS->WebServer:   signaling with |answer-B1|
WebServer->AliceJS: signaling with |answer-B1|
AliceJS->AliceUA:   setRemoteDescription with |answer-B1|
AliceUA->AliceJS:   ontrack event with audio track from Bob

//                  candidates are sent to Alice
BobUA->BobJS:       onicecandidate (host) |answer-B1-candidate-1|
BobJS->WebServer:   signaling with |answer-B1-candidate-1|
BobUA->BobJS:       onicecandidate (srflx) |answer-B1-candidate-2|
BobJS->WebServer:   signaling with |answer-B1-candidate-2|
BobUA->BobJS:       onicecandidate (relay) |answer-B1-candidate-3|
BobJS->WebServer:   signaling with |answer-B1-candidate-3|

WebServer->AliceJS: signaling with |answer-B1-candidate-1|
AliceJS->AliceUA:   addIceCandidate with |answer-B1-candidate-1|
WebServer->AliceJS: signaling with |answer-B1-candidate-2|
AliceJS->AliceUA:   addIceCandidate with |answer-B1-candidate-2|
WebServer->AliceJS: signaling with |answer-B1-candidate-3|
AliceJS->AliceUA:   addIceCandidate with |answer-B1-candidate-3|

//                  data channel opens
BobUA->BobJS:       ondatachannel event
AliceUA->AliceJS:   ondatachannel event
BobUA->BobJS:       onopen
AliceUA->AliceJS:   onopen

//                  media is flowing between endpoints
BobUA->AliceUA:     audio+data sent from Bob to Alice
AliceUA->BobUA:     audio+data sent from Alice to Bob

//                  some time later, Bob adds two video streams
//                  note: no candidates exchanged, because of bundle
BobJS->BobUA:       addTrack with first video stream
BobJS->BobUA:       addTrack with second video stream
BobJS->BobUA:       createOffer to get |offer-B2|
BobJS->BobUA:       setLocalDescription with |offer-B2|

//                  |offer-B2| is sent to Alice
BobJS->WebServer:   signaling with |offer-B2|
WebServer->AliceJS: signaling with |offer-B2|
AliceJS->AliceUA:   setRemoteDescription with |offer-B2|
AliceUA->AliceJS:   ontrack event with first video track
AliceUA->AliceJS:   ontrack event with second video track
AliceJS->AliceUA:   createAnswer to get |answer-B2|
AliceJS->AliceUA:   setLocalDescription with |answer-B2|

//                  |answer-B2| is sent over signaling protocol
//                  to Bob
AliceJS->WebServer: signaling with |answer-B2|
WebServer->BobJS:   signaling with |answer-B2|
BobJS->BobUA:       setRemoteDescription with |answer-B2|

//                  media is flowing between endpoints
BobUA->AliceUA:     audio+video+data sent from Bob to Alice
AliceUA->BobUA:     audio+video+data sent from Alice to Bob ]]></artwork>

	   <t>The SDP for |offer-B1| looks like:</t>
	   <sourcecode name="offer-B1" type="sdp"><![CDATA[
v=0
o=- 4962303333179871723 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 d1

m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 0.0.0.0
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:57017fee-b6c1-4162-929c-a25110252400
a=ice-ufrag:ATEn
a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256
              29:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:
              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=tls-id:17f0f4ba8a5f1213faca591b58ba52a7
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize

m=application 0 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 0.0.0.0
a=mid:d1
a=sctp-port:5000
a=max-message-size:65536
a=bundle-only ]]></sourcecode>

	   <t>|offer-B1-candidate-1| looks like:</t>

	   <sourcecode name="offer-B1-candidate-1" type="sdp"><![CDATA[
ufrag ATEn
index 0
mid   a1
attr  candidate:1 1 udp 2113929471 203.0.113.100 10100 typ host ]]></sourcecode>
	   <t>|offer-B1-candidate-2| looks like:</t>
	   <sourcecode name="offer-B1-candidate-2" type="sdp"><![CDATA[
ufrag ATEn
index 0
mid   a1
attr  candidate:1 1 udp 1845494015 198.51.100.100 11100 typ srflx
                raddr 203.0.113.100 rport 10100 ]]></sourcecode>
	   <t>|offer-B1-candidate-3| looks like:</t>
	   <sourcecode name="offer-B1-candidate-3" type="sdp"><![CDATA[
ufrag ATEn
index 0
mid   a1
attr  candidate:1 1 udp 255 192.0.2.100 12100 typ relay
                raddr 198.51.100.100 rport 11100 ]]></sourcecode>
	   <t>The SDP for |answer-B1| looks like:</t>
	   <sourcecode name="answer-B1" type="sdp"><![CDATA[
v=0
o=- 7729291447651054566 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 d1

m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 0.0.0.0
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:71317484-2ed4-49d7-9eb7-1414322a7aae
a=ice-ufrag:7sFv
a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256
              7B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35:
              DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:active
a=tls-id:7a25ab85b195acaf3121f5a8ab4f0f71
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize

m=application 9 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 0.0.0.0
a=mid:d1
a=sctp-port:5000
a=max-message-size:65536 ]]></sourcecode>

	   <t>|answer-B1-candidate-1| looks like:</t>

	   <sourcecode name="answer-B1-candidate-1" type="sdp"><![CDATA[
ufrag 7sFv
index 0
mid   a1
attr  candidate:1 1 udp 2113929471 203.0.113.200 10200 typ host ]]></sourcecode>
	   <t>|answer-B1-candidate-2| looks like:</t>
	   <sourcecode name="answer-B1-candidate-2" type="sdp"><![CDATA[
ufrag 7sFv
index 0
mid   a1
attr  candidate:1 1 udp 1845494015 198.51.100.200 11200 typ srflx
                raddr 203.0.113.200 rport 10200 ]]></sourcecode>
	   <t>|answer-B1-candidate-3| looks like:</t>
	   <sourcecode name="answer-B1-candidate-3" type="sdp"><![CDATA[
ufrag 7sFv
index 0
mid   a1
attr  candidate:1 1 udp 255 192.0.2.200 12200 typ relay
                raddr 198.51.100.200 rport 11200 ]]></sourcecode>
	   <t>The SDP for |offer-B2| is shown below. In addition to the
	   new "m=" sections for video, both of which are offering FEC and
	   one of which is offering simulcast, note the increment of the
	   version number in the "o=" line; changes to the "c=" line,
	   indicating the local candidate that was selected; and the
	   inclusion of gathered candidates as a=candidate lines.</t>
	   <sourcecode name="offer-B2" type="sdp"><![CDATA[
v=0
o=- 7729291447651054566 2 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 d1 v1 v2
a=group:LS a1 v1

m=audio 12200 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 192.0.2.200
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:71317484-2ed4-49d7-9eb7-1414322a7aae
a=ice-ufrag:7sFv
a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256
              7B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35:
              DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:actpass
a=tls-id:7a25ab85b195acaf3121f5a8ab4f0f71
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize
a=candidate:1 1 udp 2113929471 203.0.113.200 10200 typ host
a=candidate:1 1 udp 1845494015 198.51.100.200 11200 typ srflx
            raddr 203.0.113.200 rport 10200
a=candidate:1 1 udp 255 192.0.2.200 12200 typ relay
            raddr 198.51.100.200 rport 11200
a=end-of-candidates

m=application 12200 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 192.0.2.200
a=mid:d1
a=sctp-port:5000
a=max-message-size:65536

m=video 12200 UDP/TLS/RTP/SAVPF 100 101 102 103 104
c=IN IP4 192.0.2.200
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
a=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=rtpmap:104 flexfec/90000
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:71317484-2ed4-49d7-9eb7-1414322a7aae
a=rid:1 send
a=rid:2 send
a=rid:3 send
a=simulcast:send 1;2;3

m=video 12200 UDP/TLS/RTP/SAVPF 100 101 102 103 104
c=IN IP4 192.0.2.200
a=mid:v2
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
a=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=rtpmap:104 flexfec/90000
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:81317484-2ed4-49d7-9eb7-1414322a7aae ]]></sourcecode>
	   <t>The SDP for |answer-B2| is shown below. In addition to the
	   acceptance of the video "m=" sections, the use of a=recvonly to
	   indicate one-way video, and the use of a=imageattr to limit the
	   received resolution, note the use of setup:passive to maintain
	   the existing DTLS roles.</t>
	   <sourcecode name="answer-B2" type="sdp"><![CDATA[
v=0
o=- 4962303333179871723 2 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 d1 v1 v2
a=group:LS a1 v1

m=audio 12100 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 192.0.2.100
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:57017fee-b6c1-4162-929c-a25110252400
a=ice-ufrag:ATEn
a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256
              29:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:
              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:passive
a=tls-id:17f0f4ba8a5f1213faca591b58ba52a7
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize
a=candidate:1 1 udp 2113929471 203.0.113.100 10100 typ host
a=candidate:1 1 udp 1845494015 198.51.100.100 11100 typ srflx
            raddr 203.0.113.100 rport 10100
a=candidate:1 1 udp 255 192.0.2.100 12100 typ relay
            raddr 198.51.100.100 rport 11100
a=end-of-candidates

m=application 12100 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 192.0.2.100
a=mid:d1
a=sctp-port:5000
a=max-message-size:65536

m=video 12100 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 192.0.2.100
a=mid:v1
a=recvonly
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
a=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=imageattr:100 recv [x=[48:1920],y=[48:1080],q=1.0]
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli

m=video 12100 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 192.0.2.100
a=mid:v2
a=recvonly
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
a=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=imageattr:100 recv [x=[48:1920],y=[48:1080],q=1.0]
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli ]]></sourcecode>
	 </section>
	 <section anchor="sec.warmup-example" numbered="true" toc="default">
	   <name>Early Transport Warmup Example</name>
	   <t>This example demonstrates the early-warmup technique
	   described in
	   <xref target="sec.use-of-provisional-answer" format="default"/>. Here, Alice's
	   endpoint sends an offer to Bob's endpoint to start an
	   audio/video call. Bob immediately responds with an answer that
	   accepts the audio/video "m=" sections but marks them as sendonly
	   (from his perspective), meaning that Alice will not yet send
	   media. This allows the JSEP implementation to start negotiating
	   ICE and DTLS immediately. Bob's endpoint then prompts him to
	   answer the call, and when he does, his endpoint sends a second
	   offer, which enables the audio and video "m=" sections, and
	   thereby bidirectional media transmission. The advantage of such
	   a flow is that as soon as the first answer is received, the
	   implementation can proceed with ICE and DTLS negotiation and
	   establish the session transport. If the transport setup
	   completes before the second offer is sent, then media can be
	   transmitted by the callee immediately upon
	   answering the call, minimizing perceived post-dial delay. The
	   second offer/answer exchange can also change the preferred
	   codecs or other session parameters.</t>
	   <t>This example also makes use of the "relay" ICE candidate
	   policy described in
	   <xref target="sec.ice-candidate-policy" format="default"/> to minimize the ICE
	   gathering and checking needed.</t>

	   <artwork name="" type="ascii-art" align="left" alt=""><![CDATA[
//                  set up local media state
AliceJS->AliceUA:   create new PeerConnection with "relay" ICE policy
AliceJS->AliceUA:   addTrack with two tracks: audio and video
AliceJS->AliceUA:   createOffer to get |offer-C1|
AliceJS->AliceUA:   setLocalDescription with |offer-C1|

//                  |offer-C1| is sent over signaling protocol to Bob
AliceJS->WebServer: signaling with |offer-C1|
WebServer->BobJS:   signaling with |offer-C1|

//                  |offer-C1| arrives at Bob
BobJS->BobUA:       create new PeerConnection with "relay" ICE policy
BobJS->BobUA:       setRemoteDescription with |offer-C1|
BobUA->BobJS:       ontrack events for audio and video

//                  a relay candidate is sent to Bob
AliceUA->AliceJS:   onicecandidate (relay) |offer-C1-candidate-1|
AliceJS->WebServer: signaling with |offer-C1-candidate-1|

WebServer->BobJS:   signaling with |offer-C1-candidate-1|
BobJS->BobUA:       addIceCandidate with |offer-C1-candidate-1|

//                  Bob prepares an early answer to warm up the
//                  transport
BobJS->BobUA:       addTransceiver with null audio and video tracks
BobJS->BobUA:       transceiver.setDirection(sendonly) for both
BobJS->BobUA:       createAnswer
BobJS->BobUA:       setLocalDescription with answer

//                  |answer-C1| is sent over signaling protocol
//                  to Alice
BobJS->WebServer:   signaling with |answer-C1|
WebServer->AliceJS: signaling with |answer-C1|

//                  |answer-C1| (sendonly) arrives at Alice
AliceJS->AliceUA:   setRemoteDescription with |answer-C1|
AliceUA->AliceJS:   ontrack events for audio and video

//                  a relay candidate is sent to Alice
BobUA->BobJS:       onicecandidate (relay) |answer-B1-candidate-1|
BobJS->WebServer:   signaling with |answer-B1-candidate-1|

WebServer->AliceJS: signaling with |answer-B1-candidate-1|
AliceJS->AliceUA:   addIceCandidate with |answer-B1-candidate-1|

//                  ICE and DTLS establish while call is ringing

//                  Bob accepts call, starts media, and sends
//                  new offer
BobJS->BobUA:       transceiver.setTrack with audio and video tracks
BobUA->AliceUA:     media sent from Bob to Alice
BobJS->BobUA:       transceiver.setDirection(sendrecv) for both
                    transceivers
BobJS->BobUA:       createOffer
BobJS->BobUA:       setLocalDescription with offer

//                  |offer-C2| is sent over signaling protocol
//                  to Alice
BobJS->WebServer:   signaling with |offer-C2|
WebServer->AliceJS: signaling with |offer-C2|

//                  |offer-C2| (sendrecv) arrives at Alice
AliceJS->AliceUA:   setRemoteDescription with |offer-C2|
AliceJS->AliceUA:   createAnswer
AliceJS->AliceUA:   setLocalDescription with |answer-C2|
AliceUA->BobUA:     media sent from Alice to Bob

//                  |answer-C2| is sent over signaling protocol
//                  to Bob
AliceJS->WebServer: signaling with |answer-C2|
WebServer->BobJS:   signaling with |answer-C2|
BobJS->BobUA:       setRemoteDescription with |answer-C2| ]]></artwork>
	   <t>The SDP for |offer-C1| looks like:</t>
	   <sourcecode name="offer-C1" type="sdp"><![CDATA[
v=0
o=- 1070771854436052752 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 0.0.0.0
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce
a=ice-ufrag:4ZcD
a=ice-pwd:ZaaG6OG7tCn4J/lehAGz+HHD
a=fingerprint:sha-256
              C4:68:F8:77:6A:44:F1:98:6D:7C:9F:47:EB:E3:34:A4:
              0A:AA:2D:49:08:28:70:2E:1F:AE:18:7D:4E:3E:66:BF
a=setup:actpass
a=tls-id:9e5b948ade9c3d41de6617b68f769e55
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize

m=video 0 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 0.0.0.0
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
a=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce
a=bundle-only ]]></sourcecode>
	   <t>|offer-C1-candidate-1| looks like:</t>
	   <sourcecode name="offer-C1-candidate-1" type="sdp"><![CDATA[
ufrag 4ZcD
index 0
mid   a1
attr  candidate:1 1 udp 255 192.0.2.100 12100 typ relay
                raddr 0.0.0.0 rport 0 ]]></sourcecode>
	   <t>The SDP for |answer-C1| looks like:</t>
	   <sourcecode name="answer-C1" type="sdp"><![CDATA[
v=0
o=- 6386516489780559513 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 0.0.0.0
a=mid:a1
a=sendonly
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:751f239e-4ae0-c549-aa3d-890de772998b
a=ice-ufrag:TpaA
a=ice-pwd:t2Ouhc67y8JcCaYZxUUTgKw/
a=fingerprint:sha-256
              A2:F3:A5:6D:4C:8C:1E:B2:62:10:4A:F6:70:61:C4:FC:
              3C:E0:01:D6:F3:24:80:74:DA:7C:3E:50:18:7B:CE:4D
a=setup:active
a=tls-id:55e967f86b7166ed14d3c9eda849b5e9
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize

m=video 9 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 0.0.0.0
a=mid:v1
a=sendonly
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
a=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:751f239e-4ae0-c549-aa3d-890de772998b ]]></sourcecode>
	   <t>|answer-C1-candidate-1| looks like:</t>
	   <sourcecode name="answer-C1-candidate-1" type="sdp"><![CDATA[
ufrag TpaA
index 0
mid   a1
attr  candidate:1 1 udp 255 192.0.2.200 12200 typ relay
                raddr 0.0.0.0 rport 0 ]]></sourcecode>
	   <t>The SDP for |offer-C2| looks like:</t>
	   <sourcecode name="offer-C2" type="sdp"><![CDATA[
v=0
o=- 6386516489780559513 2 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 12200 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 192.0.2.200
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:751f239e-4ae0-c549-aa3d-890de772998b
a=ice-ufrag:TpaA
a=ice-pwd:t2Ouhc67y8JcCaYZxUUTgKw/
a=fingerprint:sha-256
              A2:F3:A5:6D:4C:8C:1E:B2:62:10:4A:F6:70:61:C4:FC:
              3C:E0:01:D6:F3:24:80:74:DA:7C:3E:50:18:7B:CE:4D
a=setup:actpass
a=tls-id:55e967f86b7166ed14d3c9eda849b5e9
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize
a=candidate:1 1 udp 255 192.0.2.200 12200 typ relay
            raddr 0.0.0.0 rport 0
a=end-of-candidates

m=video 12200 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 192.0.2.200
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
a=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:751f239e-4ae0-c549-aa3d-890de772998b ]]></sourcecode>
	   <t>The SDP for |answer-C2| looks like:</t>
	   <sourcecode name="answer-C2" type="sdp"><![CDATA[
v=0
o=- 1070771854436052752 2 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 12100 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 192.0.2.100
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce
a=ice-ufrag:4ZcD
a=ice-pwd:ZaaG6OG7tCn4J/lehAGz+HHD
a=fingerprint:sha-256
              C4:68:F8:77:6A:44:F1:98:6D:7C:9F:47:EB:E3:34:A4:
              0A:AA:2D:49:08:28:70:2E:1F:AE:18:7D:4E:3E:66:BF
a=setup:passive
a=tls-id:9e5b948ade9c3d41de6617b68f769e55
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize
a=candidate:1 1 udp 255 192.0.2.100 12100 typ relay
            raddr 0.0.0.0 rport 0
a=end-of-candidates

m=video 12100 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 192.0.2.100
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
a=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce ]]></sourcecode>
	 </section>
       </section>
       <section anchor="sec.security-considerations" numbered="true" toc="default">
	 <name>Security Considerations</name>
	 <t>The IETF has published separate documents
	 <xref target="RFC8827" format="default"/>
	   <xref target="RFC8826" format="default"/> describing the security
	 architecture for WebRTC as a whole. The remainder of this section
	 describes security considerations for this document.</t>
	 <t>While formally the JSEP interface is an API, it is better to
	 think of it as an Internet protocol, with the application
	 JavaScript being untrustworthy from the perspective of the JSEP
	 implementation. Thus, the threat model of
	 <xref target="RFC3552" format="default"/> applies. In particular, JavaScript can
	 call the API in any order and with any inputs, including
	 malicious ones. This is particularly relevant when we consider
	 the SDP that is passed to setLocalDescription. While correct
	 API usage requires that the application pass in SDP that was
	 derived from createOffer or createAnswer, there is no
	 guarantee that applications do so. The JSEP implementation <bcp14>MUST</bcp14>
	 be prepared for the JavaScript to pass in bogus data instead.</t>
	 <t>Conversely, the application programmer needs to be aware that
	 the JavaScript does not have complete control of endpoint
	 behavior. One case that bears particular mention is that editing
	 ICE candidates out of the SDP or suppressing trickled candidates
	 does not have the expected behavior: implementations will still
	 perform checks from those candidates even if they are not sent to
	 the other side. Thus, for instance, it is not possible to prevent
	 the remote peer from learning your public IP address by removing
	 server-reflexive candidates. Applications that wish to conceal
	 their public IP address <bcp14>MUST</bcp14> instead configure the ICE agent to
	 use only relay candidates.</t>
       </section>
       <section anchor="sec.iana-considerations" numbered="true" toc="default">
	 <name>IANA Considerations</name>
	 <t>This document has no IANA actions.</t>
       </section>
     </middle>
     <back>
   <displayreference target="I-D.ietf-rtcweb-sdp" to="SDP4WebRTC"/>
    <references>
	 <name>References</name>
	 <references>
	   <name>Normative References</name>

	   <reference anchor="RFC8840" target="https://www.rfc-editor.org/info/rfc8840">
	     <front>
	       <title>A Session Initiation Protocol (SIP) Usage for Incremental
	       Provisioning of Candidates for the Interactive Connectivity
	       Establishment (Trickle ICE)</title>

	       <author initials="E" surname="Ivov" fullname="Emil Ivov">
		 <organization/>
	       </author>
	       <author initials="T" surname="Stach" fullname="Thomas Stach">
		 <organization/>
	       </author>
	       <author initials="E" surname="Marocco" fullname="Enrico Marocco">
		 <organization/>
	       </author>
	       <author initials="C" surname="Holmberg" fullname="Christer Holmberg">
		 <organization/>
	       </author>
	       <date month="January" year="2021"/>
	     </front>
	     <seriesInfo name="RFC" value="8840"/>
	     <seriesInfo name="DOI" value="10.17487/RFC8840"/>
	   </reference>

<reference anchor="RFC8852" target="https://www.rfc-editor.org/info/rfc8852">
  <front>
    <title>RTP Stream Identifier Source Description (SDES)</title>
    <author initials="A.B." surname="Roach" fullname="Adam Roach"/>
    <author initials="S" surname="Nandakumar" fullname="Suhas Nandakumar"/>
    <author initials="P" surname="Thatcher" fullname="Peter Thatcher"/>
    <date month="January" year="2021"/>
  </front>
    <seriesInfo name="RFC" value="8852"/>
    <seriesInfo name="DOI" value="10.17487/RFC8852"/>
</reference>


<reference anchor="RFC8838" target="https://www.rfc-editor.org/info/rfc8838">
  <front>
    <title>Trickle ICE: Incremental Provisioning of Candidates for the
    Interactive Connectivity Establishment (ICE) Protocol</title>

    <author initials="E" surname="Ivov" fullname="Emil Ivov">
	 <organization />
    </author>

    <author initials="J" surname="Uberti" fullname="Justin Uberti">
	 <organization />
    </author>

    <author initials="P" surname="Saint-Andre" fullname="Peter Saint-Andre">
	 <organization />
    </author>

    <date month="January" year="2021" />
  </front>
  <seriesInfo name="RFC" value="8838" />
  <seriesInfo name="DOI" value="10.17487/RFC8838"/>
</reference>


<reference anchor="RFC8842" target="https://www.rfc-editor.org/info/rfc8842">

  <front>
    <title>Session Description Protocol (SDP) Offer/Answer Considerations for
Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)</title>

    <author initials="C." surname="Holmberg" fullname="Christer Holmberg">
	<organization />
    </author>

    <author initials="R." surname="Shpount" fullname="Roman Shpount">
	<organization />
    </author>

    <date month="January" year="2021" />
  </front>
  <seriesInfo name="RFC" value="8842" />
  <seriesInfo name="DOI" value="10.17487/RFC8842"/>

</reference>



<reference anchor='RFC8839' target="https://www.rfc-editor.org/info/rfc8839">
<front>
<title>Session Description Protocol (SDP) Offer/Answer Procedures for Interactive Connectivity Establishment (ICE)</title>

<author initials='M' surname='Petit-Huguenin' fullname='Marc Petit-Huguenin'>
    <organization />
</author>

<author initials='S' surname='Nandakumar' fullname='Suhas Nandakumar'>
    <organization />
</author>

<author initials='C' surname='Holmberg' fullname='Christer Holmberg'>
    <organization />
</author>

<author initials='A' surname='Keränen' fullname='Ari Keränen'>
    <organization />
</author>

<author initials='R' surname='Shpount' fullname='Roman Shpount'>
    <organization />
</author>

<date month="January" year="2021"/>

</front>
<seriesInfo name="RFC" value="8839"/>
<seriesInfo name="DOI" value="10.17487/RFC8839"/>

</reference>


<reference anchor="RFC8830" target="https://www.rfc-editor.org/info/rfc8830">
  <front>
    <title>WebRTC MediaStream Identification in the Session Description Protocol</title>
    <author initials="H" surname="Alvestrand" fullname="Harald Alvestrand">
      <organization />
    </author>
    <date month="January" year="2021" />
  </front>
  <seriesInfo name="RFC" value="8830" />
  <seriesInfo name="DOI" value="10.17487/RFC8830"/>
</reference>


<reference anchor='RFC8858' target="https://www.rfc-editor.org/info/rfc8858">
<front>
<title>Indicating Exclusive Support of RTP and RTP Control Protocol (RTCP)
       Multiplexing Using the Session Description Protocol (SDP)</title>
<author initials='C.' surname='Holmberg' fullname='Christer Holmberg'>
    <organization />
</author>

<date month="January" year='2021' />
</front>
<seriesInfo name='RFC' value='8858' />
<seriesInfo name="DOI" value="10.17487/RFC8858"/>
</reference>


<reference anchor="RFC8851" target="https://www.rfc-editor.org/info/rfc8851">
  <front>
    <title>RTP Payload Format Restrictions</title>
    <author initials="A.B." surname="Roach" fullname="Adam Roach" role="editor">
      <organization/>
    </author>
    <date month="January" year="2021"/>
  </front>
    <seriesInfo name="RFC" value="8851"/>
    <seriesInfo name="DOI" value="10.17487/RFC8851"/>
</reference>


<reference anchor="RFC8841" target="https://www.rfc-editor.org/info/rfc8841">

  <front>
    <title>Session Description Protocol (SDP) Offer/Answer Procedures for
    Stream Control Transmission Protocol (SCTP) over Datagram Transport Layer
    Security (DTLS) Transport</title>

    <author initials="C." surname="Holmberg" fullname="Christer Holmberg">
      <organization />
    </author>

    <author initials="R." surname="Shpount" fullname="Roman Shpount">
      <organization />
    </author>

    <author initials="S." surname="Loreto" fullname="Salvatore Loreto">
      <organization />
    </author>

    <author initials="G." surname="Camarillo" fullname="Gonzalo Camarillo">
      <organization />
    </author>

    <date month="January" year="2021" />
  </front>
  <seriesInfo name="RFC" value="8841" />
  <seriesInfo name="DOI" value="10.17487/RFC8841"/>

</reference>


    <reference anchor="RFC8843" target="https://www.rfc-editor.org/info/rfc8843">
      <front>
        <title>Negotiating Media Multiplexing Using the Session Description Protocol (SDP)</title>
        <author initials="C" surname="Holmberg" fullname="Christer Holmberg">
          <organization/>
        </author>
        <author initials="H" surname="Alvestrand" fullname="Harald Alvestrand">
          <organization/>
        </author>
        <author initials="C" surname="Jennings" fullname="Cullen Jennings">
          <organization/>
        </author>
        <date month="January" year="2021"/>
      </front>
        <seriesInfo name="RFC" value="8843"/>
        <seriesInfo name="DOI" value="10.17487/RFC8843"/>
    </reference>

<reference anchor="RFC8859" target="https://www.rfc-editor.org/info/rfc8859">
  <front>
    <title>A Framework for Session Description Protocol (SDP)
    Attributes When Multiplexing</title>
    <author initials="S" surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization/>
    </author>
    <date month="January" year="2021"/>
  </front>
    <seriesInfo name="RFC" value="8859"/>
    <seriesInfo name="DOI" value="10.17487/RFC8859"/>

</reference>

<reference anchor="RFC8853" target="https://www.rfc-editor.org/info/rfc8853">
  <front>
    <title>Using Simulcast in Session Description Protocol (SDP) and RTP
    Sessions</title>

    <author initials="B" surname="Burman" fullname="Bo Burman">
      <organization/>
    </author>
    <author initials="M" surname="Westerlund" fullname="Magnus Westerlund">
      <organization/>
    </author>
    <author initials="S" surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization/>
    </author>
    <author initials="M" surname="Zanaty" fullname="Mo Zanaty">
      <organization/>
    </author>
    <date month="January" year="2021"/>
  </front>
    <seriesInfo name="RFC" value="8853"/>
    <seriesInfo name="DOI" value="10.17487/RFC8853"/>
</reference>


<reference anchor="RFC8854" target="https://www.rfc-editor.org/info/rfc8854">
  <front>
    <title>WebRTC Forward Error Correction Requirements</title>
    <author initials="J." surname="Uberti" fullname="Justin Uberti">
      <organization/>
    </author>
    <date month="January" year="2021"/>
  </front>
    <seriesInfo name="RFC" value="8854"/>
    <seriesInfo name="DOI" value="10.17487/RFC8854"/>
</reference>


<reference anchor="RFC8834" target="https://www.rfc-editor.org/info/rfc8834">
  <front>
    <title>Media Transport and Use of RTP in WebRTC</title>
    <author initials="C." surname="Perkins" fullname="Colin Perkins">
      <organization />
    </author>
    <author initials="M." surname="Westerlund" fullname="Magnus Westerlund">
      <organization />
    </author>
    <author initials="J." surname="Ott" fullname="Jörg Ott">
      <organization />
    </author>
    <date month="January" year="2021" />
  </front>
  <seriesInfo name="RFC" value="8834" />
  <seriesInfo name="DOI" value="10.17487/RFC8834"/>
</reference>


<reference anchor="RFC8826" target="https://www.rfc-editor.org/info/rfc8826">
<front>
<title>Security Considerations for WebRTC</title>
<author initials='E.' surname='Rescorla' fullname='Eric Rescorla'>
  <organization/>
</author>
<date month='January' year='2021'/>
</front>
<seriesInfo name="RFC" value="8826"/>
<seriesInfo name="DOI" value="10.17487/RFC8826"/>
</reference>


<reference anchor="RFC8827" target="https://www.rfc-editor.org/info/rfc8827">
<front>
<title>WebRTC Security Architecture</title>
<author initials='E.' surname='Rescorla' fullname='Eric Rescorla'>
  <organization/>
</author>
<date month='January' year='2021'/>
</front>
<seriesInfo name="RFC" value="8827"/>
<seriesInfo name="DOI" value="10.17487/RFC8827"/>
</reference>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3261.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3264.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3605.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3890.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4145.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4566.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4585.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5124.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5285.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5761.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5888.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6236.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6347.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6716.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6904.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7160.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7587.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7742.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7850.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7874.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8108.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8122.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8445.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3711.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8829.xml"/>
      </references>
      <references>
        <name>Informative References</name>

<reference anchor="RFC8828" target="https://www.rfc-editor.org/info/rfc8828">
  <front>
    <title>WebRTC IP Address Handling Requirements</title>
    <author initials="J" surname="Uberti" fullname="Justin Uberti">
      <organization />
    </author>
    <author initials="G" surname="Shieh" fullname="Guo-wei Shieh">
      <organization />
    </author>

    <date month="January" year="2021" />
  </front>
  <seriesInfo name="RFC" value="8828" />
  <seriesInfo name="DOI" value="10.17487/RFC8828"/>
</reference>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-rtcweb-sdp.xml"/>

<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3389.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4568.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4588.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4733.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5245.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5506.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5576.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5763.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5764.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6120.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6464.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3556.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3960.xml"/>

        <reference anchor="W3C.webrtc"
                   target="https://www.w3.org/TR/2020/PR-webrtc-20201215/">
          <front>
            <title>WebRTC 1.0: Real-time Communication Between Browsers</title>
            <author fullname="Cullen Jennings" initials="C."
                    surname="Jennings" role="editor">
              <organization>Cisco</organization>
            </author>
            <author
                fullname="Henrik Boström"
                asciiFullname="Henrik Bostrom"
                initials="H."
                surname="Boström"
                asciiSurname="Bostrom"
                role="editor">
              <organization>Google</organization>
            </author>
            <author fullname="Jan-Ivar Bruaroey" initials="J."
                      surname="Bruaroey" role="editor">
              <organization>Mozilla</organization>
            </author>
            <date month="Dec" year="2020"/>
          </front>
          <refcontent>World Wide Web Consortium PR PR-webrtc-20201215</refcontent>
        </reference>

        <reference anchor="TS26.114" target="https://www.3gpp.org/DynaReport/26114.htm">
          <front>
            <title>3rd Generation Partnership Project; Technical
          Specification Group Services and System Aspects; IP
          Multimedia Subsystem (IMS); Multimedia Telephony; Media
          handling and interaction (Release 16)</title>
          <seriesInfo name="3GPP TS" value="26.114 V16.3.0"/>
            <author>
              <organization>3GPP</organization>
            </author>
            <date year="2019" month="September"/>
          </front>
        </reference>

      </references>
    </references>
    <section anchor="sec.appendix-a" numbered="true" toc="default">
      <name>SDP ABNF Syntax</name>
      <t>For the syntax validation performed in
      <xref target="sec.parsing-a-desc" format="default"/>, the following list of ABNF
      definitions is used:</t>
      <table anchor="sdp-abnf" align="center">
        <name>SDP ABNF References</name>
        <thead>
          <tr>
            <th align="left">Attribute</th>
            <th align="left">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">ptime</td>
            <td align="left">
              <xref target="RFC4566" sectionFormat="of" section="6"/></td>
          </tr>
          <tr>
            <td align="left">maxptime</td>
            <td align="left">
              <xref target="RFC4566" sectionFormat="of" section="6"/></td>
          </tr>
          <tr>
            <td align="left">rtpmap</td>
            <td align="left">
              <xref target="RFC4566" sectionFormat="of" section="6"/></td>
          </tr>
          <tr>
            <td align="left">recvonly</td>
            <td align="left">
              <xref target="RFC4566" sectionFormat="of" section="9"/></td>
          </tr>
          <tr>
            <td align="left">sendrecv</td>
            <td align="left">
              <xref target="RFC4566" sectionFormat="of" section="9"/></td>
          </tr>
          <tr>
            <td align="left">sendonly</td>
            <td align="left">
              <xref target="RFC4566" sectionFormat="of" section="9"/></td>
          </tr>
          <tr>
            <td align="left">inactive</td>
            <td align="left">
              <xref target="RFC4566" sectionFormat="of" section="9"/></td>
          </tr>
          <tr>
            <td align="left">fmtp</td>
            <td align="left">
              <xref target="RFC4566" sectionFormat="of" section="9"/></td>
          </tr>
          <tr>
            <td align="left">rtcp</td>
            <td align="left">
              <xref target="RFC3605" sectionFormat="of" section="2.1"/></td>
          </tr>
          <tr>
            <td align="left">setup</td>
            <td align="left">
              <xref target="RFC4145" section="4" sectionFormat="of"/></td>
          </tr>
          <tr>
            <td align="left">fingerprint</td>
            <td align="left">
              <xref target="RFC8122" sectionFormat="of" section="5"/></td>
          </tr>
          <tr>
            <td align="left">rtcp-fb</td>
            <td align="left">
              <xref target="RFC4585" sectionFormat="of" section="4.2"/></td>
          </tr>
          <tr>
            <td align="left">extmap</td>
            <td align="left">
              <xref target="RFC5285" sectionFormat="of" section="7"/></td>
          </tr>
          <tr>
            <td align="left">mid</td>
            <td align="left">
              <xref target="RFC5888" section="4" sectionFormat="of"/></td>
          </tr>
          <tr>
            <td align="left">group</td>
            <td align="left">
             <xref target="RFC5888" section="5" sectionFormat="of"/></td>
          </tr>
          <tr>
            <td align="left">imageattr</td>
            <td align="left">
              <xref target="RFC6236" sectionFormat="of" section="3.1"/></td>
          </tr>
          <tr>
            <td align="left">extmap (encrypt option)</td>
            <td align="left">
              <xref target="RFC6904" sectionFormat="of" section="4"/></td>
          </tr>
          <tr>
            <td align="left">candidate</td>
            <td align="left">
              <xref target="RFC8839" sectionFormat="of" section="5.1"/></td>
          </tr>
          <tr>
            <td align="left">remote-candidates</td>
            <td align="left">
              <xref target="RFC8839" sectionFormat="of" section="5.2"/></td>
          </tr>
          <tr>
            <td align="left">ice-lite</td>
            <td align="left">
              <xref target="RFC8839" sectionFormat="of" section="5.3"/></td>
          </tr>
          <tr>
            <td align="left">ice-ufrag</td>
            <td align="left">
              <xref target="RFC8839" sectionFormat="of" section="5.4"/></td>
          </tr>
          <tr>
            <td align="left">ice-pwd</td>
            <td align="left">
              <xref target="RFC8839" sectionFormat="of" section="5.4"/></td>
          </tr>
          <tr>
            <td align="left">ice-options</td>
            <td align="left">
              <xref target="RFC8839" sectionFormat="of" section="5.6"/></td>
          </tr>
          <tr>
            <td align="left">msid</td>
            <td align="left">
              <xref target="RFC8830" sectionFormat="of" section="3"/></td>
          </tr>
          <tr>
            <td align="left">rid</td>
            <td align="left">
              <xref target="RFC8851" sectionFormat="of" section="10"/></td>
          </tr>
          <tr>
            <td align="left">simulcast</td>
            <td align="left">
              <xref target="RFC8853" sectionFormat="of" section="5.1"/></td>
          </tr>
          <tr>
            <td align="left">tls-id</td>
            <td align="left">
              <xref target="RFC8842" sectionFormat="of" section="4"/></td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="sec.acknowledgements" numbered="false" toc="default">
      <name>Acknowledgements</name>
      <t><contact fullname="Harald Alvestrand"/>, <contact fullname="Taylor
      Brandstetter"/>, <contact fullname="Suhas Nandakumar"/>, and
      <contact fullname="Peter Thatcher"/> provided significant text for this
      document. <contact fullname="Bernard Aboba"/>, <contact fullname="Adam
      Bergkvist"/>, <contact fullname="Jan-Ivar Bruaroey"/>,
      <contact fullname="Dan Burnett"/>, <contact fullname="Ben
      Campbell"/>, <contact fullname="Alissa Cooper"/>,
      <contact fullname="Richard Ejzak"/>, <contact fullname="Stefan
      Håkansson"/>, <contact fullname="Ted Hardie"/>, <contact fullname="Christer Holmberg"/>,
      <contact fullname="Andrew Hutton"/>, <contact fullname="Randell
      Jesup"/>, <contact fullname="Matthew Kaufman"/>, <contact fullname="Anant Narayanan"/>,
      <contact fullname="Adam Roach"/>, <contact fullname="Robert Sparks"/>,
      <contact fullname="Neil Stratford"/>, <contact fullname="Martin
      Thomson"/>, <contact fullname="Sean
      Turner"/>, and <contact fullname="Magnus Westerlund"/> all provided valuable feedback on
      this document.</t>
    </section>
  </back>
</rfc>
